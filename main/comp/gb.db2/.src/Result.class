' Gambas class file

Export

Property Read Count, Length As Integer
Property Read Max As Integer
Property Read Available As Boolean
Property Read Index As Integer Use $iIndex = -1
Property Read Editable As Boolean
Property Read Connection As Connection
Property Read Fields As Collection

Private Enum MODE_FIND, MODE_EDIT, MODE_CREATE

Private $iMode As Integer
Private $hDriver As _DatabaseDriver

Static Private $pNull As Pointer = VarPtr($pNull)

Private $pHandle As Pointer
Private $iCount As Integer
Private $vBuffer As Variant[]
Private $cBuffer As Collection
Private $aField As String[]
Private $cFieldIndex As Collection
Private $cFields As Collection
Private $aTypes As Integer[]
Private $cTypes As Collection
Private $aLengths As Integer[]
Private $cIsBlob As Collection

Private $sTable As String
Private $bNotExist As Boolean
Private $aKey As String[]
Private $hDeleteMap As New DeleteMap

Private $bReturning As Boolean
Private $aReturning As String[]

Public Sub _free()
  
  If $pHandle Then $hDriver.FreeResult($pHandle)
  
End

Private Sub InitFields()
  
  Dim I As Integer
  Dim sName As String
  Dim iType As Integer
  Dim iLength As Integer
  Dim iPos As Integer
  
  $aField = New String[]
  $aTypes = New Integer[]
  $cTypes = New Collection
  $aLengths = New Integer[]
  
  $cFieldIndex = New Collection
  $cFieldIndex.Default = -1
  
  While Not $hDriver.GetResultField($pHandle, I, ByRef sName, ByRef iType, ByRef iLength)
    
    $aField.Add(sName)
    $aTypes.Add(iType)
    $aLengths.Add(iLength)
    
    $cTypes[I] = iType
    
    $cFieldIndex[sName] = $aField.Max
    $cTypes[sName] = iType

    iPos = InStr(sName, ".")
    If iPos > 1 Then
      sName = Mid$(sName, iPos + 1)
      If sName And If Not $cFieldIndex.Exist(sName) Then
        $cFieldIndex[sName] = $aField.Max
        $cTypes[sName] = iType
      Endif
    Endif
    
    Inc I
  Wend
  
  If $hDriver.MustQuoteBlob Then
    $cIsBlob = New Collection
    For I = 0 To $aField.Max
      If $aTypes[I] = db.Blob Then $cIsBlob[$aField[I]] = True
    Next
  Endif
  
End

Public Sub _Fill(hDriver As _DatabaseDriver, pHandle As Pointer)
  
  $hDriver = hDriver
  $pHandle = pHandle
  $iCount = $hDriver.GetResultCount(pHandle)
  
  InitFields()
  
  MoveFirst()
  
End

Public Sub _Create(hDriver As _DatabaseDriver, sTable As String, bReturning As Boolean, bNotExist As Boolean)
  
  Dim hField As Field
  Dim hConn As Connection
  Dim iField As Integer
  Dim iType As Integer
  
  $iMode = MODE_CREATE
  $hDriver = hDriver
  $iCount = 1
  $sTable = sTable
  $cBuffer = New Collection
  $vBuffer = Null
  
  If bReturning And If $hDriver.NoReturning Then
    ' debug message
    bReturning = False
  Endif
  
  If bNotExist And If $hDriver.InsertIfNotExist = _DatabaseDriver.IGNORE_NONE Then
    Error.Raise("INSERT cannot ignore already existing rows for this connection")
  Endif
  
  hConn = Me.Connection
  If $hDriver.MustQuoteBlob Then $cIsBlob = New Collection
  
  $cTypes = New Collection
  For Each hField In hConn.Tables[sTable].Fields
    iType = hField.Type
    If $hDriver.MustQuoteBlob And If iType = db.Blob Then $cIsBlob[hField.Name] = True
    $cTypes[iField] = iType
    $cTypes[hField.Name] = iType
    Inc iField
  Next
  
  If bReturning Then
    $aReturning = New String[]
    For Each hField In hConn.Tables[sTable].Fields
      If hField.Type = db.Serial Then $aReturning.Add(hField.Name)
    Next
    If $aReturning.Count = 0 Then bReturning = False
  Endif
  
  $bReturning = bReturning
  $bNotExist = bNotExist
  
End

Public Sub _Edit(hDriver As _DatabaseDriver, sTable As String, pHandle As Pointer)

  _Fill(hDriver, pHandle)
  $iMode = MODE_EDIT
  $sTable = sTable
  $cBuffer = New Collection
  $aKey = $hDriver.GetTablePrimaryKey(sTable)
  If Not $aKey Then Error.Raise("Table '" & sTable & "' has no primary key")
  
End

Private Function Count_Read() As Integer

  Return $iCount

End

Private Function Max_Read() As Integer

  Return $iCount - 1

End

Private Function Available_Read() As Boolean

  If $iCount < 0 Then 
    If $vBuffer Then Return True
  Else
    If $iIndex >= 0 And If $iIndex < $iCount Then Return True
  Endif
  
End

Private Function Editable_Read() As Boolean

  Return $iMode <> MODE_FIND

End

Public Sub MoveTo(Index As Long) As Boolean
  
  Dim iRealIndex As Integer
  
  If $iCount >= 0 Then
    If Index < 0 Or If Index >= $iCount Then 
      $iIndex = -1
      Return True
    Endif
  Endif
  
  If Index = $iIndex Then Return
  
  iRealIndex = $hDeleteMap.ToReal(Index)
  
  $vBuffer = $hDriver.GetResultData($pHandle, iRealIndex, iRealIndex = $hDeleteMap.ToReal($iIndex) + 1)
  If Not $vBuffer Then Return True
  
  If $cBuffer Then $cBuffer.Clear
  $iIndex = Index
  
End

Public Sub MoveFirst() As Boolean
  
  Return MoveTo(0)
  
End

Public Sub MoveLast() As Boolean

  Return MoveTo($iCount - 1)  
  
End

Public Sub MovePrevious() As Boolean

  Return MoveTo($iIndex - 1)  
  
End

Public Sub MoveNext() As Boolean

  Return MoveTo($iIndex + 1)
  
End

Public Sub _next()
  
  If IsNull(Enum.Index) Then
    If MoveFirst() Then Enum.Stop
    Enum.Index = 1
  Else
    If MoveTo(Enum.Index) Then Enum.Stop
    Inc Enum.Index
  Endif
  
End

Private Sub CheckAvailable()

  If $iCount >= 0 Then
    If $iIndex < $iCount Then Return
  Else
    If $vBuffer Then Return
  Endif
  
  Error.Raise("Result not available")

End

Public Sub _get(Field As String) As Variant
  
  Dim iPos As Integer
  Dim vVal As Variant
  
  CheckAvailable()
  
  If $cBuffer And If $cBuffer.Exist(Field) Then 
    vVal = $cBuffer[Field]
    If TypeOf(vVal) = gb.Pointer Then vVal = Null
    Return vVal
  Endif
  
  If $iMode = MODE_CREATE Then Return Null
  
  If $vBuffer Then
  
    If IsInteger(Field) Then
      iPos = CInt(Field)
    Else 
      iPos = $cFieldIndex[Field]
    Endif
    
    If iPos >= 0 And If iPos < $cFieldIndex.Count Then
      If $aTypes[iPos] = db.Blob And If IsNull($vBuffer[iPos]) Then $vBuffer[iPos] = $hDriver.GetResultBlob($pHandle, $iIndex, iPos)
      Return $vBuffer[iPos]
    Endif
    
  Endif
  
  Error.Raise("Unknown field: " & Me.Connection.Quote(Field))
  
End

Public Sub _put(Value As Variant, Field As String)
  
  Dim iPos As Integer
  Dim iType As Integer
  
  If $iMode = MODE_FIND Then Error.Raise("Read-only result")
  
  CheckAvailable()
  
  If $iMode = MODE_EDIT Then
    If IsInteger(Field) Then
      iPos = CInt(Field)
    Else 
      iPos = $cFieldIndex[Field]
    Endif
    If $vBuffer[iPos] = Value Then
      $cBuffer.Remove(Field)
      Return
    Endif
  Endif
  
  If IsInteger(Field) Then 
    Try Field = $aField[Field]
    If Error Then Error.Raise("Unknow field: " & Me.Connection.Quote(Field))
  Endif
  
  Try iType = $cTypes[Field]
  If Error Then Error.Raise("Unknow field: " & Me.Connection.Quote(Field))
  
  If IsNull(Value) Then 
    Value = $pNull
  Else If TypeOf(Value) <> iType Then
    Select Case iType
      Case gb.Boolean
        Value = CBool(Value)
      Case gb.Integer
        Value = CInt(Value)
      Case gb.Long, db.Serial
        Value = CLong(Value)
      Case gb.Float
        Value = CFloat(Value)
      Case gb.Date
        Value = CDate(Value)
      Case Else 
        Value = CStr(Value)
    End Select
  Endif
  
  $cBuffer[Field] = Value
  
End

Private Function Connection_Read() As Connection

  Return Object.Parent($hDriver)

End

Private Function Fields_Read() As Collection

  Dim hResultField As ResultField
  Dim I As Integer
  
  If Not $cFields Then 
    
    $cFields = New Collection
    For I = 0 To $aField.Max
      hResultField = New ResultField
      Object.Attach(hResultField, Me, "ResultField")
      hResultField._Fill($aField[I], $aTypes[I], $aLengths[I])
      $cFields[$aField[I]] = hResultField
    Next
    $cFields.ReadOnly = True
    
  Endif
  
  Return $cFields

End

Private Sub GetKeyRequest() As String

  Dim bComma As Boolean
  Dim sKey As String
  Dim sReq As String

  bComma = False
  For Each sKey In $aKey
    If bComma Then
      sReq &= " AND "
    Else
      bComma = True
    Endif
    sReq &= Me.Connection.Quote(sKey) & " = " & $hDriver.Format(Me[sKey])
  Next
  
  Return sReq

End

Public Sub Update()
  
  Dim sReq As String
  Dim bComma As Boolean
  Dim vVal As Variant
  Dim pResult As Pointer
  Dim bBlob As Boolean
  Dim vReturn As Variant[]
  Dim I As Integer
  Dim hConn As Connection
  
  CheckAvailable()

  Select Case $iMode
    
    Case MODE_CREATE
      
      sReq = "INSERT"
      
      If $bNotExist And If $hDriver.InsertIfNotExist = _DatabaseDriver.IGNORE_INSERT Then sReq &= " IGNORE"
      
      sReq &= " INTO " & Me.Connection.Quote($sTable, True) 
      
      If $cBuffer.Count Then
      
        sReq &= " ( "
        
        sReq &= $cBuffer.Keys.Join(", ")
        
        sReq &= " ) VALUES ( "
        
        For Each vVal In $cBuffer
          
          If Not bComma Then
            bComma = True
          Else
            sReq &= ", "
          Endif
          
          If $hDriver.MustQuoteBlob Then bBlob = $cIsBlob.Exist($cBuffer.Key)
          sReq &= $hDriver.Format(vVal, bBlob)
          
        Next
        
        sReq &= " )"
      
      Endif
      
      If $bNotExist And If $hDriver.InsertIfNotExist = _DatabaseDriver.IGNORE_ON_CONFLICT Then sReq &= " ON CONFLICT DO NOTHING"
      
      If $bReturning Then
      
        hConn = Me.Connection
        
        sReq &= " RETURNING " & hConn.Quote($aReturning[0])
        
        For I = 1 To $aReturning.Max
          sReq &= ", " & hConn.Quote($aReturning[I])
        Next
      
        Try pResult = $hDriver.Query(sReq)
        If Error Then Error.Raise("Cannot create record: " & Error.Text)
        
        vReturn = $hDriver.GetResultData(pResult, 0, False)
        For I = 0 To $aReturning.Max
          $cBuffer[$aReturning[I]] = vReturn[I]
        Next
        
        $hDriver.FreeResult(pResult)
        
      Else
      
        Try $hDriver.Exec(sReq)
        If Error Then Error.Raise("Cannot create record: " & Error.Text)
        $cBuffer.Clear
      
      Endif
    
    Case MODE_EDIT
      
      If $cBuffer.Count = 0 Then Return
      
      sReq = "UPDATE " & Me.Connection.Quote($sTable, True) & " SET "
      
      For Each vVal In $cBuffer
        
        If Not bComma Then
          bComma = True
        Else
          sReq &= ", "
        Endif
        
        sReq &= Me.Connection.Quote($cBuffer.Key) & " = "
        If $hDriver.MustQuoteBlob Then bBlob = $cIsBlob.Exist($cBuffer.Key)
        sReq &= $hDriver.Format(vVal, bBlob)
        
      Next
      
      sReq &= " WHERE " & GetKeyRequest()
      
      Try $hDriver.Exec(sReq)
      If Error Then Error.Raise("Cannot modify record: " & Error.Text)
      
    Case Else 
      
      Error.Raise("Read-only result")
    
  End Select
  
End

Public Sub All(Field As String) As Array
  
  Dim iPos As Integer
  Dim I As Integer
  Dim aBoolean As Boolean[]
  Dim aInteger As Integer[]
  Dim aLong As Long[]
  Dim aFloat As Float[]
  Dim aDate As Date[]
  Dim aString As String[]
  
  ' TODO: Handle $iCount = -1
  
  CheckAvailable()

  If IsInteger(Field) Then
    iPos = CInt(Field)
  Else 
    iPos = $cFieldIndex[Field]
  Endif
  
  Select Case $aTypes[iPos]
    
    Case db.Boolean
      aBoolean = New Boolean[$iCount]
      For I = 0 To $iCount - 1
        aBoolean[I] = $hDriver.GetResultData($pHandle, I, True)[iPos]
      Next
      Return aBoolean
    
    Case db.Integer, db.Serial
      aInteger = New Integer[$iCount]
      For I = 0 To $iCount - 1
        aInteger[I] = $hDriver.GetResultData($pHandle, I, True)[iPos]
      Next
      Return aInteger
    
    Case db.Long
      aLong = New Long[$iCount]
      For I = 0 To $iCount - 1
        aLong[I] = $hDriver.GetResultData($pHandle, I, True)[iPos]
      Next
      Return aLong
    
    Case db.Float
      aFloat = New Float[$iCount]
      For I = 0 To $iCount - 1
        aFloat[I] = $hDriver.GetResultData($pHandle, I, True)[iPos]
      Next
      Return aFloat
    
    Case db.Date
      aDate = New Date[$iCount]
      For I = 0 To $iCount - 1
        aDate[I] = $hDriver.GetResultData($pHandle, I, True)[iPos]
      Next
      Return aDate
      
    Case db.Blob
      aString = New String[$iCount]
      For I = 0 To $iCount - 1
        aString[I] = $hDriver.GetResultBlob($pHandle, I, iPos)
      Next
      Return aString
    
    Case Else
      aString = New String[$iCount]
      For I = 0 To $iCount - 1
        aString[I] = $hDriver.GetResultData($pHandle, I, True)[iPos]
      Next
      Return aString
    
  End Select
  
End

Public Sub Delete(Optional Keep As Boolean)
  
  CheckAvailable()
  
  Select Case $iMode
    
    Case MODE_CREATE
      
      $cBuffer.Clear
      
    Case MODE_EDIT
      
      $hDriver.Exec("DELETE * FROM " & Me.Quote($sTable, True) & " WHERE " & GetKeyRequest())
      
      If Not Keep Then
        
        $hDeleteMap.Add($hDeleteMap.ToReal($iIndex))
        If $iCount >= 0 Then Dec $iCount
        
        For Each Enum
          If IsNull(Enum.Index) Then Continue
          If Enum.Index > $iIndex Then
            Dec Enum.Index
            If Enum.Index < 0 Then Enum.Stop
          Endif
        Next
        
      Endif
      
    Case Else
      
      Error.Raise("Read-only result")
    
  End Select
  
End

Public Sub Reset()
  
  Select Case $iMode
    
    Case MODE_CREATE, MODE_EDIT
      $cBuffer.Clear
      
    Case Else
      Error.Raise("Read-only result")
    
  End Select
  
End
