' Gambas class file

Export

Property Read Key As String
Property Read ParentKey As String
Property Text As String
Property Html As String
Property Image As String
Property Read Count, Children As Integer
Property Expanded As Boolean

Property Editable As Boolean
Property Selected As Boolean
Property Background As Integer
Property Foreground As Integer
Property Tag As Variant
Property Read Depth As Integer

Private $sKey As String
Private $sParent As String
Private $sText As String
Private $sHtml As String
Private $sImage As String
Private $bExpanded As Boolean
Private $bEditable As Boolean
Private $iBg As Integer = Color.Default
Private $iFg As Integer = Color.Default
Private $vTag As Variant

Private $aChildren As String[]
Private $aText As String[]

Static Public _Tree As WebTree

Public _Depth As Integer
Public _Rows As Integer
Public _Index As Integer
Public _GrandChildren As Integer

Event _Refresh

Private Sub GetTree() As WebTree
  
  Return Object.Parent(Me)
  
End

Public Sub _IsRoot() As Boolean
  
  Return Not $sKey
  
End

Public Sub _ComputeDepth()
  
  Dim hTree As WebTree
  Dim iDepth As Integer
  Dim sChild As String

  If $sParent Then 
    iDepth = GetTree()[$sParent]._Depth + 1
  Else
    iDepth = 0
  Endif
  
  If iDepth = _Depth Then Return
  
  _Depth = iDepth
  
  If Not $aChildren Then Return
  
  hTree = GetTree()
  
  For Each sChild In $aChildren
    hTree[sChild]._ComputeDepth()
  Next
  
End

Public Sub _ComputeGrandChildren()
  
  Dim sChild As String
  Dim hTree As WebTree
  
  _GrandChildren = 0
  If Not $aChildren Then Return
  
  hTree = GetTree()
  
  For Each sChild In $aChildren
    If hTree[sChild].Count Then Inc _GrandChildren
  Next
  
End

Public Sub _SetParent(sParent As String)
  
  $sParent = sParent
  _ComputeDepth()
  
End

Public Sub _new(sKey As String, sParent As String)
  
  $sKey = sKey
  $sParent = sParent
  
  _ComputeDepth()
  
  If sKey Then 
    _Rows = 1
    _ComputeRows(1)
  Else
    $bExpanded = True
  Endif
  
End

Public Sub _AddChild(sKey As String)
  
  If Not $aChildren Then $aChildren = New String[]
  $aChildren.Add(sKey)
  
  If $aChildren.Count = 1 Then 
    Try Inc GetTree()._GetParentItem(Me)._GrandChildren
  Endif
  
End

Public Sub _RemoveChild(hItem As _WebTreeItem)
  
  Dim hTree As WebTree = GetTree()
  Dim I As Integer
  
  Try $aChildren.Remove(hItem._Index)
  
  For I = hItem._Index To $aChildren.Max
    hTree[$aChildren[I]]._Index = I
  Next
  
  If $aChildren.Count = 0 Then
    $aChildren = Null
    Try Dec hTree._GetParentItem(Me)._GrandChildren
  Endif
  
End

Public Sub _GetChildren() As String[]
  
  Return $aChildren
  
End


Private Function Key_Read() As String

  Return $sKey

End

Private Function ParentKey_Read() As String

  Return $sParent

End

Private Function Text_Read() As String

  Return $sText

End

Private Sub Text_Write(Value As String)

  Dim hTree As WebTree = GetTree()

  If $sText = Value Then Return
  $sText = Value
  'If $iLock Then Return

  'If hTree.Sorted Then hTree._SortParent($sParent)
  'hTree._UpdateItemHeight(Me)
  hTree._RefreshView

End

Private Function Html_Read() As String

  Return $sHtml 

End

Private Sub Html_Write(Value As String)

  Dim hTree As WebTree = GetTree()

  If $sHtml = Value Then Return
  $sHtml = Value
  
  'If hTree.Sorted Then hTree._SortParent($sParent)
  'hTree._UpdateItemHeight(Me)
  hTree._RefreshView

End

Private Function Image_Read() As String

  Return $sImage

End

Private Sub Image_Write(Value As String)

  Dim hTree As WebTree = GetTree()
  
  If $sImage = Value Then Return
  $sImage = Value
  hTree._RefreshView
  
End

Private Function Count_Read() As Integer

  If $aChildren Then Return $aChildren.Count

End

Private Function Expanded_Read() As Boolean

  Return $bExpanded

End

Public Sub _ComputeRows(iAdd As Integer)

  Dim hTree As WebTree = GetTree()
  Dim sKey As String
  Dim hItem As _WebTreeItem
  
  sKey = $sParent
  While sKey
    hItem = hTree[sKey]
    If Not hItem.Expanded Then Return
    hItem._Rows += iAdd
    sKey = hItem.ParentKey
  Wend

  hTree._AddCount(iAdd)
  
End


Private Sub Expanded_Write(Value As Boolean)

  Dim hTree As WebTree = GetTree()
  
  If $bExpanded = Value Then Return
  
  $bExpanded = Value
  
  'hTree._EnsureVisible(Me, Value)
  
  hTree._RaiseExpand($sKey, $bExpanded)
  hTree.Refresh
  
End

Public Sub Clear()
  
  Dim hTree As WebTree = GetTree()
  
  While $aChildren
    hTree.Remove($aChildren[0])
  Wend
  
End

Public Sub Delete()
  
  Dim hTree As WebTree = GetTree()
  hTree.Remove($sKey)
  
End

Public Sub EnsureVisible()
  
  Dim hTree As WebTree = GetTree()
  hTree._EnsureVisible(Me)
  
End

Public Sub MoveBefore(Optional (Key) As String)
  
  Dim hTree As WebTree = GetTree()
  hTree._MoveItem(Me, Key, True)
  
End

Public Sub MoveAfter(Optional (Key) As String)
  
  Dim hTree As WebTree = GetTree()
  hTree._MoveItem(Me, Key, False)
  
End

Public Sub MoveFirst()
  
  MoveAfter()
  
End

Public Sub MoveLast()
  
  MoveBefore()
  
End


Private Function Editable_Read() As Boolean

  Return $bEditable 

End

Private Sub Editable_Write(Value As Boolean)

  $bEditable = Value

End

Private Function Selected_Read() As Boolean

  Return GetTree()._IsSelected(Me)

End

Private Sub Selected_Write(Value As Boolean)

  GetTree()._SetSelected(Me, Value)

End


' Public Sub Rename(Optional Column As Integer = 0)
'   
'   If Not $bEditable Then Return
'   GetTree()._Rename(Me, Column)
'   
' End

Public Sub _compare(hOther As _WebTreeItem) As Integer
  
  Dim iSort As Integer
  Dim hTree As WebTree
  
  If _Tree And If Not _Tree._RaiseCompare($sKey, hOther.Key) Then 
    Return _Tree.Compare
  Else
    hTree = GetTree()
    
    iSort = hTree.Columns.Sort
    If iSort > 0 Then
      Try Return String.Comp($aText[iSort - 1], hOther[iSort], gb.Natural + gb.IgnoreCase)
      If Error Then Return 0
    Endif

    Return String.Comp($sText, hOther.Text, gb.Natural + gb.IgnoreCase)
    
  Endif
  
End

Public Sub _put(Text As String, Column As Integer)
  
  Dim hTree As WebTree
  
  hTree = GetTree()
  
  If Column = 0 Then
    $sText = Text
  Else
    'If Column < 0 Or If Column >= hView.Columns.Count Then Error.Raise("Out of bounds")
    ' Be backward-compatible
    If Column < 0 Then Error.Raise("Out of bounds")
    
    If Not $aText Then 
      $aText = New String[Column + 1]
    Else
      If Column >= $aText.Count Then $aText.Resize(Column + 1)
    Endif
    
    $aText[Column] = Text
  Endif
  
  hTree._RefreshView()
  
End

Public Sub _get(Column As Integer) As String
  
  If Column = 0 Then Return $sText
  If Column < 0 Then Error.Raise("Out of bounds")
  
  Try Return $aText[Column]
  
End


Public Sub Reparent(NewParent As String)
  
  Dim hTree As WebTree = GetTree()
  
  hTree._ReparentItem(Me, NewParent)
  
End

Private Function Background_Read() As Integer

  Return $iBg

End

Private Sub Background_Write(Value As Integer)

  $iBg = Value

End

Private Function Foreground_Read() As Integer

  Return $iFg

End

Private Sub Foreground_Write(Value As Integer)

  $iFg = Value

End

Private Function Tag_Read() As Variant

  Return $vTag

End

Private Sub Tag_Write(Value As Variant)

  $vTag = Value

End

Private Function Depth_Read() As Integer

  Return _Depth

End
