' Gambas class file

Event Fake

Property Text As String
Property Read Count As Integer
Property Read Max As Integer
Property Read Current As TextEditor
Property Highlight As String
Property Read Length As Integer
Property Read Keywords As String[]
Property Breakpoints As Integer[]
Property Bookmarks As Integer[]
Property EndOfLine As Integer

Public Lines As String[]
Public LinesInfo As CLineInfo[]

Public XAfter As Integer
Public YAfter As Integer

Private $aUndo As New CCommand[]
Private $aRedo As New CCommand[]
Private $bNoUndo As Boolean

Private $hDefaultInfo As New CLineInfo

Private $sHighlight As String
Private $hHighlight As Highlighter
Private $bHighlighting As Boolean

Private $iEndOfLine As Integer
Private $sEndOfLine As String

Public Sub _new()
  
  Clear
  
End

Public Sub Clear()
  
  Lines = New String[1]
  LinesInfo = New CLineInfo[1]
  $aUndo.Clear
  $aRedo.Clear
  
End

Private Function Text_Read() As String

  Return Lines.Join($sEndOfLine)

End

Private Sub Text_Write(Value As String)

  Clear

  If Value Then
    Lines = Split(Value, "\n")
    LinesInfo = New CLineInfo[Lines.Count]
    HighlightFrom(0)
  Endif
  
End

Public Sub Load(sPath As String)

  Dim hFile As File
  Dim sLine As String
  
  hFile = Open sPath
  
  Clear
  Lines.Clear
  
  For Each sLine In hFile.Lines
    Lines.Add(sLine)
  Next
  
  LinesInfo = New CLineInfo[Lines.Count]
  HighlightFrom(0)
  
End

Public Sub Save(sPath As String)

  Dim hFile As File
  Dim I As Integer
  
  hFile = Open sPath For Create
  hFile.EndOfLine = $iEndOfLine
  For I = 0 To Lines.Max - 1
    Print #hFile, Lines[I]
  Next
  Print #hFile, Lines[Lines.Max];
  Close #hFile
  
End


Private Function Count_Read() As Integer

  Return Lines.Count

End

Private Function Max_Read() As Integer

  Return Lines.Max

End

Private Sub AddUndo(hCmd As CCommand)

  If hCmd.Type = CCommand.END And If $aUndo.Count And If $aUndo[$aUndo.Max].Type = CCommand.Begin Then
    $aUndo.Pop
  Else
    $aUndo.Add(hCmd)
  Endif
  $aRedo.Clear

End

Public Sub Begin()

  If $bNoUndo Then Return
  AddUndo(CCommand(Me, CCommand.BEGIN))
  
End

Public Sub End()
  
  If $bNoUndo Then Return
  AddUndo(CCommand(Me, CCommand.END))
  
End

Private Function Current_Read() As TextEditor

  Return Object.Parent(Me)

End

Private Sub GetAllViews() As TextEditor[]

  Return Me.Current._GetViews()  
  
End

Public Sub Refresh(Optional Y As Integer = -1)
  
  Dim hView As TextEditor
  
  If Y < 0 Then
    For Each hView In GetAllViews()
      hView.Refresh
    Next
  Else
    For Each hView In GetAllViews()
      hView._RefreshLine(Y)
    Next
  Endif
  
End

Private Sub InsertLine(Y As Integer)
  
  Dim hView As TextEditor
  
  Lines.Add("", Y)
  LinesInfo.Add(CLineInfo(), Y)
  LinesInfo[Y].Modified = True
  
  For Each hView In GetAllViews()
    hView._RaiseChange
  Next
  
  Refresh
  
End

' void GDocument::insertLine(int y)
' {
'   lines.insert(y, new GLine());
'   modifyLine(lines.at(y), y);
'   FOR_EACH_VIEW(v) { v->lineInserted(y); }
' }

Public Sub SetLine(Y As Integer, sLine As String)

  Dim hView As TextEditor
  
  If sLine = Lines[Y] Then Return
  Lines[Y] = sLine
  With SetInfo(Y)
    .Modified = True
    .ClearHighlight()
  End With
  
  For Each hView In GetAllViews()
    hView._ClearCacheWidth(Y)
    hView._RaiseChange
  Next
  
  Refresh(Y)
  
End

Public Sub Insert(sText As String, X As Integer, Y As Integer)
  
  Dim iLen As Integer
  Dim sRest As String
  Dim aText As String[]
  Dim I As Integer
  Dim sLine As String
  Dim hView As TextEditor
  
  While Y > Lines.Count
    InsertLine(Lines.Count)
  Wend
  
  iLen = String.Len(Lines[Y])
  If X > iLen Then 
    SetLine(Y, Lines[Y] & Space$(X - iLen))
  Endif
  
  sRest = String.Mid$(Lines[Y], X + 1)
  aText = Split(sText, "\n")
  
  For I = 0 To aText.Max - 1
    
    SetLine(Y, String.Left(Lines[Y], X) & aText[I])
    X = 0
    Inc Y
    InsertLine(Y)
    
  Next
  
  sLine = String.Left(Lines[Y], X) & aText[aText.Max]
  YAfter = Y
  XAfter = String.Len(sLine)
  SetLine(Y, sLine & sRest)
  
  If Not $bNoUndo Then 
    AddUndo(CCommand(Me, CCommand.INSERT, sText))
  Endif
  
  For Each hView In GetAllViews()
    hView._AfterInsert(Y, YAfter)
  Next
  
  
  
End

' 
' void GDocument::insert(int y, int x, const GString &text, bool doNotMove)
' {
'   int pos;
'   int len;
'   int pos2;
'   int xs, ys;
'   GLine *l;
'   int n = 1;
'   int nl = 0;
'   GString rest;
'   int yy;
'   int i, ns;
'   GCommandDocument info(this);
' 
'   if (readOnly || text.length() == 0)
'   {
'     xAfter = x;
'     yAfter = y;
'     return;
'   }
' 
'   FOR_EACH_VIEW(v)
'   {
'     v->nx = v->x;
'     v->ny = v->y;
'   }
' 
'   disableColorize();
'   
'   while (y >= (int)lines.count())
'   {
'     yy = (int)lines.count();
'     insertLine(yy);
'     nl++;
'   }
' 
'   l = lines.at(y);
'   
'   ns = x - (int)l->s.length();
'   if (ns > 0)
'   {
'     GString str;
'     
'     for (i = 0; i < ns; i++)
'       str.append(' ');
'     
'     insert(y, x - ns, str, doNotMove);
'   }
' 
'   xs = x;
'   ys = y;
'   pos = 0;
' 
'   for(;;)
'   {
'     pos2 = text.findNextLine(pos, len);
' 
'     l = lines.at(y);
' 
'     if (len > 0)
'     {
'       l->insert(x, text.mid(pos, len));
'       modifyLine(l, y);
' 
'       //maxLength = GMAX(maxLength, (int)l->s.length());
'       //updateLineWidth(y);
' 
'       FOR_EACH_VIEW(v)
'       {
'         if (v->ny == y && v->nx >= x)
'           v->nx += len;
'       }
' 
'       x += len;
'     }
' 
'     pos = pos2;
' 
'     if (pos == 0)
'       break;
' 
'     if (x < (int)l->s.length())
'     {
'       rest = l->s.mid(x);
' 
'       l->s.remove(x, rest.length());
'       modifyLine(l, y);
'     }
' 
'     FOR_EACH_VIEW(v)
'     {
'       if (v->ny >= y)
'         v->ny++;
'     }
' 
'     y++;
' 
'     insertLine(y);
'     nl++;
' 
'     n = -1;
'     x = 0;
' 
'   }
' 
'   if (n < 0 && rest.length())
'   {
'     l->insert(x, rest);
'     modifyLine(l, y);
'     //maxLength = GMAX(maxLength, (int)l->s.length());
'     //updateLineWidth(y);
'   }
' 
'   FOR_EACH_VIEW(v)
'   {
'     v->foldInsert(ys, nl);
'   }
'   
'   begin();
'   addUndo(new GInsertCommand(&info, ys, xs, y, x, text));
'   enableColorize();
'   end();
' 
'   updateViews(ys, n);
' 
'   yAfter = y;
'   xAfter = x;
' 
'   emitTextChanged();
' 
'   if (!doNotMove)
'   {
'     FOR_EACH_VIEW(v)
'     {
'       v->cursorGoto(v->ny, v->nx, FALSE);
'     }
'   }
' }
' 

' Private Sub RemoveLine(Y As Integer)
'   
'   Lines.Remove(Y)
'   LinesInfo.Remove(Y)
'   
' End


' void GDocument::removeLine(int y)
' {
'   lines.remove(y);
'   COLORIZE_FROM(y);
'   FOR_EACH_VIEW(v) { v->lineRemoved(y); }
' }
' 

Public Sub Remove(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer)

  Dim sText As String
  Dim hView As TextEditor
  
  sText = GetText(X1, Y1, X2, Y2)
  
  If Y1 > Y2 Then
    Swap X1, X2
    Swap Y1, Y2
  Endif
  
  If Y1 = Y2 Then
    
    If X1 > X2 Then
      Swap X1, X2
    Endif
  
    If X2 > X1 And If X1 < String.Len(Lines[Y1]) Then
      
      SetLine(Y1, String.Left(Lines[Y1], X1) & String.Mid$(Lines[Y1], X2 + 1))
      
    Endif
  
  Else If Y1 < Y2 Then
    
    SetLine(Y1, String.Left(Lines[Y1], X1) & String.Mid$(Lines[Y2], X2 + 1))
    
    Lines.Remove(Y1 + 1, Y2 - Y1)
    LinesInfo.Remove(Y1 + 1, Y2 - Y1)
    
    Refresh
  
  Endif
  
  XAfter = X1
  YAfter = Y1
  
  If Not $bNoUndo Then 
    AddUndo(CCommand(Me, CCommand.DELETE, sText))
  Endif
  
  For Each hView In GetAllViews()
    hView._AfterRemove(Y1, Y2)
  Next

End


' void GDocument::remove(int y1, int x1, int y2, int x2)
' {
'   GLine *l, *l2;
'   GString text, rest;
'   int y;
'   GCommandDocument info(this);
' 
'   yAfter = y1;
'   xAfter = x1;
' 
'   if (readOnly)
'     return;
'   
'   FOR_EACH_VIEW(v)
'   {
'     v->nx = v->x;
'     v->ny = v->y;
'   }
'   
'   disableColorize();
'   
'   l = lines.at(y1);
' 
'   if (y1 == y2)
'   {
'     if (x2 >= x1 && x1 < lineLength(y1))
'     {
'       text = l->s.mid(x1, x2 - x1);
' 
'       l->s.remove(x1, x2 - x1);
'       if (text.hasUnicode())
'         l->unicode = l->s.hasUnicode();
' 
'       modifyLine(l, y1);
' 
'       FOR_EACH_VIEW(v)
'       {
'         v->foldRemove(y1);
'         if (v->ny == y1 && v->nx > x1)
'           v->nx = GMAX(x1, v->nx - (x2 - x1));
'       }
' 
'       updateViews(y1);
'     }
'   }
'   else
'   {
'     l2 = lines.at(y2);
'     text = l->s.mid(x1) + _eol;
'     rest = l2->s.left(x2);
' 
'     if (x1 < (int)l->s.length() || x2 < (int)l2->s.length())
'     {
'       l->s = l->s.left(x1) + lines.at(y2)->s.mid(x2);
'       l->state = 0; // force highlighting of next line.
'       modifyLine(l, y1);
'     }
'     else
'       updateLineWidth(y1);
' 
'     for (y = y1 + 1; y < y2; y++)
'       text += lines.at(y)->s + _eol;
'     text += rest;
' 
'     for (y = y1 + 1; y <= y2; y++)
'     {
'       removeLine(y1 + 1);
'     }
' 
'     FOR_EACH_VIEW(v)
'     {
'       v->foldRemove(y1 + 1, y2);
'       if (v->ny > y1)
'       {
'         v->ny = GMAX(y1, v->ny - (y2 - y1));
'         if (v->ny == y1)
'           v->nx = x1;
'       }
'       else if (v->ny == y1 && v->nx > x1)
'         v->nx = x1;
'     }
' 
'     updateViews(y1, -1);
'   }
' 
'   begin();
'   addUndo(new GDeleteCommand(&info, y1, x1, y2, x2, text));
'   enableColorize();
'   end();
' 
'   FOR_EACH_VIEW(v)
'   {
'     v->cursorGoto(v->ny, v->nx, false);
'   }
'   
'   emitTextChanged();
' }

Public Sub Info(Y As Integer) As CLineInfo

  Dim hInfo As CLineInfo

  hInfo = LinesInfo[Y]
  If Not hInfo Then hInfo = $hDefaultInfo
  Return hInfo

End

Public Sub SetInfo(Y As Integer) As CLineInfo
  
  Dim hInfo As CLineInfo

  hInfo = LinesInfo[Y]
  If Not hInfo Then 
    hInfo = CLineInfo()
    LinesInfo[Y] = hInfo
  Endif
  
  Return hInfo
  
End

Public Sub GetText(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer) As String
  
  Dim sText As String
  If Y1 > Y2 Or If Y1 = Y2 And X1 > X2 Then
    Swap X1, X2
    Swap Y1, Y2
  Endif
  
  If Y1 = Y2 Then Return String.Mid$(Lines[Y1], X1 + 1, X2 - X1)
  
  sText = String.Mid$(Lines[Y1], X1 + 1) & "\n"
  If (Y2 - Y1 - 1) > 0 Then sText &= Lines.Copy(Y1 + 1, Y2 - Y1 - 1).Join("\n") & "\n"
  sText &= String.Left(Lines[Y2], X2)

  Return sText
  
End


Public Sub Undo()
  
  Dim hCmd As CCommand
  Dim L As Integer
  
  If $aUndo.Count = 0 Then Return
  
  $bNoUndo = True
  
  Repeat
  
    hCmd = $aUndo.Pop()
    With hCmd
      
      Select Case .Type
        
        Case CCommand.BEGIN
          Dec L
        
        Case CCommand.END
          Inc L
        
        Case CCommand.INSERT
          Me.Current.Remove(.X, .Y, .XA, .YA)
          If .SX <> .X Or If .SY <> .Y Then 
            Me.Current.Goto(.SX, .SY)
            Me.Current.Goto(.X, .Y, True)
          Endif
          
        Case CCommand.DELETE
          Me.Current.Goto(.XA, .YA)
          Me.Current.Insert(.Text)
          If .SX <> .X Or If .SY <> .Y Then 
            Me.Current.Goto(.SX, .SY)
            Me.Current.Goto(.X, .Y, True)
          Endif
        
      End Select
  
    End With
    
    $aRedo.Add(hCmd)
    
  Until L = 0
  
  $bNoUndo = False
  
End

Public Sub Redo()
  
  Dim hCmd As CCommand
  Dim L As Integer
  
  If $aRedo.Count = 0 Then Return
  
  $bNoUndo = True
  
  Repeat
  
    hCmd = $aRedo.Pop()
    With hCmd
      
      Select Case .Type
        
        Case CCommand.BEGIN
          Inc L
          
        Case CCommand.END
          Dec L
        
        Case CCommand.DELETE
          If .SX <> .X Or If .SY <> .Y Then 
            Me.Current.Goto(.SX, .SY)
            Me.Current.Goto(.X, .Y, True)
          Else
            Me.Current.Goto(.X, .Y)
          Endif
          Me.Current.Remove(.XA, .YA, .X, .Y)
          
        Case CCommand.INSERT
          If .SX <> .X Or If .SY <> .Y Then 
            Me.Current.Goto(.SX, .SY)
            Me.Current.Goto(.X, .Y, True)
          Else
            Me.Current.Goto(.X, .Y)
          Endif
          Me.Current.Insert(.Text)
        
      End Select
  
    End With
    
    $aUndo.Add(hCmd)
    
  Until L = 0
  
  $bNoUndo = False
  
End

Private Function Highlight_Read() As String

  Return $sHighlight

End

Private Sub Highlight_Write(Value As String)

  Dim Y As Integer
  
  $sHighlight = Value
  If Not Value Then
    $hHighlight = Null
  Else
    If LCase(Value) = "c++" Then Value = "CPlusPlus"
    Try $hHighlight = Class.Load("Highlighter" & Value).AutoCreate()
    If Error Then Error.Raise("Unknown highlighter:" & Error.Text)
    For Y = 0 To LinesInfo.Max
      If LinesInfo[Y] Then LinesInfo[Y].ClearHighlight()
    Next
  Endif

End

Public Sub HighlightFrom(Y As Integer)

  Dim aHighlight As Byte[]
  
  If Not $hHighlight Then Return
  
  If $bHighlighting Then Return
  $bHighlighting = True

  Begin()

  Do

    If Y < 0 Or If Y > Lines.Max Then Break
    If Info(Y).Colors Then Break
  
    If Y = 0 Then
      $hHighlight.State = Highlight.Normal
      $hHighlight.Tag = 0
      $hHighlight.Alternate = False
    Else
      With Info(Y - 1)
        $hHighlight.State = .State
        $hHighlight.Tag = .Tag
        $hHighlight.Alternate = .Alternate
      End With
    Endif
    $hHighlight.Limit = False
    
    With SetInfo(Y)
  
      aHighlight = New Byte[]
      .Colors = aHighlight
      Highlighter._Highlight = aHighlight
      Highlighter.TextAfter = ""
      
      'Debug "Before: State = "; .State;; "Tag = "; .Tag;; "Alternate = "; .Alternate;; "Limit = "; .Limit
      
      $hHighlight.Run(Lines[Y])
      
      If $hHighlight.TextAfter And If Lines[Y] <> $hHighlight.TextAfter Then
        Me.Current.Goto(0, Y)
        Me.Current.Remove(0, Y, String.Len(Lines[Y]), Y)
        Me.Current.Insert($hHighlight.TextAfter)
        .Highlight = aHighlight
      Endif
  
      If .Alternate <> $hHighlight.Alternate Or If .State <> $hHighlight.State Or If .Tag <> $hHighlight.Tag Or If .Limit <> $hHighlight.Limit Then
        .Alternate = $hHighlight.Alternate
        .State = $hHighlight.State
        .Tag = $hHighlight.Tag
        .Limit = $hHighlight.Limit
        'Debug "Update: State = "; .State;; "Tag = "; .Tag;; "Alternate = "; .Alternate;; "Limit = "; .Limit
        If Y < Lines.Max Then SetInfo(Y + 1).ClearHighlight()
      Endif
      
      Inc Y
      
    End With
    
  Loop

  End()

  Refresh
  
  $bHighlighting = False
    
End

Private Function Length_Read() As Integer

  Dim Y As Integer
  Dim L As Integer

  For Y = 0 To Lines.Max
    L += String.Len(Lines[Y])
  Next
  
  L += Lines.Max * Len($sEndOfLine)
  Return L

End

Private Function Keywords_Read() As String[]

  If $hHighlight Then Return $hHighlight.GetKeywords()

End

Private Function Breakpoints_Read() As Integer[]

  Dim Y As Integer
  Dim aRes As Integer[]

  aRes = New Integer[]
  For Y = 0 To Lines.Max
    If Info(Y).Breakpoint Then
      aRes.Add(Y)
    Endif
  Next
  
  Return aRes

End

Private Sub Breakpoints_Write(Value As Integer[])

  Dim Y As Integer

  For Y = 0 To Lines.Max
    If Info(Y).Breakpoint Then SetInfo(Y).Breakpoint = False
  Next
  
  If Value Then
    For Each Y In Value
      SetInfo(Y).Breakpoint = True
    Next
  Endif

End

Private Function Bookmarks_Read() As Integer[]

  Dim Y As Integer
  Dim aRes As Integer[]

  aRes = New Integer[]
  For Y = 0 To Lines.Max
    If Info(Y).Bookmark Then
      aRes.Add(Y)
    Endif
  Next
  
  Return aRes

End

Private Sub Bookmarks_Write(Value As Integer[])

  Dim Y As Integer

  For Y = 0 To Lines.Max
    If Info(Y).Bookmark Then SetInfo(Y).Bookmark = False
  Next
  
  If Value Then
    For Each Y In Value
      SetInfo(Y).Bookmark = True
    Next
  Endif

End

Private Function EndOfLine_Read() As Integer

  Return $iEndOfLine

End

Private Sub EndOfLine_Write(Value As Integer)

  Select Case Value
    Case gb.Unix
      $sEndOfLine = "\n"
    Case gb.Windows
      $sEndOfLine = "\r"
    Case gb.Mac
      $sEndOfLine = "\r\n"
    Case Else
      Return
  End Select
  
  $iEndOfLine = Value  

End
