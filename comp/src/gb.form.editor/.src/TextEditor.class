' Gambas class file

Export

Inherits UserControl

Public Const _Properties As String = "*,ReadOnly"

Property Text As String
Property Read Line As Integer
Property Read Column As Integer
Property Read SelectionLine As Integer
Property Read SelectionColumn As Integer
Property Read Selected As Boolean
Property Read SelectedText As String
Property ReadOnly As Boolean

Private Const MATCH_STRING As String = "()[]{}"

Static Private $cShortcut As Collection

Private $hPanel As Panel
Private $hView As GridView
Private $hScroll As ScrollArea
Private $iLargestLine As Integer
Private $hDoc As CDocument

Private $X As Integer
Private $Y As Integer
Private $XX As Integer
Private $bShowCursor As Boolean
Private $hTimerCursor As Timer
Private $hObsScroll As Observer

Private $SX As Integer
Private $SXX As Integer
Private $SY As Integer
Private $bMouseDown As Boolean

Private $hTimerScroll As Timer

Private $MW As Integer
Private $iTabWidth As Integer
Private $iTabSymbolSize As Variant

Private $XM As Integer
Private $YM As Integer = -1
Private $XMO As Integer
Private $YMO As Integer
Private $bReadOnly As Boolean

Public Sub _new()
  
  If Not $cShortcut Then
    $cShortcut = [
      "CTRL+A": "SelectAll",
      "CTRL+C": "Copy",
      "CTRL+V": "Paste",
      "CTRL+X": "Cut",
      "CTRL+Y": "Redo",
      "CTRL+Z": "Undo"]
  Endif
  
  $hPanel = New Panel(Me)
  $hPanel.Arrangement = Arrange.Fill
  $hPanel.Border = Border.Plain
  
  $hView = New GridView($hPanel) As "View"
  $hView.Columns.Count = 1
  $hView.Mode = Select.None
  $hView.Grid = False
  $hView.Padding = 0
  $hView.Border = False
  $hView._NoMouse = True
  
  $hScroll = $hView.Children[0]
  $hObsScroll = New Observer($hScroll) As "ScrollArea"
  Me.Proxy = $hView
  
  $hDoc = New CDocument
  Object.Attach($hDoc, Me, "Document")
  
  $hTimerCursor = New Timer As "TimerCursor"
  $hTimerCursor.Delay = 500
  $hTimerCursor.Start
  
  Me.Text = ""
  
End


Private Function Text_Read() As String

  Return $hDoc.Text

End

Private Sub CalcSizes()

  $iLargestLine = -1
  UpdateWidth
  UpdateMargin
  $iTabWidth = $hView.Font.TextWidth(" ") * 8
  $iTabSymbolSize = Max(2, $hView.Rows.H \ 3)
  $hView.Refresh

End

Private Sub Text_Write(Value As String)

  $hDoc.Text = Value
  $hView.Rows.Count = $hDoc.Count
  CalcSizes
  $X = 0
  $Y = 0
  $XX = 0
  $SX = 0
  $SY = 0
  $SXX = 0
  $YM = -1
  $bShowCursor = True
  $hView.Refresh

End

Private Sub UpdateMargin()

  $MW = (CInt(Log10($hDoc.Count)) + 1) * $hView.Font.TextWidth("9") + 8

End

Public Sub ScrollArea_Font()
  
  CalcSizes
  
End


Private Sub HasSelection() As Boolean
  
  If $X <> $SX Or If $Y <> $SY Then Return True
  
End

Private Sub DrawText(sText As String, SX As Integer, X As Integer, Y As Integer)

  Dim iTab, iTab2, iLen As Integer
  Dim iCol As Integer
  
  Do
  
    iTab2 = InStr(sText, "\t", iTab + 1)  
    If iTab2 = 0 Then
      Paint.DrawText(Mid$(sText, iTab + 1), X, Y)
      Return
    Endif
    
    iLen = iTab2 - iTab - 1
    If iLen > 0 Then
      Paint.DrawText(Mid$(sText, iTab + 1, iLen), X, Y)
      X += $hView.Font.TextWidth(Mid$(sText, iTab + 1, iTab2 - iTab - 1))
    Endif
    
    iCol = Color.SetAlpha(Color.TextForeground, 128)
    Paint.FillRect(X + 2, Y - $iTabSymbolSize + 1, 1, $iTabSymbolSize, iCol)
    Paint.FillRect(X + 3, Y, $iTabSymbolSize - 1, 1, iCol)
    
    X = SX + (((X - SX) + $iTabWidth) \ $iTabWidth) * $iTabWidth
    iTab = iTab2
    
  Loop

End

Private Sub DrawMatch(X As Integer, Y As Integer, (H) As Integer, XM As Integer, YM As Integer)

  Dim sCar As String
  
  X += LineWidth(YM, XM)
  sCar = String.Mid$($hDoc.Lines[YM], XM + 1, 1)
  'Paint.FillRect(X, Y + H - 1, $hView.Font.TextWidth(sCar), 1, Color.SelectedBackground)
  Paint.Save
  Paint.Background = Color.SelectedBackground
  'Paint.DrawTextShadow(sCar, X, Y, $hView.Font.TextWidth(sCar), H, Align.TopLeft,, 1)
  Paint.DrawText(sCar, X + 1, Y + $hView.Font.Ascent)
  Paint.Restore

End

Public Sub View_Draw(X As Integer, Y As Integer, Width As Integer, Height As Integer, Row As Integer, (Column) As Integer)
  
  Dim X1 As Integer
  Dim Y1 As Integer
  Dim X1X As Integer
  Dim X2 As Integer
  Dim Y2 As Integer
  Dim X2X As Integer
  Dim iCol As Integer
  
  Paint.Translate($MW, 0)
  
  If HasSelection() Then
    
    X1 = $X
    Y1 = $Y
    X1X = $XX
    
    X2 = $SX
    Y2 = $SY
    X2X = $SXX
    
    If Y1 > Y2 Or If Y1 = Y2 And X1 > X2 Then
      Swap X1, X2
      Swap Y1, Y2
      Swap X1X, X2X
    Endif
    
    If Row >= Y1 And If Row <= Y2 Then
    
      iCol = Color.SetAlpha(Color.SelectedBackground, 128)
    
      If Y1 = Y2 Then
        Paint.FillRect(X + X1X, Y, X2X - X1X, Height, iCol)
      Else If Row = Y1 Then
        Paint.FillRect(X + X1X, Y, Width - X1X, Height, iCol)
      Else If Row = Y2 Then
        Paint.FillRect(X, Y, X2X, Height, iCol)
      Else
        Paint.FillRect(X, Y, Width, Height, iCol)
      Endif
      
    Endif
    
  Endif
  
  If Row = $Y Then
    Paint.FillRect(X, Y, Width, Height, Color.SetAlpha(Color.SelectedBackground, 240))
  Endif
  
  Paint.Background = Color.TextForeground
  DrawText($hDoc.Lines[Row], X, X, Y + $hView.Font.Ascent)
  
  If $YM >= 0 Then
    If Row = $YMO Then DrawMatch(X, Y, Height, $XMO, $YMO)
    If Row = $YM Then DrawMatch(X, Y, Height, $XM, $YM)
  Endif
  
  If Row = $Y And If $bShowCursor Then
    Paint.FillRect(X + $XX, Y, 2, Height, Color.SetAlpha(Style.ForegroundOf(Me), 64))
  Endif
  
  Paint.Translate(- $MW, 0)
  
  If $MW Then
    
    X += $hView.ScrollX
    Paint.FillRect(X, Y, $MW, Height, Color.TextBackground)
    
    With $hDoc.Info(Row)
      If .Modified Then Paint.FillRect(X + $MW - 4, Y, 4, Height, Color.Merge(Color.TextBackground, Color.Red, 0.2))
    End With
    
    iCol = Color.TextForeground
    If (Row + 1) Mod 10 Then iCol = Color.Merge(iCol, Color.TextBackground, 0.8)
    Paint.Background = iCol
    Paint.DrawText(CStr(Row + 1), X, Y, $MW - 8, Height, Align.TopRight)
  
  Endif
  
End

Private Sub LineWidth(Y As Integer, Optional iLen As Integer = -1) As Integer
  
  Dim aText As String[]
  Dim W As Integer
  Dim I As Integer
  
  If iLen < 0 Then
    aText = Split($hDoc.Lines[Y], "\t")
  Else
    aText = Split(String.Left($hDoc.Lines[Y], iLen), "\t")
  Endif
  
  If aText.Count = 0 Then Return 0
  
  For I = 0 To aText.Max - 1
    W += $hView.Font.TextWidth(aText[I])
    W = ((W + $iTabWidth) \ $iTabWidth) * $iTabWidth
  Next
  W += $hView.Font.TextWidth(aText[aText.Max])
  
  Return W
  
End

Private Sub FindLargestLine() As Integer

  Dim I As Integer
  Dim W As Integer
  Dim WM As Integer = -1

  For I = 0 To $hDoc.Count - 1
    W = LineWidth(I)
    If W > WM Then
      WM = W
      $iLargestLine = I
    Endif
  Next
  
  Return WM

End

Private Sub UpdateWidth(Optional Y As Integer = -1)

  Dim W As Integer
  
  If $iLargestLine < 0 Or If $iLargestLine > $hDoc.Max Then
    FindLargestLine
    Y = -1
  Endif

  If Y < 0 Then
    W = LineWidth($iLargestLine) + $MW + 2
    Goto UPDATE_WIDTH
  Endif

  W = LineWidth(Y) + $MW + 2
  If W > $hView.Columns[0].W Then
    $iLargestLine = Y
    Goto UPDATE_WIDTH
  Else If W < $hView.Columns[0].W And If Y = $iLargestLine Then
    W = FindLargestLine() + $MW + 2
    Goto UPDATE_WIDTH
  Endif
  
  Return
  
UPDATE_WIDTH:

  $hView.Columns[0].W = W

End

Public Sub TimerCursor_Timer()
  
  $bShowCursor = Not $bShowCursor
  RefreshLine($Y)
  
End

Public Sub View_KeyPress()
  
  Dim Y As Integer
  Dim sAction As String
  Dim sTab As String
  
  Try sAction = $cShortcut[Shortcut.FromKey()]
  If sAction Then
    Select Case sAction
      Case "Copy"
        Copy()
      Case "Paste"
        If $bReadOnly Then Goto STOP_EVENT
        Paste()
      Case "Undo"
        If $bReadOnly Then Goto STOP_EVENT
        $hDoc.Undo()
      Case "Redo"
        If $bReadOnly Then Goto STOP_EVENT
        $hDoc.Redo()
      Case "Cut"
        If $bReadOnly Then Goto STOP_EVENT
        If Not HasSelection() Then
          Goto(0, $Y)
          If $Y < $hDoc.Max Then
            Goto(0, $Y + 1, True)
          Else
            Goto(-1, $Y, True)
          Endif
        Endif
        Copy()
        DeleteSelection()
      Case "SelectAll"
        SelectAll
    End Select
    Goto STOP_EVENT
  Endif
  
  If Key.Text And If Asc(Key.Text) >= 32 And If Asc(Key.Text) <> 127 Then 
    If Not $bReadOnly Then Insert(Key.Text)
    Goto STOP_EVENT
  Endif
    
  Select Case Key.Code
    
    Case Key.Right
      If Key.Normal Or If Key.Shift Then
        If $X >= String.Len($hDoc.Lines[$Y]) Then
          Goto(0, $Y + 1, Key.Shift)
        Else
          Goto($X + 1, $Y, Key.Shift)
        Endif
      Endif
    
    Case Key.Left
      If Key.Normal Or If Key.Shift Then
        If $X = 0 Then
          Goto(-1, $Y - 1, Key.Shift)
        Else
          NormalizeColumn
          Goto($X - 1, $Y, Key.Shift)
        Endif
      Endif
      
    Case Key.Up
      Goto($X, $Y - 1, Key.Shift)
      
    Case Key.Down
      Goto($X, $Y + 1, Key.Shift)
      
    Case Key.Home
      If Key.Control Then
        Goto(0, 0, Key.Shift)
      Else
        sTab = GetTab($Y)
        If $X <> Len(sTab) Then
          Goto(Len(sTab), $Y, Key.Shift)
        Else
          Goto(0, $Y, Key.Shift)
        Endif
      Endif
      
    Case Key.End
      If Key.Control Then
        Goto(-1, $hDoc.Max, Key.Shift)
      Else
        Goto(-1, $Y, Key.Shift)
      Endif
      
    Case Key.PageUp
      Y = $hView.Rows._FindRowFromPos($hView.Rows[$Y].Y + $hView.Rows[$Y].H - $hView.ClientH)
      Goto($X, Max(0, Y), Key.Shift)
      
    Case Key.PageDown
      Y = $hView.Rows._FindRowFromPos($hView.Rows[$Y].Y + $hView.ClientH)
      If Y >= 0 Then 
        Goto($X, Y, Key.Shift)
      Else
        Goto($X, $hDoc.Max, Key.Shift)
      Endif
      
    Case Key.Enter, Key.Return
      If $bReadOnly Then Goto STOP_EVENT
      sTab = GetTab($Y)
      Insert("\n" & sTab)
      
    Case Key.BackSpace
      If Key.Normal Then
        If $bReadOnly Then Goto STOP_EVENT
        DeleteLeft
      Endif
    
    Case Key.Delete
      If Key.Normal Then
        If $bReadOnly Then Goto STOP_EVENT
        DeleteRight
      Endif
      
    Case Key.Tab
      If Key.Control Then
        If $bReadOnly Then Goto STOP_EVENT
        Insert("\t")
      Endif
    
  End Select
  
STOP_EVENT:
  
  Stop Event
  
End

Private Sub HideSelection()

  If HasSelection() Then $hView.Refresh
  $SX = $X
  $SY = $Y
  $SXX = $XX

End

Public Sub Goto(NX As Integer, NY As Integer, Optional Mark As Boolean)

  If NY < 0 Then Return
  If NY > $hDoc.Max Then Return
  
  If NX < 0 Then NX = String.Len($hDoc.Lines[NY])
  
  RefreshLine($Y)
  
  If NX <> $X Or If NY <> $Y Then
    $X = NX
    $Y = NY
    $XX = LineWidth($Y, $X)
    $XM = 0
    $YM = -1
  Endif
  
  If Not Mark Then
    HideSelection
  Else
    $hView.Refresh
  Endif
  
  $bShowCursor = True
  If Not $bReadOnly Then $hTimerCursor.Start
  RefreshLine($Y)
  
  $hScroll.EnsureVisible($XX, $hView.Rows[$Y].Y, $MW + 3, $hView.Rows[$Y].H)
  
  CheckMatch
  
End

Private Sub PosToColumn(Y As Integer, PX As Integer) As Integer

  Dim I As Integer = -1
  Dim iLen As Integer
  Dim D As Integer
  Dim F As Integer
  Dim LW As Integer
  Dim sStr As String
  
  sStr = $hDoc.Lines[Y]
  iLen = String.Len(sStr)
  
  If PX < $MW Then Return 0
  
'   if (px < margin || px >= visibleWidth())
'     _posOutside = true;
'
  If iLen = 0 Then Return PX \ $hView.Font.TextWidth("m")

  PX += $hScroll.ScrollX - $MW

'   px += contentsX();
'   
  D = 0
  F = iLen
  
  While F > D
    If I < 0 Then
      I = PX \ $hView.Font.TextWidth("m")
    Else
      I = (D + F) \ 2
    Endif
    LW = LineWidth(Y, I)
    If PX < LW Then
      F = I
      Continue
    Endif
    LW = LineWidth(Y, I + 1)
    If PX >= LW Then
      D = I + 1
      Continue
    Endif
    D = I
    Break
  Wend
  
'   _posOutside = d > len;
  Return D
End

Private Sub PosToLine(PY As Integer) As Integer

  Return $hView.Rows._FindRowFromPos(PY + $hScroll.ScrollY)

End

Public Sub ScrollArea_MouseDown()

  Dim Y As Integer
  Dim X As Integer
  
  Y = PosToLine(Mouse.Y)
  X = PosToColumn(Y, Mouse.X)
  Goto(X, Y, False)
  $bMouseDown = True

End

Public Sub ScrollArea_MouseDrag()
  
  If Not $hTimerScroll Then
    $hTimerScroll = New Timer As "TimerScroll"
    $hTimerScroll.Delay = 50
    $hTimerScroll.Start
  Endif
  
End


Public Sub ScrollArea_MouseMove()
  
  Dim Y As Integer
  Dim X As Integer

  If $bMouseDown Then
  
    Y = PosToLine(Mouse.ScreenY - $hView.ScreenY)
    If Y >= 0 Then
      X = PosToColumn(Y, Mouse.ScreenX - $hView.ScreenX)
      Goto(X, Y, True)
    Endif
    
  Endif
  
End

Public Sub ScrollArea_MouseUp()
  
  If $hTimerScroll Then
    $hTimerScroll.Stop
    $hTimerScroll = Null
  Endif

  $bMouseDown = False
  
End

Public Sub TimerScroll_Timer()
  
  ScrollArea_MouseMove
  
End

Private Function Line_Read() As Integer

  Return $Y

End

Private Function Column_Read() As Integer

  Return $X

End

Private Function SelectionLine_Read() As Integer

  Return $SY

End

Private Function SelectionColumn_Read() As Integer

  Return $SX

End

Private Function Selected_Read() As Boolean

  Return HasSelection()

End

Private Sub DeleteSelection() As Boolean

  If HasSelection() Then
    Remove($SX, $SY, $X, $Y)
    Return True
  Endif
  
End

Private Sub NormalizeColumn()

  Dim X As String

  X = Min(String.Len($hDoc.Lines[$Y]), $X)
  If X <> $X Then Goto(X, $Y)

End

Public Sub Insert(Text As String)
  
  Dim Y As Integer

  DeleteSelection

  NormalizeColumn
  
  $hDoc.Insert(Text, $X, $Y)
  
  For Y = Min($Y, $hDoc.YAfter) To Max($Y, $hDoc.YAfter)
    UpdateWidth(Y)
  Next
  UpdateMargin
  $hView.Rows.Count = $hDoc.Count
  
  Goto($hDoc.XAfter, $hDoc.YAfter)
  
End

Private Function SelectedText_Read() As String

  If Not HasSelection() Then Return  
  Return $hDoc.GetText($X, $Y, $SX, $SY)

End

Public Sub Copy()
  
  If Not HasSelection() Then Return
  Clipboard.Copy(Me.SelectedText)
  
End

Public Sub Paste()

  Dim sText As String
  
  If Clipboard.Type <> Clipboard.Text Then Return
  sText = Clipboard.Paste()
  If Not sText Then Return
  
  Insert(sText)
  
End

Public Sub SelectAll()
  
  Goto(0, 0)
  Goto(-1, $hDoc.Max, True)
  
End

Public Sub Remove(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer)
  
  $hDoc.Remove(X1, Y1, X2, Y2)
  
  If $iLargestLine >= Min(Y1, Y2) And If $iLargestLine <= Max(Y1, Y2) Then UpdateWidth
  UpdateMargin
  $hView.Rows.Count = $hDoc.Count
  
  Goto($hDoc.XAfter, $hDoc.YAfter)
  
End

Private Sub DeleteLeft()

  If DeleteSelection() Then Return

  NormalizeColumn
  
  If $X = 0 Then
    If $Y > 0 Then
      Remove(String.Len($hDoc.Lines[$Y - 1]), $Y - 1, 0, $Y)
    Endif
  Else
    Remove($X - 1, $Y, $X, $Y)
  Endif

End

Private Sub DeleteRight()

  If DeleteSelection() Then Return

  If $X >= String.Len($hDoc.Lines[$Y]) Then
    If $Y < $hDoc.Max Then
      Remove($X, $Y, 0, $Y + 1)
    Endif
  Else
    Remove($X, $Y, $X + 1, $Y)
  Endif

End

Private Sub GetTab(Y As Integer) As String

  Dim sText As String
  Dim sTab As String
  Dim I As Integer
  Dim sCar As String

  sText = $hDoc.Lines[Y]
  For I = 1 To Len(sText)
    sCar = Mid$(sText, I, 1)
    If sCar = " " Or If sCar = "\t" Then
      sTab &= sCar
    Else
      Break
    Endif
  Next
  
  Return sTab

End

' Private Sub IsVisible(Y As Integer) As Boolean
' 
'   If Y < $hView.RowAt(0) Then Return
'   If Y > $hView.RowAt($hView.ClientH - 1) Then Return
'   Return True
'   
' End

Private Sub CheckMatch()
  
  Dim sCar As String
  Dim X, Y As Integer
  Dim iMatch As Integer
  Dim N, L As Integer
  Dim sOther As String
  Dim sLine As String
  Dim iLen As Integer
  
  $XM = 0
  $YM = -1

  Y = $Y
  X = Min(String.Len($hDoc.Lines[Y]), $X)
  
  If X > 0 Then 
    sCar = String.Mid$($hDoc.Lines[Y], X, 1)
    iMatch = InStr(MATCH_STRING, sCar)
    If iMatch Then Goto FIND_MATCH
  Endif
  
  Inc X
  sCar = String.Mid$($hDoc.Lines[Y], X, 1)
  iMatch = InStr(MATCH_STRING, sCar)
  If iMatch Then Goto FIND_MATCH
  
  Return
  
FIND_MATCH:

  If Odd(iMatch) Then
    sOther = Mid$(MATCH_STRING, iMatch + 1, 1)
  Else
    sOther = Mid$(MATCH_STRING, iMatch - 1, 1)
  Endif

  L = 1  
  Dec X
  $XMO = X
  $YMO = Y
  
  sLine = $hDoc.Lines[Y]
  iLen = String.Len(sLine) 

  Do
    
    If Odd(iMatch) Then
      
      Inc X
      
      While X >= iLen
        
        X = 0
        Inc Y
        If Y > $hDoc.Max Then Return
        Inc N
        If N > 1000 Then Return
        
        sLine = $hDoc.Lines[Y]
        iLen = String.Len(sLine)
        
      Wend
      
    Else
      
      Dec X
      
      While X < 0
        
        Dec Y
        If Y < 0 Then Return
        Inc N
        If N > 1000 Then Return
        
        sLine = $hDoc.Lines[Y]
        X = String.Len(sLine) - 1
        
      Wend
      
    Endif
    
    Select Case String.Mid$(sLine, X + 1, 1)
      
      Case sOther 
        Dec L
        If L = 0 Then
          $XM = X
          $YM = Y
          RefreshLine(Y)
          Return
        Endif
        
      Case sCar
        Inc L
        
    End Select
    
  Loop
  
End

Private Sub RefreshLine(Y As Integer)

  $hView.Rows[Y].Refresh

End

Private Function ReadOnly_Read() As Boolean

  Return $bReadOnly

End

Private Sub ReadOnly_Write(Value As Boolean)

  $bReadOnly = Value
  $hTimerCursor.Enabled = Not Value

End
