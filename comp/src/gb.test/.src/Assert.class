' Gambas class file

''' Assertions which print TAP.

Export
Create Static

Property Read Printer As TapPrinter
Property Output As Stream
Property Read Session As TapContext
Property Read Finished As Boolean

Private $hPrinter As TapPrinter
Private $IsNextReverse As Boolean
Private $hNext As New TestAssertion

Public Sub _new()
   Reset()
End

Public Sub Reset()
    $hPrinter = New TapPrinter As "Printer"
End

Public Sub ReverseNext()
  $IsNextReverse = True
End

Public Sub Subtest(Description As String, Optional Tests As Integer, Optional Comment As String)
    $hPrinter.Subtest(Description, Tests, Comment)
End

Public Sub Plan(Tests As Integer, Optional Comment As String)
    $hPrinter.Plan(Tests, Comment)
End

Public Sub SkipAll(Optional Comment As String)
    $hPrinter.SkipAll(Comment)
End

Public Sub Finish()
    $hPrinter.Finish()
End

Public Sub Ok(Result As Boolean, Optional Description As String) As Boolean

    Dim bRes As Boolean

    If $IsNextReverse Then Result = Not Result
    $IsNextReverse = False

    $hNext.Ok = Result
    $hNext.Description = Description
    bRes = $hPrinter.Assert($hNext).Ok
    $hNext = New TestAssertion
    Return bRes

End

Public Sub Todo(Optional Comment As String)
    $hNext.Directive = Tap.TODO
    $hNext.Comment = Comment
End

Public Sub Skip(Optional Comment As String)
    $hNext.Directive = Tap.SKIP
    $hNext.Comment = Comment
    Pass()
End

Public Sub BailOut(Optional Comment As String)
    $hPrinter.BailOut(Comment)
End

Public Sub Diagnostic(Comment As String)
    $hPrinter.Diagnostic(Comment)
End

Public Sub Note(Comment As String)
    $hPrinter.Note(Comment)
End

Public Sub Print({Line} As String)
    $hPrinter.Print({Line})
End

Private Function Printer_Read() As TapPrinter
    Return $hPrinter
End

Private Function Output_Read() As Stream
    Return $hPrinter.Output
End

Private Sub Output_Write(Value As Stream)
    $hPrinter.Output = Value
End

Private Function Session_Read() As TapContext
    Return $hPrinter.Session
End

Private Function Finished_Read() As Boolean
    Return $hPrinter.Session.Finished
End

' -------------------- High-level test functions --------------------

Public Sub Pass(Optional Description As String) As Boolean

    Return Ok(True, Description)

End

Public Sub Fail(Optional Description As String) As Boolean

    Return Ok(False, Description)

End

Public Sub NotOk(Result As Boolean, Optional Description As String) As Boolean

    Return Ok(Not Result, Description)

End

Public Sub Equals(Got As Variant, Expected As Variant, Optional Description As String) As Boolean

    Dim bRes As Boolean

    bRes = Ok(Got = Expected, Description)
    If Not bRes Then
        Note(Subst$(("  Got:      &1"), Got))
        Note(Subst$(("  Expected: &1"), Expected))
    Endif
    Return bRes

End

Public Sub NotEquals(Got As Variant, UnExpected As Variant, Optional Description As String) As Boolean

    Return Ok(Got <> UnExpected, Description)

End

Public Sub LessEqual(Got As Variant, Bound As Variant, Optional Description As String) As Boolean

    Dim bRes As Boolean

    bRes = Ok(Got <= Bound, Description)
    If Not bRes Then
        Note(Subst$(("  Got:      &1"), Got))
        Note(Subst$(("  Expected: <= &1"), Bound))
    Endif
    Return bRes

End

Public Sub Less(Got As Variant, Bound As Variant, Optional Description As String) As Boolean

    Dim bRes As Boolean

    bRes = Ok(Got < Bound, Description)
    If Not bRes Then
        Note(Subst$(("  Got:      &1"), Got))
        Note(Subst$(("  Expected: < &1"), Bound))
    Endif
    Return bRes

End

Public Sub GreaterEqual(Got As Variant, Bound As Variant, Optional Description As String) As Boolean

    Dim bRes As Boolean

    bRes = Ok(Got >= Bound, Description)
    If Not bRes Then
        Note(Subst$(("  Got:      &1"), Got))
        Note(Subst$(("  Expected: >= &1"), Bound))
    Endif
    Return bRes

End

Public Sub Greater(Got As Variant, Bound As Variant, Optional Description As String) As Boolean

    Dim bRes As Boolean

    bRes = Ok(Got > Bound, Description)
    If Not bRes Then
        Note(Subst$(("  Got:      &1"), Got))
        Note(Subst$(("  Expected: > &1"), Bound))
    Endif
    Return bRes

End

Public Sub Approximate(Got As Float, Expected As Float, Precision As Float, Optional Description As String) As Boolean

    Return LessEqual(Abs(Got - Expected), Precision, Description)

End

Public Sub RelativeApproximate(Got As Float, Expected As Float, RelPrecision As Float, Optional Description As String) As Boolean

    Return LessEqual(Abs((Got - Expected) / Expected), RelPrecision, Description)

End

Public Sub IsType(Got As Variant, Type As Integer, Optional Description As String) As Boolean

    Return Equals(TypeOf(Got), Type, Description)

End

Public Sub Null(Got As Variant, Optional Description As String) As Boolean

    Return Equals(Got, Null, Description)

End

Public Sub NotNull(Got As Variant, Optional Description As String) As Boolean

    Return NotEquals(Got, Null, Description)

End

Public Sub Like(Got As String, Pattern As String, Optional Description As String) As Boolean

    Dim bRes As Boolean

    bRes = Ok(Got Like Pattern, Description)
    If Not bRes Then
        Note(Subst$(("  Got:      &1"), Got))
        Note(Subst$(("  Expected: &1"), Pattern))
    Endif
    Return bRes

End

Public Sub Match(Got As String, Pattern As String, Optional Description As String) As Boolean

    Dim bRes As Boolean

    bRes = Ok(Got Match Pattern, Description)
    If Not bRes Then
        Note(Subst$(("  Got:      &1"), Got))
        Note(Subst$(("  Expected: &1"), Pattern))
    Endif
    Return bRes

End

Public Sub StringEquals(Got As String, Expected As String, Optional Description As String) As Boolean

    Dim bRes As Boolean
    Dim iPos As Integer

    bRes = Equals(Got, Expected, Description)
    If Not bRes Then
        If Len(Got) <> Len(Expected) Then
            Note(Subst$(("Strings are of different lengths &1 and &2, respectively."), Len(Got), Len(Expected)))
        Endif
        For iPos = 1 To Min(Len(Got), Len(Expected))
            If Mid$(Got, iPos, 1) <> Mid$(Expected, iPos, 1) Then Break
        Next
        Note(Subst$(("Strings differ at position &1."), iPos))
    Endif
    Return bRes

End

Public Sub Error(Optional Description As String) As Boolean

    Return Ok( Error , Description)

End

Public Sub ErrorCode(Code As Integer, Optional Description As String) As Boolean

    Dim bRes As Boolean

    If Not Error Then
        bRes = Fail(Description)
        Note(("No error happened"))
    Else
        bRes = Equals(Error.Code, Code, Description)
        If Not bRes Then
            Note(Subst$(("Error was: &1 (code: &2) at &3"), Error.Text, Error.Code, Error.Where))
        Endif
    Endif

    Error.Clear()
    Return bRes

End

Public Sub NotError(Optional Description As String) As Boolean

    Dim bRes As Boolean

    bRes = Ok(Not Error , Description)
    If Not bRes Then
        Note(Subst$(("Error was: &1 (code: &2) at &3"), Error.Text, Error.Code, Error.Where))
    Endif

    Error.Clear()
    Return bRes

End
