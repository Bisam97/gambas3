' Gambas class file

' Gambas module file

Export
Create Static



Private aCResult As New CResult[]  'Compiled result
Private $vData As Variant
Static Property Read Functions As String[]
Static Private $sFunctions As New String[]
Static Public FunctionsArgsCount As New Integer[]
Private $cVars As New Collection
'Public Enum isValue, isString, isOp, isVar, isFunc, isBool
Property Data As Variant
Private $sFormula As String
Property Formula As String
Property Read Variables As CResult[]
Property Read ErrorPos As Integer
Property Read ErrorText As String

Private $iErrorPos As Integer
Private $sErrorText As String

Private $bError As Boolean

Property Read Error As Boolean

Public Value As Variant
' operators
' precedence operators associativity
' 1!right To Left
' 2 * / % Left To Right
' 3 + - Left To Right
' 4 = Right To Left
Event Data(Name As String)

Static Public Sub _init()

  Dim s As String
  Dim ars As String[]
  Dim aSh As New Byte[]
  Dim i As Byte
  
  For Each s In Split(File.Load("FunctionsList"), "\n")
    ars = Split(s, "|")
    $sFunctions.Add(UCase(ars[0]))
    FunctionsArgsCount.Add(Len(ars[1]))

  Next
  
End

Public Sub _New(Optional Formula As String)
  
  If Formula Then Me.Formula = Formula
  
End


Public Function _get(Formula As String) As SimpleEval

  Dim hEval As Object
  
  hEval = Object.New(Object.Type(Me), [Formula])
  hEval.Execute
  Return hEval
  
End


Private Function op_preced(skey As String) As Integer

  Select Case skey
    Case "!", "^"
      Return 4
    Case "*", "/", "%"
      Return 3
    Case "+", "-"
      Return 2
    Case "="
      Return 1
  End Select
  Return 0

End

Private Function op_left_assoc(sKey As String) As Boolean

  Select Case skey
      ' Left To Right
    Case "*", "/", "%", "+", "-", "&"
      Return True
      ' Right To Left
    Case "=", "!", "^", ">", "<"
      Return False
  End Select
  Return False

End

Private Function op_arg_count(skey As String) As Byte

  Select Case sKey

    Case "*", "/", "%", "+", "-", "=", "^", "&", ">", "<"
      Return 2
    Case "!"
      Return 1
    Default

      Return FunctionsArgsCount[$sFunctions.Find(skey, gb.IgnoreCase)]
  End Select
  Return 0

End

Private Function IsConditionalOP(c As String) As Boolean

  Return c = "=" Or c = "<" Or c = ">"

End

Private Sub IsFunction(c As String) As Boolean

  Return $sFunctions.Exist(c, gb.IgnoreCase)

End

Private Function IsOperator(c As String) As Boolean

  Return c = "+" Or c = "-" Or c = "/" Or c = "*" Or c = "!" Or c = "%" Or c = "=" Or c = "^" Or c = "&" Or c = "<" Or c = ">"

End

Private Function IsLetterBegin(c As String) As Boolean

  Return (c >= "A" And c <= "Z") Or (c >= "a" And c <= "z")

End

Private Function IsIdent(c As String) As Boolean

  Return (c >= "0" And c <= "9") Or c = "."

End

Private Function Compile(sValue As String) As Boolean

  Dim i As Integer = 1
  Dim j As Integer
  Dim char As String
  'Dim aOutput As New CResult[]
  Dim Stack As New CResult[]
  Dim endfunc As Boolean
  Dim s As String

  Dim hRes As CResult
  Dim lng As Integer = Len(svalue)
  Dim iTmp As Integer

  aCResult.Clear
  While i <= lng
    char = Mid(sValue, i, 1)
    If char = " " Then

      Inc i
      Continue
    Endif
    'Si l'élément est une nombre
    If IsIdent(char) Then
      s = ""
      iTmp = i
      While IsIdent(char)
        s &= char
        Inc i
        char = Mid(sValue, i, 1)
      Wend

      hRes = New CResult(CFloat(s), CResult.TypeValue)
      hres.Pos = iTmp
      aCResult.Add(hRes)
      Dec i

    Else

      'si l'élément est une chaine
      If char = "\"" Or char = "'" Then
        s = ""
        iTmp = i
        Repeat
          Inc i
          char = Mid(svalue, i, 1)
          s &= char
          If i > lng Then
            Return False

          Endif
        Until char = "\"" Or char = "'"
        hres = New CResult(Left(s, -1), CResult.TypeString)
        hres.Pos = iTmp
        aCResult.Add(hres)
      Else
        'Sinon Si l'élément est une fonction ou une variable
        If IsLetterBegin(char) Then
          s = ""
          iTmp = i
          While IsIdent(char) Or IsLetterBegin(char) And i <= Len(svalue)
            s &= char
            Inc i
            char = Mid(svalue, i, 1)

          Wend
          'c'est une fonction
          If char = "(" Then
            'on connait la fonction
            If IsFunction(s) Then
              hres = New CResult(s, CResult.TypeFunc)
              hres.Pos = iTmp
              Stack.Add(hres)
            Else
              'la fonction est inconnue
              $sErrorText = "Error: Unknown function"
              $iErrorPos = i
              Return False
            Endif
          Else
            'c'est une variable
            hres = New CResult(s, CResult.TypeVar)
            hres.Pos = iTmp
            aCResult.Add(hres)

          Endif
          Dec i
        Else
          'sinon si l'élément est un séparateur d'argument
          If char = ";" Then

            endfunc = False
            For j = Stack.Max To 0 Step -1
              s = Stack[j].Value
              If s = "(" Then
                endfunc = True
                Break
              Else
                aCResult.Add(Stack.Pop())
              Endif
            Next
            If Not endfunc Then
              $sErrorText = "Error: separator or parentheses mismatched"
              $iErrorPos = i
              Return False
            Endif

          Else
            'si l'élément est un opérateur
            If IsOperator(char) Then
              For j = Stack.Max To 0 Step -1
                s = Stack[j].Value
                If (IsOperator(s) And ((op_left_assoc(char) And (op_preced(char) <= op_preced(s))) Or (Not op_left_assoc(char) And (op_preced(char) < op_preced(s))))) Then
                  aCResult.Add(Stack.Pop())
                Else
                  Break
                Endif
              Next
              hres = New CResult(char, CResult.TypeOp)
              Stack.Add(hres)
            Else
              'si l'élément est une parenthèse gauche
              If char = "(" Then
                hres = New CResult(char, CResult.TypeOp)
                Stack.Add(hres)
              Else
                'si l'élément est une parenthèse droite
                If char = ")" Then
                  endfunc = False
                  For j = Stack.Max To 0 Step -1
                    s = Stack[j].Value
                    If s = "(" Then
                      endfunc = True
                      Break
                    Else
                      aCResult.Add(Stack.Pop())
                    Endif
                  Next
                  'si pas de parenthèse alors erreur
                  If Not endfunc Then
                    $sErrorText = ("Error: Right parenthese without left one")
                    $iErrorPos = i
                    Return False
                  Endif
                  'Vire la dernière parenthèse de la pile sans l'ajoutée a la sortie
                  Stack.Pop()
                  'SI l'élément au dessu de la pile est une fonction la sortire de la pile
                  'et l'ajouter a la sortie
                  If Stack.Max >= 0 Then
                    s = Stack[Stack.Max].Value
                    If IsFunction(s) Then
                      aCResult.Add(Stack.Pop())
                    Endif
                  Endif
                Else
                  $sErrorText = "Unknow token " & char
                  $iErrorPos = i
                  Return False
                Endif
              Endif
            Endif
          Endif
        Endif
      Endif
    Endif
    Inc i
  Wend
  'Quand tout a été lu et qu'il n'y a des élément dans la pile d'opérateur
  For j = Stack.Max To 0 Step -1
    s = Stack[j].Value
    If s = "(" Or s = ")" Then

      $iErrorPos = Len(svalue)
      $sErrorText = "Error: parentheses mismatched"
      Return False
    Endif
    'hres
    aCResult.Add(Stack.Pop())
  Next
  'aCResult = aOutput
  Return True

End

Public Function Execute() As Boolean

  Dim Stack As New CResult[]
  Dim rn As Integer
  Dim res As CResult
  Dim nargs As Integer
  Dim i, j As Integer
  Dim s, s2 As CResult
  Dim hVal As CResult

  For i = 0 To aCResult.max

    hVal = aCResult[i]

    If hVal.isValue Or hVal.isString Or hval.isVariable Then
      If hval.isVariable Then
        If Not $cVars.Exist(hval.Value) Then
          Raise Data(hval.Value)
          If $vData = Null Then 
              $sErrorText = Subst("Error: Unknown variable '&1' or no value assigned", hVal.Value)
              $iErrorPos = i
              $bError = True
            Return False
           Else
            res = New CResult($vData, GetType(TypeOf($vData)))
          Endif
          $cVars[hval.Value] = res
        Else
          res = $cVars[hval.Value]
        Endif
        Stack.Push(res)
      Else

        Stack.Push(hVal)
      Endif
    Else
      If (hVal.isOperator Or hVal.isFunction) Then

        'res = Format(rn, "_00")
        'Print res & " = ";
        Inc rn
        nargs = op_arg_count(hVal.Value)
        If Stack.Count < nargs Then
          Print "pas assez de valeur entrée"
          Return False
        Endif
        If hVal.isFunction Then
          res = Object.Call(Me, "_" & UCase(hVal.Value), Stack.Extract(Stack.Count - nargs, nargs))
          Stack.Push(res)
        Else

          If nargs = 1 Then
            s = Stack.Pop()
            res = CompareOp(hVal, s)
          Else
            s = Stack.Pop()
            s2 = Stack.Pop()
            If s.isString Or s2.isString Then
              Try res = Concatenate(s, s2, hVal)
            Else
              If IsConditionalOP(hVal.Value) Then
                res = CompareOp(hval, s, s2)
              Else
                res = Calculate(s, s2, hVal)
              Endif
            Endif
            Stack.Push(res)
          Endif
        Endif
      Endif

    Endif
  Next
  ' sil ne reste qu'une valeur dans la pile c'est le résultat !
  If Stack.Count = 1 Then
    Try res = Stack.Pop()
    Try Value = IIf(res.isValue, res.Value, Str(res.Value))
    If Error Then
      $bError = True
      Return False
    Endif

    Return True
  Endif

  'si il y a plus de valeur... c'est qu'il y a une erreur d'entrée
  Return False

End

Private Function GetVar(Res As CResult) As CResult

  Dim hRes As CResult

  If res.isVariable Then
    $vData = Null
    Raise Data
    If $vData Then
      Select Case TypeOf($vData)
        Case gb.Integer, gb.Float
          hres = New CResult($vData, CResult.TypeValue)
        Case Else
          hres = New CResult($vData, CResult.TypeString)
      End Select
      Return hres
    Endif

  Else
    Return Res
  Endif

End

Private Function CompareOp(Operator As CResult, Val1 As CResult, Optional Val2 As CResult) As CResult

  Dim bValue As Boolean

  Select Case Operator.Value
    Case ">"
      bValue = (CFloat(Val2.Value) > CFloat(Val1.Value))
    Case "<"
      bValue = (CFloat(Val2.Value) < CFloat(Val1.Value))
    Case "="
      bValue = (CFloat(Val2.Value) = CFloat(Val1.Value))
    Case "!"
      bValue = Not CBool(Val1)
  End Select
  Return New CResult(IIf(bValue, "True", "False"), CResult.TypeBool)

End

Private Function Calculate(Val1 As CResult, Val2 As CResult, Operator As CResult) As CResult

  Dim fVal1, fVal2 As Float

  fVal1 = CFloat(Val1.Value)
  fVal2 = CFloat(Val2.Value)
  Select Case Operator.Value
    Case "+"
      Return New CResult(fVal2 + fVal1, CResult.TypeValue)
    Case "-"
      Return New CResult(fVal2 - fVal1, CResult.TypeValue)
    Case "*"
      Return New CResult(fVal2 * fVal1, CResult.TypeValue)

    Case "/"
      Return New CResult(fVal2 / fVal1, CResult.TypeValue)
    Case "%"
      Return New CResult(fVal2 % fVal1, CResult.TypeValue)
    Case "^"
      Return New CResult(fVal2 ^ fVal1, CResult.TypeValue)

  End Select

End

Private Function Concatenate(Val1 As CResult, Val2 As CResult, Operator As CResult) As CResult

  Select Case Operator.Value
    Case "&"
      Return New CResult(Val2.Value & Val1.Value, CResult.TypeString)

  End Select

End

'<===================================== Intenal Functions ============================================
Public Sub _IF(Val1 As CResult, Val2 As CResult, Val3 As CResult) As CResult
  'If Not Val1.Type = CResult.isBool Then Return

  If Val1.Value = "True" Then
    Return Val2
  Else
    Return Val3
  Endif

End

'<==========================================  Functions Bridge ========================================================++++>
'
''Computes the arc sine of an angle.
Public Sub _ASIN(Val1 As CResult) As CResult

  Return New CResult(ASin(Val1.Value), CResult.TypeValue)

End

''Computes the hyperbolic arc sine of an angle.
Public Sub _ASINH(Val1 As CResult) As CResult

  Return New CResult(ASinh(Val1.Value), CResult.TypeValue)

End

''Computes the arc tangent of an angle.
Public Sub _ATAN(Val1 As CResult) As CResult

  Return New CResult(ATan(Val1.Value), CResult.TypeValue)

End

''Computes the arc tangent of two numbers.
Public Sub _ATAN2(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(ATan2(Val1.Value, Val2.Value), CResult.TypeValue)

End

''Computes the hyperbolic arc tangent of an angle.
Public Sub _ATANH(Val1 As CResult) As CResult

  Return New CResult(ATanh(Val1.Value), CResult.TypeValue)

End

''Computes the cosine of an angle.
Public Sub _COS(Val1 As CResult) As CResult

  Return New CResult(Cos(Val1.Value), CResult.TypeValue)

End

''Computes the hyperbolic cosine of an angle.
Public Sub _COSH(Val1 As CResult) As CResult

  Return New CResult(Cosh(Val1.Value), CResult.TypeValue)

End

''Converts radians to degrees.
Public Sub _DEG(Val1 As CResult) As CResult

  Return New CResult(Deg(Val1.Value), CResult.TypeValue)

End

''Calculate the hypotenuse of a triangle.
Public Sub _HYP(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(Hyp(Val1.Value, Val2.Value), CResult.TypeValue)

End

''Computes the distance polar coordinate from two rectangular coordinates.
Public Sub _MAG(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(Mag(Val1.Value, Val2.Value), CResult.TypeValue)

End

''Returns π or a multiple of π.
Public Sub _PI() As CResult

  Return New CResult(Pi(), CResult.TypeValue)

End

''Computes the sine of an angle.
Public Sub _SIN(Val1 As CResult) As CResult

  Return New CResult(Sin(Val1.Value), CResult.TypeValue)

End

''Computes the hyperbolic sine of an angle.
Public Sub _SINH(Val1 As CResult) As CResult

  Return New CResult(Sinh(Val1.Value), CResult.TypeValue)

End

''Computes the tangent of an angle.
Public Sub _TAN(Val1 As CResult) As CResult

  Return New CResult(Tan(Val1.Value), CResult.TypeValue)

End

''Computes the hyperbolic tangent of an angle.
Public Sub _TANH(Val1 As CResult) As CResult

  Return New CResult(Tanh(Val1.Value), CResult.TypeValue)

End

''Converts degrees to radians.
Public Sub _RAD(Val1 As CResult) As CResult

  Return New CResult(Rad(Val1.Value), CResult.TypeValue)

End

''Return the absolute value of a number.
Public Sub _ABS(Val1 As CResult) As CResult

  Return New CResult(Abs(Val1.Value), CResult.TypeValue)

End

''Return the smallest integral value that is not less than a number.
Public Sub _CEIL(Val1 As CResult) As CResult

  Return New CResult(Ceil(Val1.Value), CResult.TypeValue)

End

''Return the integer part of a number.
Public Sub _FIX(Val1 As CResult) As CResult

  Return New CResult(Fix(Val1.Value), CResult.TypeValue)

End

''Return the largest integral value that is not greater than a number.
Public Sub _FLOOR(Val1 As CResult) As CResult

  Return New CResult(Floor(Val1.Value), CResult.TypeValue)

End

''Return the fractional part of a number.
Public Sub _FRAC(Val1 As CResult) As CResult

  Return New CResult(Frac(Val1.Value), CResult.TypeValue)

End

''Return the mathematical integer part of a number.
Public Sub _INT(Val1 As CResult) As CResult

  Return New CResult(Int(Val1.Value), CResult.TypeValue)

End

''Return the maximum number.
Public Sub _MAX(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(Max(Val1.Value, Val2.Value), CResult.TypeValue)

End

''Return the minimum number.
Public Sub _MIN(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(Min(Val1.Value, Val2.Value), CResult.TypeValue)

End

''Round a number.
Public Sub _ROUND(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(Round(Val1.Value, Val2.Value), CResult.TypeValue)

End

''Return the sign of a number.
Public Sub _SGN(Val1 As CResult) As CResult

  Return New CResult(Sgn(Val1.Value), CResult.TypeValue)

End

''Returns the ASCII code of a character in a string.
Public Sub _ASC(Val1 As CResult) As CResult

  Return New CResult(Asc(Val1.Value), CResult.TypeValue)

End

''Returns a character from its ASCII code.
Public Sub _CHR(Val1 As CResult) As CResult

  Return New CResult(Chr(Val1.value), CResult.TypeString)

End

''Compares two strings.
Public Sub _COMP(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(Comp(Val1.value, Val2.value), CResult.TypeValue)

End

''Searches a string into another string.
Public Sub _INSTR(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(InStr(Val1.value, Val2.value), CResult.TypeValue)

End

''Converts a string to lowercase.
Public Sub _LCASE(Val1 As CResult) As CResult

  Return New CResult(LCase(Val1.value), CResult.TypeString)

End

''Returns the first characters of a string.
Public Sub _LEFT(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(Left(Val1.value, Val2.value), CResult.TypeString)

End

''Returns the length of a string.
Public Sub _LEN(Val1 As CResult) As CResult

  Return New CResult(Len(Val1.value), CResult.TypeValue)

End

''Strips white spaces from the left of a string.
Public Sub _LTRIM(Val1 As CResult) As CResult

  Return New CResult(LTrim(Val1.value), CResult.TypeString)

End

''Returns a part of a string.
Public Sub _MID(Val1 As CResult, Val2 As CResult, Val3 As CResult) As CResult

  Return New CResult(Mid(Val1.value, Val2.value, Val3.value), CResult.TypeString)

End

''Quotes a string.
Public Sub _QUOTE(Val1 As CResult) As CResult

  Return New CResult(Quote(Val1.value), CResult.TypeString)

End

''Replaces in a string a substring by another one.
Public Sub _REPLACE(Val1 As CResult, Val2 As CResult, Val3 As CResult) As CResult

  Return New CResult(Replace(Val1.value, Val2.value, Val3.value), CResult.TypeString)

End

''Returns the last characters of a string.
Public Sub _RIGHT(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(Right(Val1.value, Val2.value), CResult.TypeString)

End

''Searches a string into another string from its right.
Public Sub _RINSTR(Val1 As CResult, Val2 As CResult, Val3 As CResult) As CResult

  Return New CResult(RInStr(Val1.value, Val2.value, Val3.value), CResult.TypeValue)

End

''Strips white spaces from the right of a string.
Public Sub _RTRIM(Val1 As CResult) As CResult

  Return New CResult(RTrim(Val1.value), CResult.TypeString)

End

''Returns a string containing only space.
Public Sub FSPACE(Val1 As CResult) As CResult

  Return New CResult(Space(Val1.value), CResult.TypeString)

End

''Returns the same string concatenated many times.
Public Sub _STRING(Val1 As CResult, Val2 As CResult) As CResult

  Return New CResult(String(Val1.value, Val2.value), CResult.TypeString)

End

''Strips white spaces from a string.
Public Sub _TRIM(Val1 As CResult) As CResult

  Return New CResult(Trim(Val1.value), CResult.TypeString)

End

''Converts a string to uppercase.
Public Sub _UCASE(Val1 As CResult) As CResult

  Return New CResult(UCase(Val1.value), CResult.TypeString)

End

''Unquotes a string.
Public Sub _UNQUOTE(Val1 As CResult) As CResult

  Return New CResult(UnQuote(Val1.value), CResult.TypeString)

End

Static Private Function Functions_Read() As String[]

  Return $sFunctions

End

Private Function GetType(iType As Integer) As Integer

  If iType = gb.Float Or iType = gb.Integer Then
    Return CResult.TypeValue
  Endif
  Return CResult.TypeString

End

Private Function Data_Read() As Variant

  Return $vData

End

Private Sub Data_Write(Value As Variant)

  $vData = IIf(Value = Null, 0, Value)

End

Private Function Formula_Read() As String

  Return $sFormula

End

Private Sub Formula_Write(Value As String)

  $sFormula = Value
  $sErrorText = ""
  $iErrorPos = -1

  $bError = Not Compile($sFormula)
  If $bError Then
    aCResult.Clear
  Endif

End

Private Function Variables_Read() As CResult[]

  Dim aRes As New CResult[]
  Dim hRes As CResult
  Dim aVar As New String[]

  For Each hres In aCResult
    If hres.isVariable Then
      'attention a ne pas retourner deux fois la même variable
      If Not aVar.Exist(hres.Value) Then
        aRes.Add(hres)
        aVar.Add(hres.Value)
      Endif
    Endif
  Next
  Return aRes

End

Private Function ErrorPos_Read() As Integer

  Return $iErrorPos

End

Private Function Error_Read() As Boolean

  Return $bError

End

Private Function ErrorText_Read() As String

  Return $sErrorText

End


