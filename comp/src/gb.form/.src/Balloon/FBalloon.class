' Gambas class file

Private Const ROUND_SIZE As Integer = 8
Private Const PADDING As Integer = 8
Private Const BACKGROUND_COLOR As Integer = &HFFFFDF&

Static Private $iDelay As Integer = 5000
Static Private $bQtBug As Boolean

Private ARROW_HEIGHT As Integer

Private $hObs As Observer
Private $hWatcher2 As Watcher
Private $hCtrl As Control

Private $X As Integer
Private $Y As Integer
Private $DX As Integer
Private $DY As Integer
Private $dShow As Float
Private $sOld As String
Private $bInside As Boolean
Private $hRound As Image

Private Sub DrawRoundRect(X As Integer, Y As Integer, W As Integer, H As Integer)

  Dim hRound As Image
  
  If Not $hRound Then $hRound = Image.Load("img/round.png")

  hRound = $hRound.Copy()
  Draw.Image(hRound, X, Y)
  hRound.Mirror(True, False)
  Draw.Image(hRound, X + W - ROUND_SIZE, Y)
  hRound.Mirror(False, True)
  Draw.Image(hRound, X + W - ROUND_SIZE, Y + H - ROUND_SIZE)
  hRound.Mirror(True, False)
  Draw.Image(hRound, X, Y + H - ROUND_SIZE)

  Draw.FillStyle = Fill.Solid
  Draw.LineStyle = Line.None
  
  Draw.FillColor = BACKGROUND_COLOR
  Draw.Rect(X + ROUND_SIZE, Y, W - ROUND_SIZE * 2, ROUND_SIZE)
  Draw.Rect(X, Y + ROUND_SIZE, W, H - ROUND_SIZE * 2)
  Draw.Rect(X + ROUND_SIZE, Y + H - ROUND_SIZE, W - ROUND_SIZE * 2, ROUND_SIZE)
  Draw.LineStyle = Line.Solid
  Draw.Foreground = &H808080& '&H808070&
  Draw.Line(X + ROUND_SIZE, Y, X + W - ROUND_SIZE - 1, Y)
  Draw.Line(X + ROUND_SIZE, Y + H - 1, X + W - ROUND_SIZE, Y + H - 1)
  Draw.Line(X, Y + ROUND_SIZE, X, Y + H - ROUND_SIZE - 1)
  Draw.Line(X + W - 1, Y + ROUND_SIZE, X + W - 1, Y + H - ROUND_SIZE - 1)
  
End

Private Sub GetTopLevel(hCtrl As Control) As Window
  
  Dim hWin As Window

  If Not hCtrl Then Return  
  hWin = hCtrl.Window
  Do
    If hWin.TopLevel Then Return hWin
    hWin = hWin.Parent.Window
  Loop
  
End

' Static Private Sub PaintRoundRect(x As Float, y As Float, w As Float, h As Float, Radius As Float)
' 
'   Dim ARC_TO_BEZIER As Float = 0.55228475
'   Dim c1, c2 As Float
'   Dim i As Integer
'   Dim radius_x As Float[] = [Radius, Radius, Radius, Radius]
'   Dim radius_y As Float[] = radius_x.Copy()
' 
'   For i = 0 To 3
'     If radius_x[i] > w - radius_x[i] Then
'       radius_x[i] = w / 2
'     Endif
' 
'     If radius_y[i] > h - radius_y[i] Then
'       radius_y[i] = h / 2
'     Endif
' 
'   Next
'   'approximate(quite Close )the arc using a bezier curve
' 
'   '        A**********B
'   '       H            C
'   '       *            *
'   '       *            *
'   '       G            D
'   '        F**********E
' 
'   '-->A
'   Paint.MoveTo(x + radius_x[0], y)
' 
'   '-->B
'   Paint.LineTo(x + w - radius_x[1], y)
' 
'   '-->C
'   c1 = ARC_TO_BEZIER * radius_x[1]
'   c2 = ARC_TO_BEZIER * radius_y[1]
'   Paint.RelCurveTo(c1, 0.0, radius_x[1], c2, radius_x[1], radius_y[1])
' 
'   '-->D
'   Paint.LineTo(x + w, y + h - radius_y[2])
' 
'   '-->E
'   c1 = ARC_TO_BEZIER * radius_x[2]
'   c2 = ARC_TO_BEZIER * radius_y[2]
'   Paint.RelCurveTo(0.0, c2, c1 - radius_x[2], radius_y[2], - radius_x[2], radius_y[2])
' 
'   '-->F
'   Paint.LineTo(x + radius_x[3], y + h)
' 
'   '-->G
'   c1 = ARC_TO_BEZIER * radius_x[3]
'   c2 = ARC_TO_BEZIER * radius_y[3]
'   Paint.RelCurveTo(- c1, 0, - radius_x[3], - c2, - radius_x[3], - radius_y[3])
' 
'   '-->H
'   Paint.LineTo(x, y + radius_y[0])
' 
'   '-->A
'   c1 = ARC_TO_BEZIER * radius_x[0]
'   c2 = ARC_TO_BEZIER * radius_y[0]
'   Paint.relcurveto(0.0, - c2, radius_x[0] - c1, - radius_y[0], radius_x[0], - radius_y[0])
' 
'   'Paint.closepath()
' 
' End


Private Sub MakeBorder(Optional W As Integer, H As Integer)
  
  Dim hPict As Picture
  Dim hImage As Image
  Dim SX, SY, CX, CY As Integer
  Dim X, Y, X1, Y1, X2, Y2, X3, Y3, Y4 As Integer
  Dim hWin As Window
  Dim sNew As String
  Dim hCtrl As Control
  Dim iColor As Integer
  
  $X = $hCtrl.ScreenX
  $Y = $hCtrl.ScreenY

  If $DX < 0 Then
    SX = $X + $hCtrl.W \ 2
  Else 
    SX = $X + $DX
  Endif 
  If $DY < 0 Then 
    SY = $Y + $hCtrl.H \ 2
  Else 
    SY = $Y + $DY
  Endif
  
  'DEBUG $hCtrl;; "SX =";; SX;; "SY =";; SY
  
  hWin = GetTopLevel($hCtrl)
  'DEBUG hWin
  
  CX = hWin.ScreenX + hWin.W \ 2
  CY = hWin.ScreenY + hWin.H \ 2
  
  'DEBUG "CX =";; CX;; "CY =";; CY
'   IF SX < (Desktop.W \ 2) THEN 
'     X = Max(0, SX - ME.W \ 2 - 32)
'   ELSE 
'     X = Min(Desktop.W - ME.W, SX - ME.W \ 2 + 32)
'   ENDIF
' 
  If W <= 0 Then W = Me.W
  If H <= 0 Then H = Me.H

  If SX < CX And SX >= W Then 
    X = SX - W \ 2 - ARROW_HEIGHT
  Else 
    X = SX - W \ 2 + ARROW_HEIGHT
  Endif

  X = Desktop.X + Max(4, Min(Desktop.W - W - 4, X))

  'IF SY < (Desktop.H \ 2) THEN 
  
  'DEBUG SY;; CY;; ME.H
  
  If (SY >= CY And SY < (Desktop.Y + Desktop.Height - H)) Or SY < (Desktop.Y + H) Then 
    Y1 = 0
    Y4 = ARROW_HEIGHT
    Y2 = Y4 + 1
    Y = SY
  Else 
    Y1 = H - 1
    Y4 = H - ARROW_HEIGHT - 1
    Y2 = Y4 - 1
    Y = SY - H
  Endif
  
  Y = Desktop.Y + Max(4, Min(Desktop.H - H - 4, Y))
  
  'DEBUG "X =";; X;; "Y =";; Y;; "W =";; W;; "H ="; H

  Y3 = Y2
  
  X1 = Min(Max(16, SX - X), W - 16)
  'X2 = W \ 2 - 12
  'X3 = X2 + 24
  If X1 < (W \ 2) Then 
    X2 = X1
  Else
    X2 = X1 - ARROW_HEIGHT
  Endif
  X2 = Max(X2, 16)
  X3 = X2 + ARROW_HEIGHT

  Me.Move(X, Y, W, H)
  
  sNew = ARROW_HEIGHT & " " & Me.W & " " & Me.H & " " & X1 & " " & Y1 & " " & X2 & " " & Y2 & " " & X3 & " " & Y3
  If sNew <> $sOld Then

    'DEBUG sNew
    'ME.Hide
    '
    ' hImage = New Image(Me.W, Me.H, Color.Transparent)
    ' Paint.Begin(hImage)
    ' 
    ' PaintRoundRect(0, ARROW_HEIGHT, Paint.W, Paint.H - ARROW_HEIGHT * 2, 12)
    ' Paint.Brush = Paint.Color(Me.Background)
    ' Paint.Fill
    ' PaintRoundRect(0.5, ARROW_HEIGHT + 0.5, Paint.W - 1, Paint.H - ARROW_HEIGHT * 2 - 1, 12)
    ' iColor = Color.Black 'Color.Merge(&H808080, Me.Background)
    ' Paint.Brush = Paint.Color(iColor)
    ' Paint.LineWidth = 1
    ' Paint.Stroke
    ' 
    ' Paint.End
    ' 
    ' hPict = hImage.Picture
    ' 
    
    hPict = New Picture(Me.W, Me.H)
  
    Draw.Begin(hPict)
    
    Draw.FillRect(0, 0, Draw.W, Draw.H, Color.White)
    DrawRoundRect(0, ARROW_HEIGHT, Me.W, Me.H - ARROW_HEIGHT * 2)

    Draw.FillStyle = Fill.Solid
    Draw.LineStyle = Line.None
    
    Draw.FillColor = iColor
    'DrawInternalRect(0, ARROW_HEIGHT, ME.W, ME.H - ARROW_HEIGHT * 2)
    Draw.Polygon([X1, Y1, X2, Y2, X3, Y3])

    Draw.FillColor = Me.Background
    'DrawInternalRect(1, ARROW_HEIGHT + 1, ME.W - 2, ME.H - (ARROW_HEIGHT + 1) * 2)
    Draw.Polygon([X1, Y1, X2, Y2, X3, Y3])

    Draw.LineStyle = Line.Solid
    Draw.Foreground = Me.Background
    Draw.Line(X1, Y1, X2 + 1, Y4)
    Draw.Line(X1, Y1, X3 - 1, Y4)
    Draw.Foreground = iColor
    Draw.Line(X1, Y1, X2, Y4)
    Draw.Line(X1, Y1, X3, Y4)
  
    Draw.End
    
    hImage = hPict.Image
    'hImage = hImage.Erase()
    hImage.Replace(BACKGROUND_COLOR, Me.Background)
    hImage.Replace(Color.TextBackground, Color.Transparent)
    hPict = hImage.Picture
  
    'Wait
    Me.Picture = hPict
    
    $sOld = sNew
    
  Endif 
  
  hCtrl = Application.ActiveControl
  
  If Not Me.Visible Then 
    hWin = Application.ActiveWindow
    Me.Show
    ' If hWin Then 
    '   Debug hWin
    '   hWin.Show
    '   Wait
    '   hWin.Show
    ' Endif
  Else  
    Form_Show
    Me.Raise
  Endif
  
  Try GetTopLevel(hCtrl).Show
  Try hCtrl.SetFocus
  
  $dShow = Timer
  
End

Public Sub Run(sMsg As String, hCtrl As Control, hIcon As Picture, DX As Integer, DY As Integer)
  
  Dim X, Y, W, H As Integer
  Dim hWin As Window
  
  'IF hCtrl <> $hCtrl THEN 
  '  DEBUG
  '  ME.Hide
  'ELSE
    Form_Hide
  'ENDIF
  
  txtMessage.W = Max(hCtrl.W / 2, 768)
  txtMessage.Text = Replace(sMsg, "\n", "<br>")
  txtMessage.Adjust
  If txtMessage.W < 64 Then txtMessage.W = 64
  'txtMessage.Adjust
  'DEBUG txtMessage.W

  $hCtrl = hCtrl
  ARROW_HEIGHT = Min(16, $hCtrl.H \ 4 + 8)
  $DX = DX
  $DY = DY

  hWin = GetTopLevel($hCtrl)
  If Not hWin.Modal Then hWin.Show
  
  $hObs = New Observer(hWin) As "Window"
  $hWatcher2 = New Watcher($hCtrl) As "Watcher"

  If hIcon Then 
    imgIcon.Picture = hIcon
    imgIcon.Resize(hIcon.Width, hIcon.Height)
    imgIcon.Show
    W = txtMessage.W + imgIcon.W + 8 + PADDING * 2
    H = Max(txtMessage.H, imgIcon.H) + PADDING * 2 + ARROW_HEIGHT * 2
    imgIcon.Move(PADDING, PADDING + ARROW_HEIGHT)
    txtMessage.Move(imgIcon.X + imgIcon.W + 8, PADDING + ARROW_HEIGHT) ', ME.W - 32 - imgIcon.W - 8)
  Else
    imgIcon.Hide
    W = txtMessage.W + PADDING * 2
    H = txtMessage.H + PADDING * 2 + ARROW_HEIGHT * 2
    txtMessage.Move(PADDING, PADDING + ARROW_HEIGHT) ', ME.W - 32)
  Endif

  MakeBorder(W, H)
  
End


Public Sub Form_Show()

  'DEBUG
  'timCheck.Enabled = FALSE
  'GetTopLevel($hCtrl).Show
  timCheck.Delay = timCheck.Delay
  timCheck.Enabled = True

End

Public Sub Form_Hide()

  'Debug
  timCheck.Enabled = False
  $hObs = Null
  $hWatcher2 = Null

End

Public Sub Watcher_Hide()
  
  'Debug
  Me.Close
  
End

' PUBLIC SUB Form_Deactivate()
'   
'   ME.Hide
'   
' END

Public Sub txtMessage_MouseDown()

  'Debug 
  Me.Close

End

Public Sub Form_MouseDown()

  'Debug 
  Me.Close

End

Public Sub Window_Move()
  
  If Not Me.Visible Then Return
  
  If Abs($hCtrl.ScreenX - $X) >= 4 Or Abs($hCtrl.ScreenY - $Y) >= 4 Then
    MakeBorder
  Endif
  
End

Public Sub Window_Hide()
  
  'Debug
  Me.Close
  
End

Public Sub timCheck_Timer()

  Dim hWin As Window

  'Debug Me.X;; Me.Y;; Me.Visible;; Me.Picture.W;; Me.Picture.H
  If $bInside Then 
    'Debug
    Me.Close
    Return 
  Endif 

  If (Timer - $dShow) > ($iDelay / 1000) Then 
    'Debug
    Me.Close
    Return 
  Endif
  
  ' hWin = GetTopLevel($hCtrl)
  ' If Not hWin.TopOnly Then
  '   Debug Application.ActiveWindow;; GetTopLevel(Application.ActiveWindow);; hWin
  '   If GetTopLevel(Application.ActiveWindow) <> hWin Then 
  '     Debug "HIDE 3"
  '     Me.Hide
  '     Return
  '   Endif
  ' Endif
  
  If Abs($hCtrl.ScreenX - $X) >= 4 Or Abs($hCtrl.ScreenY - $Y) >= 4 Then
    MakeBorder
  Endif
  
End

Public Sub GetControl() As Control
  
  If Me.Visible Then Return $hCtrl
  
End


Static Public Sub GetDelay() As Integer
  
  Return $iDelay
  
End

Static Public Sub SetDelay(iDelay As Integer)

  $iDelay = iDelay
  
End

Public Sub _new()

  Me.Background = Color.Merge(Color.TextBackground, Color.LightBackground)
  

End