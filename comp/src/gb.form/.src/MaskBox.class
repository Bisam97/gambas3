' Gambas class file

Export

Inherits TextBox

Public Const _Properties As String = "*,Mask,MaskChar"
'Public Const _DefaultEvent As String = "Click"
'Public Const _DefaultSize As String = "24,4"
Public Const _Similar As String = "TextBox"
Public Const _DrawWith As String = "TextBox"

'Property Picture As Picture
'Property Text As String
'Property Read Length As Integer
'Property ReadOnly As Boolean
'Property Border As Boolean
'Property Read Editor As TextBox
'Property Button As Boolean
Property Mask As String
Property MaskChar As String

'Private $hPanel As Panel
'Private $hBackground As DrawingArea
'Private $bBorder As Boolean
'Private $hTextBox As TextBox
'Private $hButton As ToolButton
Private $hObserver As Observer

Private Const MASK_CHARACTER As String = "90A6?"
Private Const MASK_DEFAULT As String = "_0___"

Private $sMaskOrg As String

Private $aMask As String[]
Private $sDefault As String
Private $sSeparator As String
Private $sAlign As String

Private $bUpperCase As Boolean
Private $bLowerCase As Boolean

Private $sMaskChar As String

Public Sub _new()
  
  $hObserver = New Observer(Me) As "TextBox"
  
End

Private Function Mask_Read() As String

  Return $sMaskOrg

End

Private Sub GetDefaultCharacter(iPos As Integer) As String
  
  Dim sCar As String = String.Mid$($sDefault, iPos + 1, 1)
  If sCar = " " Then sCar = String.Mid$($sSeparator, iPos + 1, 1)
  Return sCar
  
End


Private Sub MakeDefault() As String
  
  Dim sDefault As String
  Dim sCar As String
  Dim iInd As Integer
  
  For iInd = 0 To $aMask.Max
    sDefault &= GetDefaultCharacter(iInd)
  Next
  
  Return RTrim(sDefault)
  
End

Private Sub GetFirstCharacterPos() As Integer
  
  Dim iPos As Integer
  
  For iPos = 0 To $aMask.Max
    If $aMask[iPos] Then Return iPos
  Next
  
End

Private Sub GetLastCharacterPos() As Integer
  
  Dim iPos As Integer
  
  For iPos = $aMask.Max DownTo 0
    If $aMask[iPos] Then Return iPos + 1
  Next
  
End

Private Sub UpdateMaskAndSeparator(sMask As String)
  
  Dim iPos, iPos2 As Integer
  Dim sCar As String
  Dim iLen As Integer
  Dim aMask As New String[]
  Dim sSeparator As String
  Dim sAlign As String
  Dim sDefault As String

  iLen = String.Len(sMask)

  For iPos = 1 To iLen
    sCar = String.Mid$(sMask, iPos, 1)
    If sCar = "[" Then
      iPos2 = String.InStr(sMask, "]", iPos)
      If iPos2 = 0 Then Error.Raise("Bad mask")
      aMask.Add(String.Mid$(sMask, iPos, iPos2 - iPos + 1))
      iPos = iPos2
      sSeparator &= " "
      sDefault &= "_"
      Continue
    Else If sCar = "?" Then
      aMask.Add(sCar)
      sSeparator &= " "
      sDefault &= "_"
    Else If sCar = "0" Then
      aMask.Add("[0-9]")
      sSeparator &= " "
      sDefault &= "0"
    Else If sCar = "9" Then
      aMask.Add("[0-9]")
      sSeparator &= " "
      sDefault &= "_"
    Else If sCar = "A" Then
      aMask.Add("[A-Za-z]")
      sSeparator &= " "
      sDefault &= "_"
    Else If sCar = "\\" And If iPos < iLen Then
      aMask.Add("")
      Inc iPos
      sSeparator &= String.Mid$(sMask, iPos, 1)
      sDefault &= " "
    Else
      aMask.Add("")
      sSeparator &= sCar
      sDefault &= " "
    Endif
  Next
  
  $sMaskOrg = sMask
  $aMask = aMask
  $sSeparator = sSeparator
  $sAlign = sAlign
  $sDefault = sDefault
  If $sMaskChar Then $sDefault = Replace($sDefault, "_", $sMaskChar)
  
End


Private Sub Mask_Write(Value As String)

  UpdateMaskAndSeparator(Value)
  
  If Not $sMaskOrg Then Return
  
  Me.Text = MakeDefault()
  Me.Pos = GetFirstCharacterPos()

End

' Private Sub IsMaskCharacter(sCar As String) As Boolean
'   
'   Return InStr(MASK_CHARACTER, sCar)
'   
' End

Private Sub GetNextSeparator(sText As String, iPos As Integer, Optional sSep As String) As Integer
  
  Dim iLen As Integer = String.Len(sText)
  Dim sCar As String
  
  If iPos < 0 Then Return 0
  
  While iPos < iLen
    sCar = $aMask[iPos]
    If Not sCar Then
      If Not sSep Then Break
      If sSep = String.Mid$(sText, iPos + 1, 1) Then Break
    Endif
    Inc iPos
  Wend
  
  Return iPos
  
End

Private Sub GetNextCharacter(sText As String, iPos As Integer) As Integer
  
  Dim iLen As Integer = String.Len(sText)
  
  If iPos < 0 Then Return 0
  
  While iPos < iLen
    If $aMask[iPos] Then Break
    Inc iPos
  Wend
  
  Return iPos
  
End



Public Sub TextBox_KeyPress()
  
  Dim sText As String
  Dim iOldPos, iPos, iPosNext As Integer
  Dim iMove As Integer
  Dim sCar As String
  Dim sInsert As String
  Dim bDelete As Boolean
  Dim sDefault As String
  Dim bChange As Boolean
  
  If Not $sMaskOrg Then Return
  
  sText = Me.Text
  If Me.Selected Then
    iPos = GetNextCharacter(sText, Me.Selection.Start)
  Else
    iPos = Me.Pos
  Endif
  
  Select Key.Code
    
    Case Key.Left
      iMove = -1
      
    Case Key.Right
      iMove = 1
      
    Case Key.Home
      iPos = GetFirstCharacterPos()
      
    Case Key.End
      iPos = GetLastCharacterPos()
      
    Case Key.Delete
      If iPos < Me.Length
        iMove = 0
        bDelete = True
      Endif
      
    Case Key.BackSpace
      If iPos > 0 Then
        iMove = -1
        bDelete = True
      Endif
    
    Case Key.Tab, Key.BackTab, Key.Up, Key.Down
      Return
    
    Case Else
      
      If Key.Code = Key["A"] And If Key.Control Then
        Me.SelectAll
        Stop Event
        Return
      Endif
      
      If Key.Text And iPos < $aMask.Count Then
        
        sCar = $aMask[iPos]
        If sCar And If Key.Text Like sCar Then sInsert = Key.Text
          
        If Not sInsert Then
          iPosNext = GetNextSeparator(sText, iPos - 1, Key.Text)
          If iPosNext >= Me.Length Then Goto DO_NOTHING
          iPos = iPosNext
        Endif
        iMove = 1
          
      Endif
    
  End Select
  
  If sInsert Or If bDelete Then
    If Me.Selected Then
      If Me.Selection.Length = Me.Length Then sText = MakeDefault()
      'sText = String.Left$(sText, Me.Selection.Start) & String.Mid$(sDefault, Me.Selection.Start + 1, Me.Selection.Length) & String.Mid$(sText, Me.Selection.Start + Me.Selection.Length + 1)
      iPos = GetNextCharacter(sText, Me.Selection.Start)
      Me.Selection.Hide
    Endif
  Endif
  
  If sInsert Then
    sText = String.Left(sText, iPos) & sInsert & String.Mid$(sText, iPos + 1 + String.Len(sInsert))
  Endif
  
  If iMove Then
    
    iOldPos = iPos
    Do
      iPos += iMove
      If iPos < 0 Then
        iPos = GetFirstCharacterPos()
        Break
      Endif
      If iPos >= Me.Length Then
        iPos = GetLastCharacterPos()
        Break
      Endif
      If $aMask[iPos] Then Break
    Loop
    
  Endif
  
  If bDelete Then
    iPosNext = GetNextSeparator(sText, iPos)
    If iPosNext > iPos Then
      sText = RTrim(String.Left(sText, iPos) & String.Mid$(sText, iPos + 2, iPosNext - iPos - 1) & GetDefaultCharacter(iPosNext - 1) & String.Mid$(sText, iPosNext + 1))
    Endif
  Endif
  
  If Me.Text <> sText Then Me.Text = sText
  Me.Pos = iPos
  'Me.Select(iPos, 1)

DO_NOTHING:
  
  Stop Event
  
End

Private Function MaskChar_Read() As String

  Return $sMaskChar  

End

Private Sub MaskChar_Write(Value As String)

  Dim sText As String
  Dim iPos As Integer
  Dim sCar As String
  Dim aPos As New Integer[]

  Value = String.Left(Value)
  sText = Me.Text
  
  For iPos = 0 To $aMask.Max
    sCar = $aMask[iPos]
    If Not sCar Or If String.Mid$($sDefault, iPos + 1, 1) <> "_" Then Continue
    If String.Mid$(sText, iPos + 1, 1) = GetDefaultCharacter(iPos) Then aPos.Add(iPos)
  Next
  
  $sMaskChar = Value
  UpdateMaskAndSeparator($sMaskOrg)
  
  For Each iPos In aPos
    sText = String.Left(sText, iPos) & GetDefaultCharacter(iPos) & String.Mid$(sText, iPos + 2)
  Next
  
  Me.Text = RTrim(sText)
  Me.Pos = GetFirstCharacterPos()

End
