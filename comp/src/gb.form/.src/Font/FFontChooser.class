' Gambas class file

Public Family As String
Public Bold As Boolean
Public Italic As Boolean
Public Underline As Boolean
Public Strikeout As Boolean
Public Size As Integer
Public Grade As Integer
Public ShowFixed As Boolean

Public StylePanel As Container
Public Preview As Control

Private $iNoChange As Integer
Private $bNoRefresh As Boolean
Private $sLast As String
Private $bShowLabel As Boolean

Private $sSplitFont As String
Private $aSplitFont As String[]
Private $bShowFont As Boolean
Private $sLastFilter As String

Public Sub _new()
  
  Inc $iNoChange
  $bNoRefresh = True
  $bShowFont = True
  Me.Proxy = txtFilter
  
  'lstSize.List = ["6", "7", "8", "9", "10", "11", "12", "13", "14", "16", "18", "20", "24", "28", "32", "36", "40", "48", "56", "64", "72", "80", "96", "112", "128"]
  
  StylePanel = panStyle
  Preview = txtExample
  
  txtFamily.Foreground = Color.Merge(Color.LightForeground, Color.Foreground)
  
  SetFont("")
  
End

Public Sub Form_Open()

  'RefreshFamily
  UpdateRelative
  txtSize_Change
  Dec $iNoChange
  
End

' Private Sub RefreshGrade()
' 
'   Dim iInd As Integer
'   Dim H As Integer
'   Dim hFont As Font
'   Dim sGrade As String
' 
'   If $bNoRefresh Then Return
'   If chkSize.Value Then Return
' 
'   Inc Application.Busy
' 
'   For iInd = 0 To NBR_GRADE - 1
'     sGrade = Trim(Format(FIRST_GRADE + iInd, "+#"))
'     hFont = Font[GetFont(sGrade)]
'     H = hFont.Height + 4
'     With $hGrade[iInd]
'       .Font = hFont
'       .Height = H
'       .Text = " " & sGrade & " " & Family
'       .Tag = FIRST_GRADE + iInd
'       If .Tag = Grade Then 
'         lstGrade.Select($hGrade[iInd])
'       Endif
'     End With
'   Next
' 
'   Dec Application.Busy
' 
' End

Private Sub IsSeparator(sCar As String) As Boolean
  
  If Not IsPunct(sCar) Then Return
  If InStr("()[]{}", sCar) Then Return
  Return True
  
End


Private Sub SplitFont(sFont As String, N As Integer) As String
  
  Dim I As Integer
  Dim sCar As String
  
  If sFont <> $sSplitFont Then
    $sSplitFont = sFont
    $aSplitFont = New String[]
    
    sFont = " " & sFont & " "
    While Len(sFont) > 1
      For I = 2 To Len(sFont)
        sCar = Mid$(sFont, I, 1)
        If IsSeparator(sCar) Or If IsSpace(sCar) Then Goto SPLIT_FONT
        If IsUCase(sCar) Then
          sCar = Mid$(sFont, I - 1, 1)
          If IsSeparator(sCar) Or If IsSpace(sCar) Or IsUCase(sCar) Then Continue
          If Not IsLetter(Mid(sFont, I + 1, 1)) Then Continue
          Goto SPLIT_FONT
        Endif
        Continue
        
      SPLIT_FONT:
        $aSplitFont.Add(Left$(sFont, I - 1))
        sFont = Mid$(sFont, I)
        Break
        
      Next
    Wend
    
  Endif
  
  If N <= $aSplitFont.Count Then Return Trim($aSplitFont.Copy(0, N - 1).Join(""))
  
  ' For I = 1 To Len(sFont)
  '   sCar = Mid$(sFont, I, 1)
  '   If IsUCase(sCar) Or If IsPunct(sCar) Or If sCar = " " Then
  '     If S Then
  '       If (I - S) >= 2 Or If sCar = " " Or If IsPunct(sCar) Then 
  '         Dec N
  '         If N = 0 Then Return RTrim(Left$(sFont, I - 1))
  '       Endif
  '     Endif
  '     S = I
  '   Endif
  ' Next
  
End

Private Sub GetFontName(sFont As String) As String

  Dim sText As String

  If $bShowFont Then
    sText = "<font size=\"+2\" face=\"" & Html(sFont) & "\">" & Html(sFont) & "</font>"
  Else
    sText = Html(sFont)
  Endif
  
  Return sText
  
End

Private Sub FillFamily()
  
  Dim sFont As String
  Dim cFont As Collection
  Dim aFont As String[]
  Dim I As Integer
  Dim sParentFont As String
  Dim hParent As Menu
  Dim iCount As Integer
  Dim cParent As New Collection
  Dim sFilter As String
  Dim sText As String
  Dim H As Integer
  
  sFilter = Trim(txtFilter.Text)
  If tvwFamily.Count And If sFilter = $sLastFilter Then Return
  $sLastFilter = sFilter
  
  Inc Application.Busy
  
  tvwFamily.Clear
  
  H = tvwFamily.Font.H * 2
  
  cFont = New Collection
  aFont = New String[]
  
  For Each sFont In Fonts
    
    If ShowFixed Then
      If Not Font[sFont].Fixed Then Continue
    Endif
    
    If sFilter And If InStr(sFont, sFilter, 1, gb.IgnoreCase) = 0 Then Continue
    
    For I = 16 DownTo 1
      sParentFont = SplitFont(sFont, I)
      If Not sParentFont Then Continue
      If Not cFont.Exist(sParentFont) Then
        cFont[sParentFont] = 0
        aFont.Add(sParentFont)
      Else
        Inc cFont[sParentFont]
        Break
      Endif
    Next
    
    cFont[sFont] = 1000
    aFont.Add(sFont)
    
  Next
  
  aFont.Sort(gb.Natural + gb.IgnoreCase)
  ' For Each sFont In aFont
  '   Print cFont[sFont];; sFont
  ' Next
  
  tvwFamily._Begin()
  
  For Each sFont In aFont
    
    iCount = cFont[sFont]
    If iCount = 0 Then Continue
    
    hParent = Null
    For I = 16 DownTo 1
      sParentFont = SplitFont(sFont, I)
      If Not sParentFont Then Continue
      If cParent.Exist(sParentFont) Then Break
      sParentFont = ""
    Next
    
    If sParentFont And If tvwFamily[sParentFont].Children = 0 Then
      With tvwFamily[sParentFont]
        .Foreground = Color.Merge(Color.LightForeground, Color.TextForeground)
        .Background = Color.Merge(Color.LightForeground, Color.TextBackground, 0.8)
        .Expanded = True
        .Font = Font["-2"]
        .RichText = ""
        .Text = sParentFont
        .H = 0
      End With
      If cFont[sParentFont] >= 1000 Then
        With tvwFamily.Add("." & sParentFont, "",, sParentFont)
          .H = H
          .RichText = GetFontName(sParentFont)
        End With
      Endif
    Endif
    
    With tvwFamily.Add(sFont, "",, sParentFont)
      .H = H
      .RichText = GetFontName(sFont)
    End With
    cParent[sFont] = True
    
  Next
  
  'UpdateShowFont
  
  tvwFamily._End()
  
  Dec Application.Busy

End

Private Sub UpdateShowFont()
  
  Dim sKey As String
  
  For Each sKey In tvwFamily.Keys
    
    With tvwFamily[sKey]
      If .Children = 0 Then 
        If sKey Begins "." Then sKey = Mid$(sKey, 2)
        If $bShowFont Then
          .Font = Font[sKey & ",+4"]
        Else
          .Font = Null
        Endif
        '.Text = "\n" & .Text & "\n"
      Endif
    End With
    
  Next
  
End

Public Sub RefreshFamily(Optional bForce As Boolean)
  
  Dim hFont As Font
  Dim sFamily As String
  Dim bExist As Boolean
  
  If bForce Then tvwFamily.Clear

  If $bNoRefresh Then Return
  
  Inc $iNoChange
  
  If tvwFamily.Visible Then
    
    FillFamily
    If EnsureFontVisible() Then
      tvwFamily.MoveFirst()
      Try Family = tvwFamily.Item.Key
      EnsureFontVisible
    Endif
    
  Else
    
    cmbFamily.Clear
    For Each sFamily In Fonts
      hFont = Font[sFamily]
      If ShowFixed And Not hFont.Fixed Then Continue
      cmbFamily.Add(sFamily)
      If sFamily = Family Then bExist = True
    Next
    
    If bExist Then
      cmbFamily.Text = Family
    Else
      cmbFamily.Index = 0
    Endif
    
    Family = cmbFamily.Text
    
  Endif
  
  Dec $iNoChange
  
  RefreshExample
  
End

Private Sub EnsureFontVisible() As Boolean
  
  Dim sKey As String
  
  sKey = "." & Family
  If Not tvwFamily.Exist(sKey) Then sKey = Family
  If Not tvwFamily.Exist(sKey) Then Return True

  With tvwFamily[sKey]
    .Selected = True
    'tvwFamily[sKey].EnsureVisible
    tvwFamily.ScrollY = .Y + tvwFamily.ScrollY - (tvwFamily.ClientH - .H) \ 2
  End With
  
End

Public Sub SetFont(sFont As String)
  
  Dim hFont As Font = Font[sFont]
  Dim bRelative As Boolean
  Dim sElt As String
  
  bRelative = True
  
  For Each sElt In Split(sFont, ",")
    sElt = Trim(sElt)
    If InStr("0+-", Left(sElt)) = 0 And If IsDigit(Left(sElt)) Then
      bRelative = False
      Break
    Endif
  Next
  
  Family = hFont.Name
  Bold = hFont.Bold
  Italic = hFont.Italic
  Underline = hFont.Underline
  StrikeOut = hFont.StrikeOut
  Size = hFont.Size
  Grade = hFont.Grade
  
  btnRelative.Value = bRelative
  
  EnsureFontVisible
  
  btnBold.Value = Bold
  btnItalic.Value = Italic
  btnUnderline.Value = Underline
  btnStrikeout.Value = StrikeOut
  
  'chkUnderline.Value = UnderLine
  'chkStrikeout.Value = StrikeOut
  
  If bRelative Then
    txtSize.Value = Grade
  Else
    txtSize.Value = Size
  Endif
  
  txtExample.Text = ("How quickly daft jumping zebras vex") & "\n0123456789 àéîöùÀÉÎÖÙ [({*%#"
  
  RefreshExample
  
End

Public Function GetFont() As String
  
  Dim sFont As String
  
  sFont = Family
  If Bold Then sFont &= ",Bold"
  If Italic Then sFont &= ",Italic"
  If Underline Then sFont &= ",Underline"
  If Strikeout Then sFont &= ",Strikeout"
  If btnRelative.Value Then
    If Grade Then sFont &= "," & Trim(Format(Grade, "+#"))
  Else
    sFont &= "," & Size
  Endif
  
  Return sFont
  
End

Private Sub GetParent() As Object
  
  Return Me.Parent
  
End

Private Sub RefreshExample()
  
  Dim sFont As String = GetFont()
  
  If $bNoRefresh Then Return
  
  If sFont = $sLast And If panExample.Expand = cmbFamily.Visible Then Return
  
  If panExample.Visible Then
    
    txtFamily.Text = Family
    txtExample.Font = Font[sFont]
    
    If cmbFamily.Visible Then
      panExample.Expand = True
    Else
      panExample.Expand = False
      panExample.H = Max(Desktop.Scale * 8, Min(Desktop.Scale * 16, txtExample.Font.Height * 2)) + txtFamily.H + 1 + Desktop.Scale * 2
    Endif
    
  Endif
  
  Size = Font[sFont].Size
  Grade = Font[sFont].Grade
  
  sldSize.Value = txtSize.Value
  
  If $iNoChange = 0 Then GetParent()._Change
  If Not panExample.Visible Then GetParent()._Activate
  
  $sLast = sFont
  
End

Public Sub tvwFamily_Select()
  
  If Not tvwFamily.Current Then Return
  
  If tvwFamily.Current.Children Then
    Return
  Endif
  
  Family = tvwFamily.Key
  If Family Begins "." Then Family = Mid$(Family, 2)
  RefreshExample
  
End

Public Sub cmbFamily_Click()
  
  Family = cmbFamily.Text
  RefreshExample
  
End

Public Sub btnBold_Click()
  
  Bold = btnBold.Value
  RefreshExample
  
End

Public Sub btnItalic_Click()
  
  Italic = btnItalic.Value  
  RefreshExample
  
End

Public Sub txtSize_Change()
  
  If btnRelative.Value Then
    Grade = txtSize.Value
  Else
    Size = txtSize.Value
  Endif
  sldSize.Value = txtSize.Value
  RefreshExample
  
End

Private Sub UpdateRelative()
  
  Object.Lock(txtSize)
  Object.Lock(sldSize)
  If btnRelative.Value Then
    txtSize.MinValue = -8
    txtSize.MaxValue = 24
    txtSize.Value = Grade
    sldSize.PageStep = 1
  Else
    txtSize.MinValue = 1
    txtSize.MaxValue = 256
    txtSize.Value = Size
    sldSize.PageStep = 4
  Endif
  
  sldSize.MinValue = txtSize.MinValue
  sldSize.MaxValue = txtSize.MaxValue
  
  Object.Unlock(txtSize)
  Object.Unlock(sldSize)
  txtSize_Change
  
End

Public Sub btnRelative_Click()
  
  UpdateRelative
  txtSize.SetFocus
  
End

' Public Sub chkUnderline_Click()
' 
'   Underline = chkUnderline.Value
'   RefreshExample
' 
' End
' 
' 
' Public Sub chkStrikeout_Click()
' 
'   Strikeout = chkStrikeout.Value
'   RefreshExample
' 
' End

Public Sub SetShowLabel(bVisible As Boolean)
  
  ' lblFamily.Visible = bVisible
  ' lblSize.Visible = bVisible
  ' lblStyle.Visible = bVisible
  $bShowLabel = bVisible
  
End

Public Sub IsShowLabel() As Boolean
  
  Return $bShowLabel
  
End

Public Sub sldSize_Change()
  
  txtSize.Value = sldSize.Value
  
End

Public Sub panFont_Arrange()
  
  If (panFont.W - txtSize.W - sldSize.X) < 64 Then
    sldSize.Hide
  Else
    sldSize.Show
  Endif
  
End

Public Sub HasBorder() As Boolean
  
  Return panBorder.Border
  
End

Public Sub SetBorder(bBorder As Boolean)
  
  panBorder.Border = If(bBorder, Border.Plain, Border.None)
  
End

Public Sub btnUnderline_Click()
  
  Underline = btnUnderline.Value  
  RefreshExample
  
End

Public Sub btnStrikeout_Click()
  
  Strikeout = btnStrikeout.Value
  RefreshExample
  
End

Public Sub panBorder_BeforeArrange()
  
  If Not Me.Visible Then Return
  
  If panBorder.H < (Desktop.Scale * 32) Then
    
    If tvwFamily.Visible Then
      tvwFamily.Hide
      sepFamily.Hide
      sepToolbar.Hide
      cmbFamily.Show
      cmbFamily.Lower
      txtFilter.Hide
      RefreshFamily
    Endif
    
    If panBorder.H < (Desktop.Scale * 18) Then
      sepToolbar.Hide
      panExample.Hide
      sepExample.Hide
    Else
      panExample.Show
      sepExample.Show
      sepToolbar.Show
    Endif
    
  Else
    
    If cmbFamily.Visible Then
      cmbFamily.Hide
      panExample.Show
      sepExample.Show
      tvwFamily.Show
      sepFamily.Show
      sepToolbar.Show
      txtFilter.Show
      RefreshFamily
    Endif
    
  Endif
  
  RefreshExample
  
  Me.Proxy = If(txtFilter.Visible, txtFilter, cmbFamily)
  
End

Public Sub SetShowRelative(bRelative As Boolean)
  
  btnRelative.Visible = bRelative
  If Not bRelative Then btnRelative.Value = False
  
End

Public Sub GetShowRelative() As Boolean
  
  Return btnRelative.Visible
  
End

Public Sub tvwFamily_Activate()
  
  If tvwFamily.Current.Children Then Return
  GetParent()._Activate()
  
End

Public Sub SetShowFont(bShow As Boolean)
  
  If $bShowFont = bShow Then Return
  $bShowFont = bShow
  UpdateShowFont
  
End

Public Sub HasShowFont() As Boolean
  
  Return $bShowFont
  
End

Public Sub txtFilter_Filter()
  
  RefreshFamily
  
End

Public Sub txtFilter_KeyPress()
  
  Dim hGridView As Container
  Dim hScrollArea As Control
  
  If Key.Normal Then
    If Key.Code = Key.Down Or If Key.Code = Key.Up Then
      hGridView = tvwFamily.Children[0]
      hScrollArea = hGridView.Children[0]
      Object.Raise(hScrollArea, "KeyPress")
      Stop Event
    Else If Key.Code = Key.Return Or If Key.Code = Key.Enter Then
      If tvwFamily.Current.Children Then
        hGridView = tvwFamily.Children[0]
        hScrollArea = hGridView.Children[0]
        Object.Raise(hGridView, "KeyPress")
        Stop Event
      Else
        GetParent()._Activate()
      Endif
    Endif
  Endif

End

Public Sub tvwFamily_GotFocus()
  
  txtFilter.SetFocus
  
End

Public Sub Form_Show()

  $bNoRefresh = False
  panBorder_BeforeArrange

End
