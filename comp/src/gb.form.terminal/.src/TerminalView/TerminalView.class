' Gambas class file

Inherits UserControl

Export

Public Const _Properties As String = "*,Border=True,ScrollBar=True,Limit"
Public Const _DrawWith As String = "-"
Public Const _Group As String = "View"

Event Kill

Property Border As Boolean
Property ScrollBar As Boolean
Property Read Attr As TerminalAttr
Property Foreground As Integer
Property Read Column As Integer
Property Read Line As Integer
Property Limit As Integer
Property Read Screen As Rect
Property Type As String

Private $hPanel As Panel
Private $hView As ScrollArea
Private $aScreen As New TerminalScreen[2]
Private $hScreen As TerminalScreen

Private $hFont As Font
Private $LH As Integer
Private $iAscent As Integer
Private $CW As Integer

Private $bMouseDown As Boolean
Private $iLimit As Integer
Private $hCursorTimer As Timer
Private $bHideCursor As Boolean
Private $hMouseTimer As Timer
Private $hProcess As Process
Private $hFilter As TerminalFilter
Private $sType As String

Public Sub _new()
  
  Me.Font = Font["monospace"]

  $hPanel = New Panel(Me) 
  $hPanel.Arrangement = Arrange.Fill
  $hPanel.Border = Border.Plain

  $hView = New ScrollArea($hPanel) As "View"
  $hView.Border = False
  $hView.Focus = True
  $hView.Tracking = True
  $hView.Mouse = Mouse.Text
  $hView.Background = Color.Black
  $hView.Foreground = Color.White
  
  Me.Proxy = $hView
  
  Me.Type = "VT100"
  
  $aScreen[0] = New TerminalScreen As "TerminalScreen"
  $aScreen[1] = New TerminalScreen As "TerminalScreen"
  $hScreen = $aScreen[0]
  
  UpdateFont
  
End

Public Sub Clear()
  
  $hScreen.Clear()
  UpdateFont
  
End


Public Sub Refresh()

  'ClearCache
  $hView.Refresh

End

Public Sub _RefreshLine((Y) As Integer)

  Refresh

End

Public Sub _UpdateSize()

  Dim W, H As Integer

  W = $hView.ClientW
  If $hView.ScrollH <= $hView.ClientH Then W -= Style.ScrollbarSize + Style.ScrollbarSpacing
  W = Max(1, W \ $CW)
  
  H = Max(1, $hView.ClientH \ $LH)
  
  $hView.ResizeContents($hView.ClientW, Max(H, $hScreen.Lines.Count + 1) * $LH)

  '$hView.ScrollY = GetScrollY()
  
  If $hScreen.Resize(W, H) Then
    If $hProcess Then $hProcess.Term.Resize(W, H)
  Endif

  Refresh
  
End

Private Sub UpdateFont()

  Dim sText As String
  'Dim I As Integer
  
  $hFont = $hView.Font
  '$hFontBold = $hView.Font.Copy()
  '$hFontBold.Bold = True
  
  $LH = $hFont.Height + 1

  $iAscent = $hFont.Ascent
  sText = String$(4, "AbCdEfGh01#@WwmM")
  $CW = Ceil($hFont.TextWidth(sText) / Len(sText))
  
  ' $hCacheFont = New Image($CW * 256, $LH, Color.Transparent)
  ' Paint.Begin($hCacheFont)
  ' Paint.Font = $hFont
  ' Paint.Background = $hView.Foreground
  ' For I = 32 To 255
  '   Paint.DrawText(String.Chr(I), I * $CW, $iAscent)
  ' Next
  ' Paint.End
  
  _UpdateSize

End

Public Sub View_Font()
  
  UpdateFont
  
End


Public Sub View_Resize()
  
  _UpdateSize
  
End

Private Sub GetScrollY() As Integer
  
  Return ($hView.ScrollY \ $LH) * $LH
  
End


Public Sub View_Draw()

  ApplyLimit
  $hScreen.Paint($hView.ScrollY, $LH, $CW, $iAscent, $bHideCursor)
  
End

Public Sub Goto(X As Integer, Y As Integer)

  $hScreen.Goto(X, Y)
  
End


Private Function Border_Read() As Boolean

  Return $hPanel.Border <> Border.None

End

Private Sub Border_Write(Value As Boolean)

  $hPanel.Border = If(Value, Border.Plain, Border.None)

End

Private Function ScrollBar_Read() As Boolean

  Return $hView.ScrollBar

End

Private Sub ScrollBar_Write(Value As Boolean)

  $hView.ScrollBar = If(Value, Scroll.Vertical, Scroll.None)

End

Private Function Attr_Read() As TerminalAttr

  Return $hScreen.Attr

End

Private Sub EnsureVisibleAt(X As Integer, Y As Integer)
  
  $hScreen.GetLine(Y)
  $hView.EnsureVisible(X * $CW, Y * $LH + $LH - 1, $CW, $LH)
  
End


Public Sub EnsureVisible()

  EnsureVisibleAt($hScreen.X, $hScreen.Y)
  
End

Private Function Foreground_Read() As Integer

  Return Super.Foreground

End

Private Sub Foreground_Write(Value As Integer)

  Super.Foreground = Value
  UpdateFont

End

Private Sub GotoMouse(bStart As Boolean)

  Dim X As Integer
  Dim Y As Integer

  X = (Mouse.ScreenX - $hView.ScreenX) \ $CW
  Y = (Mouse.ScreenY - $hView.ScreenY + GetScrollY()) \ $LH

  $hScreen.GotoMouse(X, Y, bStart)

  Refresh
  EnsureVisibleAt(X, Y)

End

Public Sub View_MouseDown()
  
  $bMouseDown = True
  GotoMouse(True)
  $hMouseTimer = New Timer(50) As "MouseTimer"
  
End

Public Sub View_MouseMove()
  
  If $bMouseDown Then 
    GotoMouse(False)
  Endif
  
End

Public Sub View_MouseUp()
  
  If $hMouseTimer Then
    $hMouseTimer.Stop
    $hMouseTimer = Null
  Endif
  $bMouseDown = False
  
End

Public Sub View_KeyPress()
  
  'If Key.Text Then $hScreen.Print(Replace(Key.Text, "\r", "\n"))
  If Not $hProcess Then Return
  If $hFilter.InputTo(Me, $hProcess, Key.Code, Key.Text) Then 
    Stop Event
  Endif
  
End


Private Function Column_Read() As Integer

  Return $hScreen.Column

End

Private Function Line_Read() As Integer

  Return $hScreen.Line

End

Private Sub ApplyLimit()

  If $iLimit <= ($hView.ClientH \ $LH) Then Return

  $hScreen.ApplyLimit($iLimit)

End

Private Function Limit_Read() As Integer

  Return $iLimit

End

Private Sub Limit_Write(Value As Integer)

  $iLimit = Value
  ApplyLimit

End

Public Sub View_GotFocus()
  
  $hCursorTimer = New Timer(500) As "CursorTimer"
  
End

Public Sub View_LostFocus()
  
  $hCursorTimer.Stop
  $hCursorTimer = Null
  $bHideCursor = False
  
End

Public Sub _ShowCursor()
  
  $bHideCursor = False
  
End


Public Sub CursorTimer_Timer()
  
  $bHideCursor = Not $bHideCursor
  _RefreshLine($hScreen.Y)
  
End

Public Sub MouseTimer_Timer()
  
  GotoMouse(False)
  
End

Private Function Screen_Read() As Rect

  Return $hScreen.Geometry

End

Private Function Type_Read() As String

  Return $sType

End

Private Sub Type_Write(Value As String)

  Try $hFilter = Object.New("TerminalFilter_" & Value)
  If Error Then Error.Raise("Unknown terminal type: " & Value)
  $sType = UCase(Value)

End

' Running a command

Public Sub Exec(aCommand As String[]) As Process

  If $hProcess Then Return
  
  $hProcess = Exec aCommand With ["TERM=xterm"] For Input Output As "Process"
  $hProcess.Term.Echo = True
  $hProcess.Term.Resize($hScreen.Width, $hScreen.Height)
  
End

Public Sub Shell(sCommand As String) As Process

  If $hProcess Then Return
  
  $hProcess = Shell sCommand With ["TERM=xterm"] For Input Output As "Process"
  $hProcess.Term.Echo = True
  $hProcess.Term.Resize($hScreen.Width, $hScreen.Height)
  
End

Public Sub Process_Kill()
  
  $hProcess = Null
  Raise Kill
  
End

Public Sub Process_Read()
  
  Dim sData As String
  
  sData = Read #$hProcess, Lof($hProcess)
  $hFilter.OutputTo(Me, sData)
  EnsureVisible
  
End

Public Sub _GetCurrentScreen() As TerminalScreen
  
  Return $hScreen
  
End
