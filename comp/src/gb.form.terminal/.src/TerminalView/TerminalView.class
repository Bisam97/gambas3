' Gambas class file

Inherits UserControl

Export

Public Const _Properties As String = "*,Border=True,Limit"
Public Const _DrawWith As String = "-"
Public Const _Group As String = "View"

Event Kill

Property Border As Boolean
Property Read Attr As TerminalAttr
Property Foreground As Integer
Property Read Column As Integer
Property Read Line As Integer
Property Limit As Integer
Property Type As String
Property Screen As Integer

Private $hPanel As Panel
Private $hView As DrawingArea
Private $hScroll As ScrollBar

Private $aScreen As New TerminalScreen[2]
Private $hScreen As TerminalScreen

Private $LH As Integer
Private $iAscent As Integer
Private $CW As Float

Private $bMouseDown As Boolean
Private $iLimit As Integer
Private $bHideCursor As Boolean
Private $hMouseTimer As Timer

Private $hProcess As Process

Private $hFilter As TerminalFilter
Public _DisableFilter As Integer

Private $sType As String

Private $hCursorTimer As Timer

Public Sub _new()
  
  Me.Font = Font["monospace"]

  $hPanel = New Panel(Me) 
  $hPanel.Arrangement = Arrange.Fill
  $hPanel.Border = Border.Plain

  $hView = New DrawingArea($hPanel) As "View"
  $hView.Border = False
  $hView.Focus = True
  $hView.Tracking = True
  $hView.Mouse = Mouse.Text
  $hView.Background = Color.Black
  $hView.Foreground = Color.White
  
  $hScroll = New ScrollBar($hView) As "ScrollBar"
  $hScroll.Ignore = True
  $hScroll.Mouse = Mouse.Arrow
  $hScroll.Hide
  
  Me.Proxy = $hView
  
  Me.Type = "VT100"
  
  $aScreen[0] = New TerminalScreen As "TerminalScreen"
  $aScreen[1] = New TerminalScreen As "TerminalScreen"
  $hScreen = $aScreen[0]
  
  UpdateFont
  
End

Public Sub Clear()
  
  $hScreen.Clear()
  UpdateFont
  
End

Public Sub Refresh()

  $hView.Refresh

End

Public Sub _RefreshLine((Y) As Integer)

  $hView.Refresh(0, (Y - GetScrollY()) * $LH, $hView.ClientW, $LH)

End

Public Sub _UpdateSize()

  Dim W, H As Integer

  'W = $hView.ClientW
  'If $hView.ScrollH <= $hView.ClientH Then W -= Style.ScrollbarSize + Style.ScrollbarSpacing
  W = Max(1, CInt($hView.ClientW / $CW))
  H = Max(1, $hView.ClientH \ $LH)
  
  '$hView.ResizeContents($hView.ClientW, Max(H, $hScreen.Lines.Count) * $LH + $hView.ClientH Mod $LH)
  $hScroll.MinValue = 0
  $hScroll.MaxValue = Max(0, $hScreen.Lines.Count - H)
  
  If $hScreen.Resize(W, H) Then
    'Debug W;; H
    If $hProcess Then $hProcess.Term.Resize(W, H)
  Endif

  Refresh
  
End

Private Sub UpdateFont()

  Dim sText As String
  
  'Dim I As Integer
  
  '$hFont = $hView.Font
  '$hFontBold = $hView.Font.Copy()
  '$hFontBold.Bold = True
  
  With $hView.Font
  
    $LH = .Height + 1
    $iAscent = .Ascent
    sText = String$(4, "AbCdEfGh01#@WwmM")
    $CW = .TextWidth(sText) / Len(sText)
    Debug $CW
    
  End With
  
  ' $hCacheFont = New Image($CW * 256, $LH, Color.Transparent)
  ' Paint.Begin($hCacheFont)
  ' Paint.Font = $hFont
  ' Paint.Background = $hView.Foreground
  ' For I = 32 To 255
  '   Paint.DrawText(String.Chr(I), I * $CW, $iAscent)
  ' Next
  ' Paint.End
  
  _UpdateSize

End

Public Sub View_Font()
  
  UpdateFont
  
End


Public Sub View_Arrange()
  
  $hScroll.Move($hView.ClientW - Style.ScrollbarSize, 0, Style.ScrollbarSize, $hView.ClientH)
  _UpdateSize
  
End

Private Sub GetScrollY() As Integer
  
  Return $hScroll.Value
  
End


Public Sub View_Draw()

  ApplyLimit
  $hScreen.Paint(GetScrollY() * $LH, $LH, $CW, $iAscent, $bHideCursor)
  
End

Public Sub Goto(X As Integer, Y As Integer)

  $hScreen.Goto(X, Y)
  
End


Private Function Border_Read() As Boolean

  Return $hPanel.Border <> Border.None

End

Private Sub Border_Write(Value As Boolean)

  $hPanel.Border = If(Value, Border.Plain, Border.None)

End

Private Function Attr_Read() As TerminalAttr

  Return $hScreen.Attr

End

Private Sub EnsureVisibleAt((X) As Integer, Y As Integer)
  
  Dim PH, CY, CH As Integer
  Dim YY, HH As Float
  Dim H As Integer
  
  Y = Y * $LH + $LH - 1
  H = $LH
  
  HH = H / 2
  YY = Y + HH

  PH = $hView.ClientH

  CY = - $hScroll.Value
  CH = $hScroll.MaxValue

  If PH < (HH * 2) Then HH = PH / 2

  If CH <= PH Then
    HH = 0
    CY = 0
  Endif

  If YY < (- CY + HH) Then
    CY = Ceil(- YY + HH)
  Else If YY >= (- CY + PH - HH) Then
    CY = Floor(- YY + PH - HH)
  Endif

  If CY > 0 Then
    CY = 0
  Else If CY < (PH - CH) And If CH > PH Then
    CY = PH - CH
  Endif

  CY = (- CY)
  If $hScroll.Value <> CY Then $hScroll.Value = CY
  
End


Public Sub EnsureVisible()

  EnsureVisibleAt($hScreen.X, $hScreen.Y)
  
End

Private Function Foreground_Read() As Integer

  Return Super.Foreground

End

Private Sub Foreground_Write(Value As Integer)

  Super.Foreground = Value
  UpdateFont

End

Private Sub GotoMouse(bStart As Boolean)

  Dim X As Integer
  Dim Y As Integer

  X = CInt((Mouse.ScreenX - $hView.ScreenX) / $CW)
  Y = GetScrollY() + (Mouse.ScreenY - $hView.ScreenY) \ $LH

  $hScreen.GotoMouse(X, Y, bStart)

  Refresh
  EnsureVisibleAt(X, Y)

End

Public Sub View_MouseDown()
  
  $bMouseDown = True
  GotoMouse(True)
  $hMouseTimer = New Timer(50) As "MouseTimer"
  
End

Public Sub View_MouseMove()
  
  If $bMouseDown Then 
    GotoMouse(False)
  Else
    If Mouse.X >= ($hView.ClientW - Style.ScrollbarSize) And If $hScroll.MaxValue Then
      $hScroll.Raise
      $hScroll.Show
    Else
      $hScroll.Hide
    Endif
  Endif
  
End

Public Sub View_MouseUp()
  
  If $hMouseTimer Then
    $hMouseTimer.Stop
    $hMouseTimer = Null
  Endif
  $bMouseDown = False
  
End

Public Sub View_KeyPress()
  
  'If Key.Text Then $hScreen.Print(Replace(Key.Text, "\r", "\n"))
  If Not $hProcess Then Return
  If $hFilter.InputTo(Me, $hProcess, Key.Code, Key.Text) Then 
    Stop Event
  Endif
  
End


Private Function Column_Read() As Integer

  Return $hScreen.Column

End

Private Function Line_Read() As Integer

  Return $hScreen.Line

End

Private Sub ApplyLimit()

  If $iLimit <= ($hView.ClientH \ $LH) Then Return

  $hScreen.ApplyLimit($iLimit)

End

Private Function Limit_Read() As Integer

  Return $iLimit

End

Private Sub Limit_Write(Value As Integer)

  $iLimit = Value
  ApplyLimit

End

Public Sub View_GotFocus()
  
  $hCursorTimer = New Timer(500) As "CursorTimer"
  
End

Public Sub View_LostFocus()
  
  $hCursorTimer.Stop
  $hCursorTimer = Null
  $bHideCursor = False
  
End

Public Sub _ShowCursor()
  
  $bHideCursor = False
  
End


Public Sub CursorTimer_Timer()
  
  $bHideCursor = Not $bHideCursor
  _RefreshLine($hScreen.Y)
  
End

Public Sub MouseTimer_Timer()
  
  GotoMouse(False)
  
End

Private Function Type_Read() As String

  Return $sType

End

Private Sub Type_Write(Value As String)

  Try $hFilter = Object.New("TerminalFilter_" & Value)
  If Error Then Error.Raise("Unknown terminal type: " & Value)
  $sType = UCase(Value)

End

' Running a command

Public Sub Exec(aCommand As String[]) As Process

  If $hProcess Then Return
  
  $hProcess = Exec aCommand With ["TERM=xterm"] For Input Output As "Process"
  $hProcess.Term.Echo = True
  $hProcess.Term.Resize($hScreen.Width, $hScreen.Height)
  
End

Public Sub Shell(sCommand As String) As Process

  If $hProcess Then Return
  
  $hProcess = Shell sCommand With ["TERM=xterm"] For Input Output As "Process"
  $hProcess.Term.Echo = True
  $hProcess.Term.Resize($hScreen.Width, $hScreen.Height)
  
End

Public Sub Process_Kill()
  
  $hProcess = Null
  Raise Kill
  
End

Public Sub Process_Read()
  
  Dim sData As String
  
  sData = Read #$hProcess, Lof($hProcess)
  $hFilter.OutputTo(Me, sData)
  EnsureVisible
  
End

Public Sub _GetCurrentScreen() As TerminalScreen
  
  Return $hScreen
  
End

Private Function Screen_Read() As Integer

  If $hScreen = $aScreen[1] Then Return 1

End

Private Sub Screen_Write(Value As Integer)

  If Value = 1 Then
    $hScreen = $aScreen[1]
  Else
    $hScreen = $aScreen[0]
  Endif
  
  _UpdateSize

End

Public Sub ScrollBar_Change()
  
  Refresh
  
End

