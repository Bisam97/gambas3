' Gambas class file

Event _Foo

Public Const DEBUG_FILTER As Boolean = False

Property Read Attr As TerminalAttr
Property Read Column As Integer
Property Read Line As Integer
Property Read Width As Integer
Property Read Height As Integer
Property Read Geometry As Rect
Property Read X As Integer
Property Read Y As Integer

Property Read HasMode As Boolean

Public AppCursorKey As Boolean
Public AppKeypad As Boolean
Public Origin As Boolean
Public InsertMode As Boolean
Public NewlineMode As Boolean
Public WrapMode As Boolean
Public HideCursor As Boolean


Static Private $aColor As Integer[] = [
&H000000, &H800000, &H008000, &H808000, &H000080, &H800080, &H008080, &Hc0c0c0,
&H808080, &Hff0000, &H00ff00, &Hffff00, &H0000ff, &Hff00ff, &H00ffff, &Hffffff,
&H000000, &H00005f, &H000087, &H0000af, &H0000d7, &H0000ff,
&H005f00, &H005f5f, &H005f87, &H005faf, &H005fd7, &H005fff,
&H008700, &H00875f, &H008787, &H0087af, &H0087d7, &H0087ff,
&H00af00, &H00af5f, &H00af87, &H00afaf, &H00afd7, &H00afff,
&H00d700, &H00d75f, &H00d787, &H00d7af, &H00d7d7, &H00d7ff,
&H00ff00, &H00ff5f, &H00ff87, &H00ffaf, &H00ffd7, &H00ffff,
&H5f0000, &H5f005f, &H5f0087, &H5f00af, &H5f00d7, &H5f00ff,
&H5f5f00, &H5f5f5f, &H5f5f87, &H5f5faf, &H5f5fd7, &H5f5fff,
&H5f8700, &H5f875f, &H5f8787, &H5f87af, &H5f87d7, &H5f87ff,
&H5faf00, &H5faf5f, &H5faf87, &H5fafaf, &H5fafd7, &H5fafff,
&H5fd700, &H5fd75f, &H5fd787, &H5fd7af, &H5fd7d7, &H5fd7ff,
&H5fff00, &H5fff5f, &H5fff87, &H5fffaf, &H5fffd7, &H5fffff,
&H870000, &H87005f, &H870087, &H8700af, &H8700d7, &H8700ff,
&H875f00, &H875f5f, &H875f87, &H875faf, &H875fd7, &H875fff,
&H878700, &H87875f, &H878787, &H8787af, &H8787d7, &H8787ff,
&H87af00, &H87af5f, &H87af87, &H87afaf, &H87afd7, &H87afff,
&H87d700, &H87d75f, &H87d787, &H87d7af, &H87d7d7, &H87d7ff,
&H87ff00, &H87ff5f, &H87ff87, &H87ffaf, &H87ffd7, &H87ffff,
&Haf0000, &Haf005f, &Haf0087, &Haf00af, &Haf00d7, &Haf00ff,
&Haf5f00, &Haf5f5f, &Haf5f87, &Haf5faf, &Haf5fd7, &Haf5fff,
&Haf8700, &Haf875f, &Haf8787, &Haf87af, &Haf87d7, &Haf87ff,
&Hafaf00, &Hafaf5f, &Hafaf87, &Hafafaf, &Hafafd7, &Hafafff,
&Hafd700, &Hafd75f, &Hafd787, &Hafd7af, &Hafd7d7, &Hafd7ff,
&Hafff00, &Hafff5f, &Hafff87, &Hafffaf, &Hafffd7, &Hafffff,
&Hd70000, &Hd7005f, &Hd70087, &Hd700af, &Hd700d7, &Hd700ff,
&Hd75f00, &Hd75f5f, &Hd75f87, &Hd75faf, &Hd75fd7, &Hd75fff,
&Hd78700, &Hd7875f, &Hd78787, &Hd787af, &Hd787d7, &Hd787ff,
&Hd7af00, &Hd7af5f, &Hd7af87, &Hd7afaf, &Hd7afd7, &Hd7afff,
&Hd7d700, &Hd7d75f, &Hd7d787, &Hd7d7af, &Hd7d7d7, &Hd7d7ff,
&Hd7ff00, &Hd7ff5f, &Hd7ff87, &Hd7ffaf, &Hd7ffd7, &Hd7ffff,
&Hff0000, &Hff005f, &Hff0087, &Hff00af, &Hff00d7, &Hff00ff,
&Hff5f00, &Hff5f5f, &Hff5f87, &Hff5faf, &Hff5fd7, &Hff5fff,
&Hff8700, &Hff875f, &Hff8787, &Hff87af, &Hff87d7, &Hff87ff,
&Hffaf00, &Hffaf5f, &Hffaf87, &Hffafaf, &Hffafd7, &Hffafff,
&Hffd700, &Hffd75f, &Hffd787, &Hffd7af, &Hffd7d7, &Hffd7ff,
&Hffff00, &Hffff5f, &Hffff87, &Hffffaf, &Hffffd7, &Hffffff,
&H080808, &H121212, &H1c1c1c, &H262626, &H303030, &H3a3a3a,
&H444444, &H4e4e4e, &H585858, &H606060, &H666666, &H767676,
&H808080, &H8a8a8a, &H949494, &H9e9e9e, &Ha8a8a8, &Hb2b2b2,
&Hbcbcbc, &Hc6c6c6, &Hd0d0d0, &Hdadada, &He4e4e4, &Heeeeee]

Static Private $sControlChar As String

Public Lines As New CTerminalLine[]

' Screen size
Private $W As Integer
Private $H As Integer

' Cursor position
Private $X As Integer
Private $Y As Integer

' Saved cursor
Private $SX As Integer
Private $SY As Integer

' Current attributes
Private $hAttr As New TerminalAttr

' Selection
Private $X1 As Integer
Private $Y1 As Integer
Private $X2 As Integer
Private $Y2 As Integer

' Scroll area
Private $iScrollStart As Integer = -1
Private $iScrollEnd As Integer = -1

Private $hLineCache As Image
Private $cCharCache As New Collection

Public Sub _new()
  
  Dim I As Integer
  
  If Not $sControlChar Then
    For I = 0 To 31
      $sControlChar &= Chr$(I)
    Next
  Endif
  
  Reset
  
End

Private Sub GetView() As TerminalView

  Return Object.Parent(Me)

End

Public Sub Clear()
  
  Lines.Clear
  GetView()._UpdateSize
  
End

Public Sub Resize(W As Integer, H As Integer) As Boolean
  
  If W <> $W Or If H <> $H Then
    $W = W
    $H = H
    $X = Min($X, $W - 1)
    $Y = ScreenTop() + Max(0, Min($Y - ScreenTop(), $H - 1))
    $iScrollStart = -1
    $iScrollEnd = -1
    If GetView().AlternateScreen Then
      If Lines.Count > $H Then
        Lines.Resize($H)
        GetView()._UpdateSize
      Endif
    Endif
    $hLineCache = Null
    Return True
  Endif
  
End

Public Sub GetLine(Y As Integer) As CTerminalLine

  Dim hLine As CTerminalLine
  
  If Y > Lines.Max Then
    Lines.Resize(Y + 1)
    GetView()._UpdateSize()
  Endif
  hLine = Lines[Y]
  If Not hLine Then 
    hLine = New CTerminalLine
    Lines[Y] = hLine
  Endif
  
  Return hLine

End

Private Sub ClearLine(Y As Integer)
  
  Dim hLine As CTerminalLine
  
  If Y > Lines.Max Then Return
  hLine = Lines[Y]
  If Not hLine Then Return
  
  hLine.Clear()
  
End


Private Sub Insert(sText As String, Optional X As Integer = $X)

  Dim hLine As CTerminalLine
  Dim iLen As Integer = String.Len(sText)
  
  If iLen = 0 Then Return
  
  If (X + iLen) > $W Then
    iLen = Max(0, $W - X)
    If iLen Then
      Insert(String.Left(sText, iLen))
      sText = String.Mid$(sText, iLen + 1) 
    Endif
    If WrapMode Then
      NewLine()
      $X = 0
      Insert(sText)
    Endif
    Return
  Endif
  
  hLine = GetLine($Y)
  
  If hLine.Length < X Then 
    hLine.Text &= Space$(X - hLine.Length) & sText & String.Mid(hLine.Text, X + iLen)
    hLine.Length = String.Len(hLine.Text)
    hLine.SetAttr($hAttr, X, iLen)
  Else
    If InsertMode Then
      hLine.Text = String.Left(String.Left(hLine.Text, X) & sText & String.Mid(hLine.Text, X + 1), $W)
      hLine.Length = String.Len(hLine.Text)
      hLine.SetAttr($hAttr, X, iLen, True)
    Else
      hLine.Text = String.Left(hLine.Text, X) & sText & String.Mid(hLine.Text, X + iLen + 1)
      hLine.Length = String.Len(hLine.Text)
      hLine.SetAttr($hAttr, X, iLen)
    Endif
  Endif
  
  GetView()._RefreshLine($Y)
  
  If IsMissing(X) Then $X += iLen
  
End

Public Sub Print(sText As String)

  Dim aText As String[]
  Dim sElt As String
  Dim iLen As Integer
  Dim iCode As Integer
  
  aText = Split(sText, $sControlChar)
  
  For Each sElt In aText
    
    If sElt Then 
      
      If DEBUG_FILTER Then
        Debug Quote(sElt)
        DebugRefresh
      Endif
      
      Insert(sElt)
      
    Endif
    
    iLen += Len(sElt)
    If iLen >= Len(sText) Then Break
    iCode = Asc(sText, iLen + 1)
    
    If DEBUG_FILTER Then
      Debug "^" & Chr$(64 + iCode)
      DebugRefresh
    Endif
    
    Select Case iCode
      Case 7
      Case 8
        CursorLeft
      Case 9
        Tab()
      Case 10, 12
        Goto(0, $Y)
        NewLine()
      ' Case 12
      '   EraseScreen()
      Case 13
        Goto(0, $Y)
      Case Else
        Insert("^" & Chr$(64 + iCode))
    End Select
    Inc iLen
  Next
  
End


Private Sub NewLine()
  
  If NewlineMode Then $X = 0
  Index()
  
End

Private Sub Tab()
  
  Goto($X + 8 - $X Mod 8, $Y)
  
End

Public Sub Goto(X As Integer, Y As Integer)
  
  If X >= $W Then
    X = 0
    Inc Y
  Else If X < 0 Then
    X = $W - 1
    Dec Y
  Endif
  
  If Y < 0 Then Y = 0
  
  With GetView()
  
    ._RefreshLine($Y)
  
    $X = X
    $Y = Y
  
    ._ShowCursor()
    ._RefreshLine($Y)
    .EnsureVisible
    
  End With
  
End


' Private Sub EnsureVisibleAt(X As Integer, Y As Integer)
'   
'   GetLine(Y)
'   GetView().EnsureVisible(X * $CW, Y * $LH, $CW, $LH)
'   
' End
' 
' 
' Public Sub EnsureVisible()
' 
'   EnsureVisibleAt($X, $Y)  
'   
' End

Private Function Column_Read() As Integer

  Return $X

End

Private Function Line_Read() As Integer

  Return Max(0, $Y - ScreenTop())

End

Public Sub ApplyLimit(iLimit As Integer)

  Dim iDel As Integer
  
  iDel = Lines.Count - iLimit
  If iDel <= 0 Then Return
  
  Lines.Remove(0, iDel)
  $Y = Max(0, $Y - iDel)
  
  GetView()._UpdateSize()
  
End

Private Sub ScreenTop() As Integer
  
  Return Max(0, Lines.Count - $H)
  
End

' Terminal VT100 commands

Public Sub CursorGoto(X As Integer, Y As Integer)
  
  ' If X >= $W Then
  '   X = 0
  '   Inc Y
  ' Else If X < 0 Then
  '   X = $W - 1
  '   Dec Y
  ' Endif
  
  If X < 0 Then
    X = 0
  Else If X >= $W
    X = $W - 1
  Endif
  
  If Y < 0 Then
    Y = 0
  Else If Y >= $H
    Y = $H - 1
  Endif
  
  With GetView()
  
    ._RefreshLine($Y)
  
    $X = X
    $Y = Y + ScreenTop()
  
    ._ShowCursor()
    ._RefreshLine($Y)
    .EnsureVisible
    
  End With
  
End

Public Sub CursorUp(Optional Count As Integer = 1)
  
  CursorGoto($X, Me.Line - Count)
  
End

Public Sub CursorDown(Optional Count As Integer = 1)
  
  CursorGoto($X, Me.Line + Count)
  
End

Public Sub CursorLeft(Optional Count As Integer = 1)
  
  CursorGoto($X - Count, $Y)
  
End

Public Sub CursorRight(Optional Count As Integer = 1)
  
  CursorGoto($X + Count, $Y)
  
End

Public Sub DeleteChar(Optional N As Integer = 1)

  Dim hLine As CTerminalLine
  
  hLine = GetLine($Y)
  If $X < hLine.Length Then 
    hLine.Text = String.Left(hLine.Text, $X) & String.Mid$(hLine.Text, $X + N + 1)
    hLine.Length = String.Len(hLine.Text)
  Endif
  If Not $hAttr.IsVoid() Then
    Insert(Space$(N), hLine.Length)
  Endif
  
End

Public Sub EraseEndOfLine()

  Dim hLine As CTerminalLine

  hLine = GetLine($Y)
  If hLine.Length <= $X Then 
    If $hAttr.IsVoid() Then Return
    hLine.Text &= Space($X - hLine.Length)
  Else
    hLine.Text = String.Left(hLine.Text, $X)
  Endif
  hLine.Length = $X
  If Not $hAttr.IsVoid() Then Insert(Space$($W - $X), $X)
  GetView()._RefreshLine($Y)

End

Public Sub EraseStartOfLine()

  Dim hLine As CTerminalLine

  hLine = GetLine($Y)
  If hLine.Length <= $X Then
    hLine.Clear()
    GetView()._RefreshLine($Y)
  Else
    hLine.Text = Space$($X + 1) & String.Mid$(hLine.Text, $X + 1)
  Endif
  GetView()._RefreshLine($Y)

End

Public Sub EraseLine()

  Dim hLine As CTerminalLine

  hLine = GetLine($Y)
  If $hAttr.IsVoid() Then
    hLine.Clear()
  Else
    Insert(Space$($W), 0)
  Endif
  
  GetView()._RefreshLine($Y)

End

Public Sub EraseScreen()

  Dim Y As Integer
  
  For Y = ScreenTop() To Lines.Max
    ClearLine(Y)
  Next
  
  CursorGoto(0, 0)
  GetView().Refresh
  
End

Public Sub EraseDown()
  
  Dim Y As Integer
  
  EraseEndOfLine
  
  For Y = Max(ScreenTop(), $Y + 1) To Lines.Max
    ClearLine(Y)
  Next
  
  GetView().Refresh
  
End


Public Sub EraseUp()

  Dim Y As Integer
  
  EraseStartOfLine
  
  For Y = ScreenTop() To Max(ScreenTop() - 1, $Y + 1)
    ClearLine(Y)
  Next
  
  GetView().Refresh
  
End

Public Sub ScrollScreen(Optional Start As Integer, {End} As Integer)
  
  If IsMissing(Start) Or IsMissing({End}) Then
    $iScrollStart = -1
    $iScrollEnd = -1
  Else
    $iScrollStart = Start
    $iScrollEnd = {End}
  Endif
  
End

Private Sub GetScreen(ByRef Y1 As Integer, ByRef Y2 As Integer)
  
  If $iScrollStart < 0 Or $iScrollEnd < 0 Then
    Y1 = ScreenTop()
    Y2 = Y1 + $H - 1
  Else
    Y1 = Max(ScreenTop(), $iScrollStart)
    Y2 = Min(ScreenTop() + $H - 1, $iScrollEnd)
  Endif
  
End


Private Sub Scroll(bUp As Boolean, Optional iFrom As Integer)

  Dim hView As TerminalView = GetView()
  Dim Y1, Y2 As Integer
  
  GetScreen(ByRef Y1, ByRef Y2)
  If Not IsMissing(iFrom) Then Y1 = iFrom
  
  If bUp Then
    If $iScrollStart >= 0 Or If hView.AlternateScreen Then
      Try Lines.Remove(Y1)
      Try Lines.Add(Null, Y2)
    Else
      Lines.Add(Null)
      Inc $Y
      hView._UpdateSize()
      hView.EnsureVisible
    Endif
  Else
    Try Lines.Remove(Y2)
    Try Lines.Add(Null, Y1)
  Endif
  
  GetView().Refresh
  
End

Public Sub ScrollUp(Optional N As Integer)
  
  Repeat
    Scroll(True)
    Dec N
  Until N <= 0
  
End

Public Sub ScrollDown(Optional N As Integer)
  
  Repeat
    Scroll(False)
    Dec N
  Until N <= 0
  
End

Public Sub InsertLine(N As Integer)

  While N > 0  
    Scroll(False, $Y)
    Dec N
  Wend
  
End

Public Sub DeleteLine(N As Integer)

  While N > 0  
    Scroll(True, $Y)
    Dec N
  Wend
  
End

Public Sub Index()
  
  Dim Y1, Y2 As Integer

  GetScreen(ByRef Y1, ByRef Y2)

  If $Y >= Y2 Then
    ScrollUp
  Else
    CursorDown
  Endif
  
End

Public Sub ReverseIndex()
  
  Dim Y1, Y2 As Integer

  GetScreen(ByRef Y1, ByRef Y2)

  If $Y <= Y1 Then
    ScrollDown
  Else
    CursorUp
  Endif
  
End


Private Function Attr_Read() As TerminalAttr

  Return $hAttr

End

Private Function Geometry_Read() As Rect

  Return Rect(0, ScreenTop(), $W, $H)

End

Private Function Width_Read() As Integer

  Return $W

End

Private Function Height_Read() As Integer

  Return $H

End

Private Sub DrawLine(L As Integer, X As Float, Y As Integer, LH As Integer, CW As Float, (LA) As Integer, hFontCache As Image)

  Dim hView As TerminalView = GetView()
  Dim hLine As CTerminalLine
  Dim I As Integer
  'Dim sText As String
  Dim aAttr As Integer[]
  Dim hAttr As New TerminalAttr
  Dim iFg As Integer = hView.Foreground
  Dim iBg As Integer = hView.Background
  'Dim hRect As Rect
  Dim P, iLen As Integer
  Dim XT As Integer
  Dim J As Integer
  Dim C As Integer
  Dim hFont As Font
  Dim HC As Integer
  Dim hRect As Rect
  Dim W As Integer
  Dim YC As Integer
  Dim XC As Integer

  hLine = Lines[L]
  If Not hLine Then Return
  
  hFont = Paint.Font
  aAttr = hLine.GetAttr()
  
  P = 1
  
  For I = 0 To aAttr.Max
  
    If P > hLine.Length Then Break
  
    hAttr.FillFrom(aAttr[I])
    iLen = Min((Lsr(aAttr[I], 8) And 255), hLine.Length - P) + 1
  
    iBg = hAttr.Background
    If iBg >= 0 Then
      iBg = $aColor[iBg]
    Else
      iBg = hView.Background
    Endif
    
    iFg = hAttr.Foreground
    If iFg >= 0 Then
      'Debug iFg
      iFg = $aColor[iFg]
    Else
      iFg = hView.Foreground
    Endif
    
    If hAttr.Reverse Then Swap iBg, iFg
    
    If hAttr.Blink Then
      hView._HasBlink = True
      If hView._Blink Then Swap iBg, iFg      
    Endif
    
    If hAttr.Dim Then iFg = Color.Merge(iFg, hView.Background)
    
    Paint.Background = Color.White
    
    If hAttr.Bold Then
      HC = LH
    Else
      HC = 0
    Endif
      
    GoSub DRAW_TEXT
    
  Next
  
  If P <= hLine.Length Then
    iLen = hLine.Length - P + 1
    iFg = hView.Foreground
    iBg = hView.Background
    HC = 0
    hAttr.FillFrom(0)
    GoSub DRAW_TEXT
  Endif
    
  Return
  
DRAW_TEXT:

  If iLen <= 0 Then Return
  
  W = iLen * CW
  
  If hFontCache Then
  
    Paint.Begin($hLineCache)
    
    Paint.FillRect(0, 0, W, LH, iFg)
    
    XT = 0
    
    hRect = Rect(0, 0, CW, LH)
    
    Paint.Operator = Paint.OperatorDestATop
    For J = P To P + iLen - 1
      'sCar = String.Mid$(hLine.Text, J, 1)
      C = String.Code(hLine.Text, J)
      If C = 0 Then Stop
      If C <= 255 Then
        hRect.Move(C * CW, HC)
        Paint.DrawImage(hFontCache, XT, 0, CW, LH,, hRect)
      Else
        
        If $cCharCache.Exist(C) Then
          
          C = $cCharCache[C]
          hRect.Move(C * CW, 0)
          Paint.DrawImage(hFontCache, XT, 0, CW, LH,, hRect)
          
        Else
          
          If $cCharCache.Count < 32 Then
            XC = $cCharCache.Count * CW
            YC = 0
          Else
            XC = 0
            YC = LH
          Endif
          
          Paint.Begin(hFontCache)
          Paint.Operator = Paint.OperatorSource
          Paint.FillRect(XC, YC, CW, LH, Color.Transparent)
          Paint.Font = hFont
          Paint.DrawText(String.Chr$(C), XC, YC, CW, LH, Align.Center)
          If hAttr.Bold Then Paint.DrawText(String.Chr$(C), XC + 1, YC, CW, LH, Align.Center)
          Paint.End
          hRect.Move(XC, YC)
          Paint.DrawImage(hFontCache, XT, 0, CW, LH,, hRect)
          
          If YC = 0 Then $cCharCache[C] = $cCharCache.Count
          
        Endif
      Endif
      XT += CW
    Next
    
    Paint.End
    
    XT = X
    
    Paint.FillRect(XT, Y, W, LH, iBg)
    Paint.DrawImage($hLineCache, XT, Y, W, LH,, Rect(0, 0, W, LH))
    
  Else
    
    XT = X
    
    Paint.FillRect(XT, Y, W, LH, iBg)
    Paint.Background = iFg
    Paint.DrawText(String.Mid$(hLine.Text, P, iLen), XT, Y + LA)
    If hAttr.Bold Then Paint.DrawText(String.Mid$(hLine.Text, P, iLen), XT + 1, Y + LA)
    
  Endif
  
  If hAttr.Underscore Then Paint.FillRect(XT, Y + LH - 1, W, 1, Color.SetAlpha(iFg, 64))
  
  X += W
  P += iLen
  Return

End

Private Sub GetSelection(ByRef X1 As Integer, ByRef Y1 As Integer, ByRef X2 As Integer, ByRef Y2 As Integer) As Boolean

  Y1 = $Y1
  Y2 = $Y2
  X1 = $X1
  X2 = $X2
  
  If Y1 > Y2 Then
    Swap Y1, Y2
    Swap X1, X2
  Endif

  If Y2 > Y1 Or If X2 > X1 Then Return True
  
End

Public Sub Paint(SY As Integer, LH As Integer, CW As Float, LA As Integer, bHideCursor As Boolean, hFont As Image)

  Dim hView As TerminalView = GetView()
  Dim L, L1, L2 As Integer
  Dim Y As Integer
  Dim X1 As Integer
  Dim X2 As Integer
  Dim Y1 As Integer
  Dim Y2 As Integer

  If Not $hLineCache Then $hLineCache = New Image($W * CW, LH)
  $cCharCache.Clear

  L1 = (SY + Paint.ClipRect.Y) \ LH
  L2 = (SY + Paint.ClipRect.Y + Paint.ClipRect.H - 1) \ LH

  'Debug L1;; L2
  
  Y = L1 * LH - SY + SY Mod LH
  
  For L = L1 To L2
    
    If L < Lines.Count Then DrawLine(L, 0, Y, LH, CW, LA, hFont)

    ' Cursor

    If L = $Y And If Not bHideCursor And If Not HideCursor Then
      Paint.FillRect($X * CW, Y, CW, LH, Color.SetAlpha(Color.Merge(Color.SelectedBackground, hView.Foreground), 64))
    Endif
    
    ' Selection
    
    If GetSelection(ByRef X1, ByRef Y1, ByRef X2, ByRef Y2) Then
    
      If L >= Y1 And If L <= Y2 Then
        If L = Y1 Then
          X1 *= CW
        Else
          X1 = 0
        Endif
        If L = Y2 Then
          X2 *= CW
        Else
          X2 = Paint.W
        Endif
        If X2 > X1 Then Paint.FillRect(X1, Y, X2 - X1, LH, Color.SetAlpha(Color.SelectedBackground, 128))
      Endif
      
    Endif
  
    Y += LH
      
  Next
  
End


Private Function X_Read() As Integer

  Return $X

End

Private Function Y_Read() As Integer

  Return $Y

End

Public Sub GotoMouse(X As Integer, Y As Integer, bStart As Boolean)

  X = Max(0, Min($W - 1, X))
  Y = Max(0, Min(Max(Lines.Max, $H - 1), Y))
  
  If bStart Then
    $X1 = X
    $Y1 = Y
  Endif
  $X2 = X
  $Y2 = Y
  
  If Not bStart Then
    With GetView()
      .Refresh
      ._EnsureVisibleAt(X, Y)
    End With
  Endif

End

Public Sub SaveCursor()
  
  $SX = $X
  $SY = $Y
  
End

Public Sub RestoreCursor()
  
  Goto($SX, $SY)
  
End

Public Sub Reset()

  $X = 0
  $Y = 0
  $iScrollStart = -1
  $iScrollEnd = -1
  $hAttr.Reset
  
  AppCursorKey = False
  AppKeypad = False
  Origin = False
  InsertMode = False
  NewlineMode = False
  WrapMode = True
  HideCursor = False
  
End

Public Sub DebugRefresh()
  
  If DEBUG_FILTER Then
    GetView().Refresh
    Inc GetView()._DisableFilter
    Wait
    Dec GetView()._DisableFilter
    'Stop
  Endif
  
End


Private Function HasMode_Read() As Boolean

  If AppCursorKey Or If AppKeypad Or If Origin Or If InsertMode Or If NewlineMode Or If WrapMode Or If HideCursor Then Return True

End

Public Sub GetSelectedText() As String
  
  Dim X1 As Integer
  Dim X2 As Integer
  Dim Y1 As Integer
  Dim Y2 As Integer
  Dim sText As String
  Dim Y As Integer
  
  If Not GetSelection(ByRef X1, ByRef Y1, ByRef X2, ByRef Y2) Then Return
  
  If Y2 = Y1 Then
    sText = String.Mid$(Lines[Y1].Text, X1 + 1, X2 - X1)
  Else
    sText = String.Mid$(Lines[Y1].Text, X1 + 1) & "\n"
    For Y = Y1 + 1 To Y2 - 1
      sText &= Lines[Y].Text & "\n"
    Next
    sText &= String.Left$(Lines[Y2].Text, X2)
  Endif
  
  Return sText
  
End
