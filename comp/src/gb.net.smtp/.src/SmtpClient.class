' Gambas class file

Export

Static Private $aDay As String[] 
Static Private $aMonth As String[] 

Property Debug As Boolean

Property Host As String
Property Port As Integer
Property User As String
Property Password As String
Property Encrypt As Integer

Property From As String
Property Subject As String
Property Body As String

Property Read To As String[]
Property Read Cc As String[]
Property Read Bcc As String[]

Property Alternative As Boolean
Property Read Count As Integer

Public _NoGreeting As Boolean
Public _Stream As Stream

Private $bDebug As Boolean
Private $sHost As String
Private $iPort As Integer
Private $sUser As String
Private $sPassword As String

Private $sFrom As String
Private $sSubject As String
Private $sBody As String

Private $aTo As New String[]
Private $aCc As New String[]
Private $aBcc As New String[]

Private $aPart As New SmtpPart[]
Private $bAlternative As Boolean
Private $hSession As SmtpSession
Private $iEncrypt As Integer

Public Sub Add(Data As String, Optional MimeType As String, Name As String)
  
  Dim hPart As SmtpPart
  
  'If IsMissing(Name) Then Name = "Part #" & CStr($aPart.Count + 1)
  
  hPart = New SmtpPart(MimeType, Name)
  hPart.Data = Data
  
  $aPart.Add(hPart)
  
End

Private Function Debug_Read() As Boolean

  Return $bDebug

End

Private Sub Debug_Write(Value As Boolean)

  $bDebug = Value

End

Private Function Host_Read() As String

  Return $sHost

End

Private Sub Host_Write(Value As String)

  $sHost = Value

End

Private Function Port_Read() As Integer

  Return $iPort

End

Private Sub Port_Write(Value As Integer)

  $iPort = Value

End

Private Function User_Read() As String

  Return $sUser

End

Private Sub User_Write(Value As String)

  $sUser = Value

End

Private Function Password_Read() As String

  Return $sPassword

End

Private Sub Password_Write(Value As String)

  $sPassword = Value

End

Private Function From_Read() As String

  Return $sFrom

End

Private Sub From_Write(Value As String)

  $sFrom = Value

End

Private Function Subject_Read() As String

  Return $sSubject

End

Private Sub Subject_Write(Value As String)

  $sSubject = Value

End

Private Function Body_Read() As String

  Return $sBody

End

Private Sub Body_Write(Value As String)

  $sBody = Value

End

Private Function To_Read() As String[]

  Return $aTo

End

Private Function Cc_Read() As String[]

  Return $aCc

End

Private Function Bcc_Read() As String[]

  Return $aBcc

End

Private Function Alternative_Read() As Boolean

  Return $bAlternative

End

Private Sub Alternative_Write(Value As Boolean)

  $bAlternative = Value

End

Private Function Count_Read() As Integer

  Return $aPart.Count

End

Private Sub FormatAddress(sAdr As String) As String

  sAdr = Trim(sAdr)  
  If Not sAdr Then Return
  If sAdr Not Like "* <*>" Then Return "<" & sAdr & ">"
  Return sAdr

End

Private Sub ExtractAddress(sAdr As String) As String

  Dim iPos As Integer

  sAdr = Trim(sAdr)  
  If Not sAdr Then Return
  If sAdr Not Like "* <*>" Then Return "<" & sAdr & ">"
  iPos = InStr(sAdr, "<")
  Return Mid$(sAdr, iPos)

End

Private Sub BeginSession()

  Dim hPart As SmtpPart
  Dim bParent As Boolean

  Select Case $iEncrypt
    Case Net.None
      $hSession = New TcpSession
    Case Net.SSL
      $hSession = New SslSession
    Case Net.TLS
      $hSession = New TlsSession
    Case Else
      Error.Raise("Unknown encryption")
  End Select
  
  $hSession._Debug = $bDebug

  If $sBody Then
  
    hPart = New SmtpPart
    hPart.Data = $sBody
    $aPart.Add(hPart, 0)
  
  Endif

  If $aPart.Count > 1 Then
    
    hPart = New SmtpPart("multipart/" & If($bAlternative, "alternative", "mixed"), "Main part")
    $aPart.Add(hPart, 0)
    bParent = True
    
  Endif
  
'     
'     main_part->Tag = -1;
'     //parent = -1;
'     
'     for (i = 0; i < npart; i++)
'     {
'       p = &THIS->parts[i];
'       
'       parent_part = main_part;
'     
'       decode_mime(p->mime);
'     
'       if (!p->name_set)
'       {
'         sprintf(buffer, "MIME part #%d", i + 1);
'         name = buffer;
'       }
'       else if (!p->name)
'         name = "";
'       else
'         name = p->name;
'       
'       part = libsmtp_part_new(parent_part, _mime_type, _mime_subtype, _mime_encoding, _mime_charset, name, -1, THIS->session);
'       if (!part)
'       {
'         GB.Error("Cannot add part: &1", libsmtp_strerr(THIS->session));
'         return TRUE;    
'       }
'       
'       part->Tag = i;
'       #ifdef DEBUG_ME
'       fprintf(stderr, "part = %p  parent_part = %p  Tag = %d\n", part, parent_part, i);
'       #endif
'       p->part = part;
'     }
'   }
'   
'   return FALSE;
' }
' 

End

Private Sub EndSession()

  $hSession.Send("QUIT")
  $hSession.Disconnect

End

Private Sub GetDomainName() As String

  Dim sName As String
  
  sName = System.Domain
  If sName And If sName <> "(none)" Then
    sName &= "."
  Else
    sName = ""
  Endif
  
  Return sName & System.Host

End

Private Sub Connect()

  Dim sData As String
  
  $hSession.Connect($sHost, $iPort)
  
  If $iEncrypt <> Net.TLS Then
    ' greetings
    $hSession.GetLine()
  Endif
  
  sData = $hSession.Send("EHLO " & GetDomainName(), True)
  If $hSession.LastCode <> "250" Then Error.Raise("EHLO command failed")
  
Catch
  
  Error.Raise("Unable to connect to the SMTP server: " & Error.Text)
  
End

Private Sub Authenticate()
  
  Dim sData As String
  
  If Not $sUser Then Return
  
  ' int libsmtp_authenticate(struct libsmtp_session_struct *session, const char *user, const char *password)
  ' {
  '   GString *temp_gstring;  /* Temp gstring */
  '   int len_user = strlen(user);
  '   int len_password = strlen(password);
  '   int len_auth = strlen("auth plain ");
  '   char buffer[len_user + len_password + len_auth + 3];
  '   char *p;
  ' 
  '   temp_gstring = g_string_new (NULL);
  ' 
  '   /* We enter the auth stage now */
  '   session->Stage = LIBSMTP_AUTH_STAGE;
  ' 
  '   /* Send the AUTH PLAIN authentification */
  ' 
  '   p = buffer;
  '   strcpy(p, "auth plain "); p += len_auth;
  '   *p++ = 0;
  '   strcpy(p, user); p += len_user;
  '   *p++ = 0;
  '   strcpy(p, password); p += len_password;
  '   strcpy(p, "\r\n"); p += 2;
  ' 
  '   if (libsmtp_int_send_base64(buffer, p - buffer, session, len_auth))
  '     return LIBSMTP_ERRORSENDFATAL;
  ' 
  '   if (libsmtp_int_read(temp_gstring, session, 2))
  '     return LIBSMTP_ERRORSENDFATAL;
  ' 
  '   if (session->LastResponseCode != 235)
  '   {
  '     /* We couldn't authenticate */
  '     libsmtp_close(session);
  '     session->ErrorCode = LIBSMTP_AUTHERR;
  '     return LIBSMTP_AUTHERR;
  '   }
  ' 
  '   return LIBSMTP_NOERR;  
  ' }
  ' 
  sData = $hSession.Send("AUTH PLAIN")
  If $hSession.LastCode <> "334" Then Error.Raise("Unsupported authentication method")
  
  sData = $hSession.Send(Base64$($sUser & Chr$(0) & $sUser & Chr$(0) & $sPassword))
  If $hSession.LastCode <> "235" Then Error.Raise("Authentication failed")
  
End

Private Sub SendRecipients()

  Dim aRcpt As String[]
  Dim sRcpt As String
  Dim sAdr As String

  $hSession.Send("MAIL FROM: " & ExtractAddress($sFrom))
  If $hSession.LastCode >= "300" Then Error.Raise("Sender rejected")
  
  aRcpt = $aTo.Copy()
  aRcpt.Insert($aCC)
  aRcpt.Insert($aBcc)
  
  For Each sRcpt In aRcpt
    
    sAdr = ExtractAddress(sRcpt)
    If Not sAdr Then Continue
    
    $hSession.Send("RCPT TO: " & sAdr)
    If $hSession.LastCode >= "300" Then
      Error.Raise("Recipient rejected: " & sAdr)
    Endif
    
  Next

End

Static Public Sub FormatDate(dDate As Date) As String

  If Not dDate Then dDate = Now
  dDate -= Frac(Date(Now)) ' Go to GMT

  If Not $aDay Then 
    $aDay = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    $aMonth = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  Endif
  
  Return $aDay[WeekDay(dDate)] & ", " & Format(Day(dDate), "00") & " " & $aMonth[Month(dDate) - 1] & " " & Year(dDate) & " " & Format(Time(dDate), "hh:nn:ss") & " GMT"

End

Private Sub SendHeaders()

'   /* Now we send through all the headers. No more responses will come from
'     the mailserver until we end the DATA part. */
' 
'   // BM: Put the Date field
'   // For example: Date: Sat, 18 Jul 2009 12:47:43 +0100
'   
'   date = get_current_time();
'   if (date)
'   {
'     g_string_sprintf (libsmtp_temp_gstring, "Date: %s\r\n", date);
' 
'     if (libsmtp_int_send (libsmtp_temp_gstring, libsmtp_session, 1))
'       return LIBSMTP_ERRORSENDFATAL;
'   }
' 
  
  $hSession.PrintHeader("Date", FormatDate(Now))

'   /* First the From: header */
' 
'   g_string_sprintf (libsmtp_temp_gstring, "From: %s\r\n", \
'                       libsmtp_session->From->str);
' 
'   if (libsmtp_int_send (libsmtp_temp_gstring, libsmtp_session, 1))
'     return LIBSMTP_ERRORSENDFATAL;

  $hSession.PrintHeader("From", FormatAddress($sFrom))
' 
'   /* Then the Subject: header */
' 
'   // BM: if the subject is not ASCII, then it is UTF-8
' 
'   if (is_ascii_string(libsmtp_session->Subject->str))
'   {
'     g_string_sprintf (libsmtp_temp_gstring, "Subject: %s\r\n", \
'                         libsmtp_session->Subject->str);
'   
'     if (libsmtp_int_send (libsmtp_temp_gstring, libsmtp_session, 1))
'       return LIBSMTP_ERRORSENDFATAL;
'   }
'   else
'   {
'     /*g_string_assign(libsmtp_temp_gstring, "Subject: =?utf-8?q?");
'     if (libsmtp_int_send (libsmtp_temp_gstring, libsmtp_session, 1))
'       return LIBSMTP_ERRORSENDFATAL;*/
'     
'     if (libsmtp_int_send_quoted_header("Subject:", libsmtp_session->Subject->str, libsmtp_session->Subject->len, libsmtp_session))
'       return LIBSMTP_ERRORSENDFATAL;
'   
'     //g_string_assign(libsmtp_temp_gstring, "?=\r\n");
'     //if (libsmtp_int_send(libsmtp_temp_gstring, libsmtp_session, 1))
'     //  return LIBSMTP_ERRORSENDFATAL;
'   }

  $hSession.PrintHeader("Subject", $sSubject)

' 
'   /* Then we send all the To: addresses */
' 
'   g_string_assign (libsmtp_temp_gstring, "To: ");
' 
'   for (libsmtp_temp=0; libsmtp_temp < g_list_length(libsmtp_session->To);\
'       libsmtp_temp++)
'   {
'     /* Select the respective node of the linked list */
'     libsmtp_temp_glist=g_list_nth (libsmtp_session->To, libsmtp_temp);
' 
'     /* If this is the last entry of the list, don't append a comma */
'     if (libsmtp_temp==(g_list_length (libsmtp_session->To)-1))
'     {
'       g_string_append (libsmtp_temp_gstring, libsmtp_temp_glist->data);
'       g_string_append (libsmtp_temp_gstring, "\r\n");
'     }
'     else
'     {
'       g_string_append (libsmtp_temp_gstring, libsmtp_temp_glist->data);
'       g_string_append (libsmtp_temp_gstring, ", ");
'     }
'   }
'   /* Send the line to the server */
' 
'   if (libsmtp_int_send (libsmtp_temp_gstring, libsmtp_session, 1))
'     return LIBSMTP_ERRORSENDFATAL;

  If $aTo.Count Then $hSession.PrintHeader("To", $aTo.Join(","))
  If $aCc.Count Then $hSession.PrintHeader("CC", $aCc.Join(","))

' 
'   /* Then we iterate through all CC recipients */
' 
'   if (g_list_length (libsmtp_session->CC))
'   {
'     g_string_assign (libsmtp_temp_gstring, "CC: ");
' 
'     for (libsmtp_temp=0; libsmtp_temp < g_list_length(libsmtp_session->CC);\
'         libsmtp_temp++)
'     {
'       /* Select the respective node of the linked list */
'       libsmtp_temp_glist=g_list_nth (libsmtp_session->CC, libsmtp_temp);
' 
'       /* If this is the last entry of the list, don't append a comma */
'       if (libsmtp_temp==(g_list_length (libsmtp_session->CC)-1))
'       {
'         g_string_append (libsmtp_temp_gstring, libsmtp_temp_glist->data);
'         g_string_append (libsmtp_temp_gstring, "\r\n");
'       }
'       else
'       {
'         g_string_append (libsmtp_temp_gstring, libsmtp_temp_glist->data);
'         g_string_append (libsmtp_temp_gstring, ", ");
'       }
'     }
'     /* Send the line to the server */
' 
'     if (libsmtp_int_send (libsmtp_temp_gstring, libsmtp_session, 1))
'       return LIBSMTP_ERRORSENDFATAL;
'   }
' 
'   return LIBSMTP_NOERR;
' 


End

Private Sub SendMimeHeaders()

  '   /* If we use the MIME stuff we tell them this, too */
  '   g_string_assign (libsmtp_temp_gstring, "Mime-Version: 1.0\r\n");
  ' 
  '   #ifdef LIBSMTP_DEBUG
  '     printf ("libsmtp_mime_headers: %s", libsmtp_temp_gstring->str);
  '   #endif
  ' 
  '   if (libsmtp_int_send (libsmtp_temp_gstring, libsmtp_session, 1))
  '     return LIBSMTP_ERRORSENDFATAL;
  
  $hSession.Print("MIME-Version: 1.0")
  
  ' 
  '   /* If there are no parts defined by now, we assume its
  '      text/plain MIME type and US-ASCII charset */
  ' 
  '   if (!libsmtp_session->Parts)
  '   {
  '     g_string_assign (libsmtp_temp_gstring, "Content-Type: text/plain; charset=\"us-ascii\"\r\n");
  ' 
  '     #ifdef LIBSMTP_DEBUG
  '       printf ("libsmtp_mime_headers: %s", libsmtp_temp_gstring->str);
  '     #endif
  ' 
  '     if (libsmtp_int_send (libsmtp_temp_gstring, libsmtp_session, 1))
  '       return LIBSMTP_ERRORSENDFATAL;
  '   }

  
  If $aPart.Count = 0 Then
    
    $hSession.Print("Content-Type: text/plain; charset=\"us-ascii\"")
  
  Else
  
    $aPart[0].SendHeaders($hSession)
    
  Endif
  
  ' 
  '   /* We enter the data stage now */
  '   libsmtp_session->Stage = LIBSMTP_MIMEHEADERS_STAGE;
  ' 
  '   return LIBSMTP_NOERR;
  ' 
  

End

Public Sub Send()
  
  Dim I As Integer
  
  If Not $sFrom Then
    Error.Raise("The From property must be set")
    Return
  Endif

  BeginSession

  Connect

  Authenticate

  SendRecipients

  $hSession.Send("DATA")
  If $hSession.LastCode <> "354" Then Error.Raise("DATA command failed")
  
  SendHeaders

  SendMimeHeaders

  If $aPart.Count = 1 Then
    
    $aPart[0].Send($hSession)
    
  Else If $aPart.Count > 1 Then
    
    For I = 1 To $aPart.Max
      
      $hSession.Print("--" & $aPart[0].Boundary)
      $aPart[I].SendHeaders($hSession)
      $aPart[I].Send($hSession)
      
    Next

    $hSession.Print("--" & $aPart[0].Boundary & "--")
    
  Endif

  $hSession.Send(".")
  If $hSession.LastCode >= "300" Then
    Error.Raise("Body rejected")
  Endif

  EndSession
    
End



Private Function Encrypt_Read() As Integer

  Return $iEncrypt

End

Private Sub Encrypt_Write(Value As Integer)

  $iEncrypt = Value

End
