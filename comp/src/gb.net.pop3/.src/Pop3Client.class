' Gambas class file

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 2 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

''POP3 protocol implementation in Gambas
'Author: sebikul <sebikul@gmail.com>
'Protocol specifications: http://tools.ietf.org/html/rfc1939

'Minimal Command Set:
'    USER name         user(name)        DONE
'    PASS string       pass_(string)     DONE
'    STAT              stat()            DONE
'    LIST [msg]        list(msg = None)  DONE
'    RETR msg          retr(msg)         DONE
'    DELE msg          dele(msg)         DONE
'    NOOP              noop()            DONE
'    RSET              rset()            DONE
'    QUIT              quit()            DONE
'
'Optional Commands:
'    RPOP name         rpop(name)
'    APOP name digest  apop(name, digest)
'    TOP msg n         top(msg, n)       DONE
'    UIDL [msg]        uidl(msg = None)  DONE

Export

Public Const _IsControl As Boolean = True
Public Const _IsVirtual As Boolean = True
Public Const _Group As String = "Network"
Public Const _Properties As String = "Host,Port,Debug,Encrypt{Net.None;SSL}"

Public Const SERVER_POSITIVE_RESPONSE As String = "+OK"
Public Const SERVER_NEGATIVE_RESPONSE As String = "-ERR"

''Use plaintext or an ssl encrypted conenction
Property Encrypt As Integer
Private $iEncrypt As Integer

''Returns the status of the client as defined by the POP3 class
Property Read Status As Integer
Private $iStatus As Integer

''Used to store the client instance. Either TCPClient or SSLClient.
''Both share the same API.
Private $oClient As POPClient

''Returns or sets the username used to authenticate to the server.
''It cannot be modified after Open() is executed
Property User As String
Private $sUsername As String

''Returns or sets the password used to authenticate to the server.
''It cannot be modified after Open() is executed
Property Password As String
Private $sPassword As String

''Returns or sets the server used to connect to the server.
''It cannot be modified after Open() is executed
Property Host As String
Private $sServer As String

''Returns or sets the port used to connect to the server.
''It cannot be modified after Open() is executed
Property Port As Integer
Private $iPort As Integer

''Returns the message count
Property Read Count As Integer
Private $iCount As Integer

''Returns the size of the inbox in bytes
Property Read Size As Integer
Private $iSize As Integer

''Welcome message returned by the server
Property Read Welcome As String
Private $sWelcome As String

'' If debugging mode is activated for this client
Property Debug As Boolean
Private $bDebug As Boolean

''Collection used to cache the request of single messages
Private $msgCache As New Collection

'' If connection has been closed
Private $bClosed As Boolean

''Returns True if _Text_ begins with "+OK"
Static Public Function isPositive(Text As String) As Boolean

  Return (Text Begins SERVER_POSITIVE_RESPONSE)

End

''Returns True if _Text_ begins with "-ERR"
Static Public Function isNegative(Text As String) As Boolean

  Return (Text Begins SERVER_NEGATIVE_RESPONSE)

End

''Strips the +OK part of the response
Static Public Function StripOK(Text As String) As String

  If Not isPositive(Text) Then Return

  Text = Trim(Mid(Text, 4))

  Return Text

End

Static Public Sub _PrintDebug(sMsg As String)

  Error "gb.net.pop3: "; sMsg

End

Public Function _get(msgid As Integer) As _Pop3Client_Message

  Dim oPOPMInstance As _Pop3Client_Message

  If msgid = 0 Then msgid = 1

  If msgid > Me.Count Then Return

  If Not $msgCache.Exist(msgid) Then

    oPOPMInstance = New _Pop3Client_Message(msgid, Me)

    $msgCache.Add(oPOPMInstance, msgid)

  Endif

  Return $msgCache[msgid]

End

Public Function _next() As _Pop3Client_Message

  Dim oPOPMInstance As _Pop3Client_Message

  Dim i As Integer

  If IsNull(Enum.Index) Then
    Enum.Index = 1
  Endif

  If Enum.Index > Me.Count Then
    Enum.Stop()
    Return
  Endif

  'oPOPMInstance = New _Pop3Client_Message(Enum.Index, Me)

  i = Enum.Index

  oPOPMInstance = _get(i)

  Inc Enum.Index

  Return oPOPMInstance

End

''Establish a connection. Choose Client depending on Encrypt
''Port defaults to 110 for TCPClient and 995 for SSLClient
Public Function Open() As Boolean

  Dim iPort As Integer

  If Not $sServer Then
    Error.Raise(("Server not set"))
  Endif

  If Not $sUsername Then
    Error.Raise(("Username not set"))
  Endif

  If Not $sPassword Then
    Error.Raise(("Password not set"))
  Endif

  If $bDebug Then _PrintDebug("Connecting to " & Me.Host)

  iPort = $iPort

  Select Case Me.Encrypt

    Case Net.None
      $oClient = New TCPClient
      If iPort = 0 Then
        iPort = 110
        If $bDebug Then _PrintDebug(("Port not specified, using 110"))
      Endif

    Case Net.SSL
      If iPort = 0 Then
        iPort = 995
        If $bDebug Then _PrintDebug(("Port not specified, using 995"))
      Endif

      $oClient = New SSLClient

    Case Else
      Error.Raise(("Invalid connection type"))

  End Select

  $oClient.Connect(Me.Host, iPort)

  'Set welcome message
  $sWelcome = Trim($oClient.GetLine())

  If $bDebug Then _PrintDebug("Authenticating...")

  If Not _User(Me.User) Then
    $iStatus = Net.CannotAuthenticate
    If $bDebug Then _PrintDebug("Bad username")
  Else If Not _Pass(Me.Password) Then
    $iStatus = Net.CannotAuthenticate
    If $bDebug Then _PrintDebug("Bad password")
  Else
    $iStatus = Net.Connected
    If $bDebug Then _PrintDebug("OK")
  Endif

  Return $iStatus

End

''Send Data to the server and wait for a response, then return it.
Public Function Exec(Data As String, Optional Multiline As Boolean = False) As String

  Dim Response As String
  Dim iPos As Integer

  If $bDebug Then _PrintDebug("Sending: " & Data)
  'Send the data
  Response = $oClient.Send(Data, Multiline)

  ' If Not Response Begins "+" Then
  '   Error.Raise("Invalid POP response: " & Response)
  ' Endif

  If $bDebug Then
    If Multiline Then
      iPos = InStr(Response, "\n")
      If iPos Then
        _PrintDebug(RTrim(Left(Response, iPos - 1)) & "...")
      Else
        _PrintDebug(Response)
      Endif
    Else
      _PrintDebug(Response)
    Endif
  Endif

  Return Response

End

''Logout from the server and disconnect
Public Function Close() As Boolean

  Dim Response As String

  If $iStatus <> Net.Connected Then
    Error.Raise(("Not connected"))
  Else If $bClosed Then
    Error.Raise(("Already in UPDATE state"))
  Endif

  Response = Exec("QUIT")

  If $bDebug Then _PrintDebug("Disconnecting...")
  $oClient.Disconnect()

  $msgCache = Null

  $bClosed = True

  Return isPositive(Response)

End

Public Function Stat() As Integer[]

  Dim Response As String

  Dim stat_data As String[]

  Response = Exec("STAT", False)

  If isPositive(Response) Then
    Response = StripOK(Response)

    If Not Response Then Return

    stat_data = Split(Response, " ")

    Return [CInt(stat_data[0]), CInt(stat_data[1])]

  Endif

End

''Returns a positive response if the Client is in Transaction state.
''Can be used as a keep-alive feature
Public Function Ping() As Boolean

  Dim Response As String

  Response = Exec("NOOP")

  Return isPositive(Response)

End

Public Function Reset() As Boolean

  Dim Response As String

  Response = Exec("RSET")

  Return isPositive(Response)

End

Private Function _User(Username As String) As Boolean

  Dim Response As String

  Response = Exec("USER " & Username)

  Return isPositive(Response)

End

Private Function _Pass(Password As String) As Boolean

  Dim Response As String

  Response = Exec("PASS " & Password)

  Return isPositive(Response)

End

Public Function List() As String[]

  Dim Response As String

  Dim list_data As String[]

  Response = Exec("LIST", True)

  If isPositive(Response) Then
    Response = StripOK(Response)

    list_data = Split(Response, "\n")

    list_data.Remove(list_data.Count - 1)

    Return list_data

  Endif

End

Public Function UniqueID() As String[]

  Dim Response As String

  Dim list_data As String[]

  Response = Exec("UIDL", True)

  If isPositive(Response) Then
    Response = StripOK(Response)

    list_data = Split(Response, "\n")

    list_data.Remove(list_data.Count - 1)

    Return list_data

  Endif

End

Private Function Count_Read() As Integer

  If Not $iCount Then _Refresh()

  'Debug $iCount

  Return $iCount

End

Private Function Size_Read() As Integer

  If Not $iSize Then _Refresh()

  Return $iSize

End

Private Function Encrypt_Read() As Integer

  Return $iEncrypt

End

Private Sub Encrypt_Write(Value As Integer)

  If $iEncrypt Then Error.Raise(("Cannot modify encryption"))

  $iEncrypt = Value

End

Private Function Status_Read() As Integer

  Return $iStatus

End

Private Function User_Read() As String

  Return $sUsername

End

Private Sub User_Write(Value As String)

  'If $sUsername Then Error.Raise("Cannot modify username")

  $sUsername = Value

End

Private Function Password_Read() As String

  Return $sPassword

End

Private Sub Password_Write(Value As String)

  'If $sPassword Then Error.Raise("Cannot modify password")

  $sPassword = Value

End

Private Function Host_Read() As String

  Return $sServer

End

Private Sub Host_Write(Value As String)

  'If $sServer Then Error.Raise("Cannot modify Server")

  $sServer = Value

End

Private Function Port_Read() As Integer

  Return $iPort

End

Private Sub Port_Write(Value As Integer)

  'If $iPort Then Error.Raise("Cannot modify port")

  $iPort = Value

End

''Clears inbox and message cache
Private Sub _Refresh()

  Dim sResponse As Integer[]

  'Dim sMessage As String

  'Dim iSize As Integer

  If $bDebug Then _PrintDebug("Refreshing inbox cache")

  $msgCache.Clear()

  sResponse = Me.Stat()

  $iCount = sResponse[0]
  $iSize = sResponse[1]

  '
  ' If sResponse.Count > 0 Then
  '   $iCount = sResponse.Count
  '   For Each sMessage In sResponse
  '     iSize += CInt(Split(sMessage, " ")[1])
  '
  '   Next
  '
  '   $iSize = iSize
  '
  ' Endif

End

Private Function Welcome_Read() As String

  Return $sWelcome

End

Private Function Debug_Read() As Boolean

  Return $bDebug

End

Private Sub Debug_Write(Value As Boolean)

  $bDebug = Value

End
