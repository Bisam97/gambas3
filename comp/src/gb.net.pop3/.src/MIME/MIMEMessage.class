' Gambas class file

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 2 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

''MIME parser implemented in Gambas
'Author: sebikul <sebikul@gmail.com>
'(main) specifications: http://tools.ietf.org/html/rfc1341

Export

Private $aHeaders As New Collection

''Space character
Private WSP_SP As String = Chr(32)

''Horizontal tab character
Private WSP_HTAB As String = Chr(9)

''Original message stored as a string
Private $sOriginal As String

''Original body stored as an array (\n). The headers are striped
Private $aOriginal As String[]

''Line(-1) or array index that separates the header section from the body
Private $iSplitLine As String

''Returns a _MIMEpart_Message instance
''or an array of _MIMEpart_Message is message is multipart/*
Property Read Message As Variant
Private $oMessages As Object[]

'Private $sBody As String

Property Read From As String

Property Read To As String

Property Read Subject As String

''FIXME: Parse into date
Property Read Date As Date

Property Read ContentType As String[]
Private $sType As String
Private $sSubtype As String

Property Read isMultipart As Boolean

Private $sBoundary As String

''TODO: test for mime version header

Public Sub _new(sMessage As String)

  Dim cType As Collection

  $sOriginal = sMessage

  _parseHeaders()

  cType = _parseType(_get("Content-Type"))

  $sType = LCase(cType["Content-Type"][0])
  $sSubtype = LCase(cType["Content-Type"][1])

  If cType.Exist("boundary") Then $sBoundary = cType["boundary"]

  _parseBody($aOriginal.Join("\n"))

End

''Parse the headers of the message into a collection
Private Sub _parseHeaders()

  Dim i, iPos As Integer

  ''temporary store for headers
  Dim aHeaders As New String[]

  Dim sMsgLine, sFirstChar As String

  Dim sFieldName, sFieldBody, sTempVal As String

  'Debug "Parsing message headers"

  $aOriginal = Split($sOriginal, "\n")

  For Each sMsgLine In $aOriginal

    'sMsgLine = Trim(sMsgLine)

    If Not Trim(sMsgLine) And i = 0 Then
      'aOriginal.Remove(0)
      Inc i
      Continue
    Endif

    'Exit the loop if we reached the message body
    If Not Trim(sMsgLine) Then Break

    sFirstChar = Left(sMsgLine)

    'If the first character is a space, we asume we are in a multiline
    'header. Add a new line character and append it to the last element of the array
    If sFirstChar = WSP_HTAB Or sFirstChar = WSP_SP Then

      aHeaders[aHeaders.Count - 1] &= "\n" & Trim(sMsgLine)

    Else
      aHeaders.Add(sMsgLine)
    Endif

    Inc i

  Next

  ''We now have multiline headers grouped itno single lines, parse
  ''the array and populate the collection
  For Each sMsgLine In aHeaders

    iPos = InStr(sMsgLine, ":")
    If Not iPos Then Continue

    sFieldName = Mid(sMsgLine, 1, iPos - 1)

    sFieldBody = Trim(Mid(sMsgLine, iPos + 1))

    ''An element with this key already exist, store it into a temporary
    ''value and replace it with an array structure
    If $aHeaders.Exist(sFieldName) Then

      If TypeOf($aHeaders[sFieldName]) = gb.String Then

        sTempVal = $aHeaders[sFieldName]

        $aHeaders[sFieldName] = New String[]

        ''Restore the temporary value as the first element of the new array
        $aHeaders[sFieldName].Add(sTempVal)

      Endif

      $aHeaders[sFieldName].Add(sFieldBody)

    Else

      $aHeaders.Add(sFieldBody, sFieldName)

    Endif

  Next

  ''Parse body using _i_ as a marker for the end of the headers section

  $iSplitLine = i

  $aOriginal.Extract(0, i + 1)

End

''@Deprecated. Multipart messages to be implemented
' Private Sub _parseBody()
'
'   Dim sMsgLine, sEscapeChar As String
'
'   Dim iPos, i, iLine As Integer
'
'   For Each sMsgLine In $aOriginal
'
'     If sMsgLine Begins "--=" Then Continue
'
'     If sMsgLine Ends "=" Then
'       sMsgLine = Mid(sMsgLine, 1, -1) & "\n"
'     Endif
'
'     i = InStr(sMsgLine, "=", i)
'
'     While i
'
'       ''This is not an escape character!
'       If Trim(Mid(sMsgLine, i, i + 1)) Then
'
'         sEscapeChar = Trim(Mid(sMsgLine, i + 1, 2))
'
'         If Len(sEscapeChar) = 2 And sEscapeChar <> "==" And IsHexa(sEscapeChar) Then
'
'           'Print Trim(sMsgLine), sEscapeChar, Eval("&" & sEscapeChar), QuoteDecode(sEscapeChar)
'
'           ''Escape character is valid.
'           sMsgLine = Mid(sMsgLine, 1, i - 1) & QuoteDecode(sEscapeChar) & Mid(sMsgLine, i + 3)
'
'           'Print
'
'           Wait
'         Else
'           'Debug "Invalid escape character detected[" & Trim(sMsgLine) & "]: " & sEscapeChar
'         Endif
'
'         'Debug "Escape character detected: " & sEscapeChar
'
'         'Print i, sMsgLine
'
'       Endif
'       ''False when we reach EOL
'       i = InStr(sMsgLine, "=", i + 1)
'     Wend
'
'     $aOriginal[iLine] = Trim(sMsgLine)
'
'     Inc iLine
'
'   Next
'
'   'FIXME:
'   '$sBody = Trim($aOriginal.Join("\n"))
'
'   'Print $sText
'
' End

Private Function _parseBody(Text As String) As Variant

  Dim iStart, iEnd, iCount As Integer

  Dim aText, aMessagePart As String[]

  Dim aMessage As New Collection

  Dim aHeaders As Collection

  Dim iMIME As MIMEPart_Message

  If Me.isMultipart Then

    aText = Split(Text, "\n")

    iStart = aText.Find("--" & $sBoundary)

    While (iStart <> -1)

      iEnd = aText.Find("--" & $sBoundary,, iStart + 1)

      If iEnd = -1 Then
        aMessagePart = aText.Copy(iStart + 1)
      Else
        aMessagePart = aText.Copy(iStart + 1, iEnd - iStart - 1)
      Endif

      ''TODO: Detect headers at the start of a message part

      ''TODO: Recurse if header has multipart
      iMIME = New MIMEPart_Message(aMessagePart.Join("\n"), _parseType(aMessagePart[0]))

      aMessage.Add(iMIME, iCount)

      iStart = aText.Find("--" & $sBoundary,, iStart + 1)

      Inc iCount

    Wend

  Else

    Return QuoteDecode(Text)

  Endif

End

''Return the header with matching _sKey_ field name
'TODO: Return array for String[] or use the iKey parameter?
Public Function _get(sKey As String) As Variant 'Optional iKey As Integer) As Variant

  If Not $aHeaders.Exist(sKey) Then Return

  Return $aHeaders[sKey]

  ' If iKey Then
  '   Return $aHeaders[sKey][iKey]
  ' Else
  '
  '   Return $aHeaders[sKey]
  ' Endif

End

Public Function ToString() As String

End

Private Function _parseType(Optional sHeader As String) As Collection

  Dim aParams, sCType, aParam As String[]

  Dim sParam, sKey, sValue As String

  Dim iPos, iEnd As Integer

  Dim cRetParams As New Collection

  'If sHeader Then
  '  aParams = Split(sHeader, ";")
  ' Else
  '   aParams = Split(_get("Content-Type"), ";")
  ' Endif
  '
  ' sCType = Split(aParams[0], "/")
  '
  ' $sType = LCase(Trim(QuoteDecode(sCType[0])))
  ' $sSubtype = LCase(Trim(QuoteDecode(sCType[1])))
  '
  ' aParams.Remove(0)

  aParams = Split(sHeader, ";")

  sParam = QuoteDecode(aParams[0])

  cRetParams.Add(Split(sParam, "/"), "Content-Type")

  ''remove the content type
  aParams.Remove(0)

  ''We have more parameters to parse...
  If aParams.Count > 0 Then

    For Each sParam In aParams

      sParam = Trim(sParam)

      iPos = InStr(sParam, "\"")

      If Not iPos Then

        aParam = Split(sParam, "=")

        sKey = aParam[0]

        sValue = aParam[1]

      Else

        iEnd = InStr(sParam, "\"", iPos + 1)

        ''This is an attribute
        sKey = Trim(Split(sParam, "=")[0])

        If iPos And iEnd Then

          sValue = Mid(sParam, (iPos + 1), (iEnd - iPos - 1))

        Endif

      Endif

      cRetParams.Add(sValue, sKey)

    Next

  Endif

  Return cRetParams

End

Private Function Body_Read() As String

  'Return $sBody

End

Private Function From_Read() As String

  If $aHeaders.Exist("from") Then
    Return $aHeaders["from"]
  Else If $aHeaders.Exist("From")
    Return $aHeaders["From"]
  Endif

  Return

End

''Decode Quote-Encoded characters in _Text_
Static Public Function QuoteDecode(Text As String) As String

  Dim iLine, iPos As Integer

  Dim aText As String[]

  Dim sLine, sEscapeChar As String

  aText = Split(Text, "\n")

  For Each sLine In aText

    If sLine Ends "=" Then
      sLine = Mid(sLine, 1, -1) & "\n"
    Endif

    iPos = InStr(sLine, "=", iPos)

    While iPos

      ''This is an escape character
      If Trim(Mid(sLine, iPos + 1)) Then

        sEscapeChar = Trim(Mid(sLine, iPos + 1, 2))

        If Len(sEscapeChar) = 2 And IsHexa(sEscapeChar) Then

          'Print Trim(sMsgLine), sEscapeChar, Eval("&" & sEscapeChar), QuoteDecode(sEscapeChar)

          ''Escape character is valid.
          sLine = Mid(sLine, 1, iPos - 1) & QuoteDecode(sEscapeChar) & Mid(sLine, iPos + 3)

          'Print

        Else
          'Debug "Invalid escape character detected[" & Trim(sMsgLine) & "]: " & sEscapeChar
        Endif

        'Debug "Escape character detected: " & sEscapeChar

        'Print i, sMsgLine

      Endif
      ''False when we reach EOL
      iPos = InStr(sLine, "=", iPos + 1)
    Wend

    aText[iLine] = Trim(sLine)

    Inc iLine

  Next

  Return aText.Join("\n")

End

''Decode a pair of quote-encoded chars
Private Function _DecodeChar(Char As String) As String

  If Len(Char) <> 2 Or Not IsHexa(Char) Then Return Char

  Return Chr(Eval("&" & Char))

End

''TODO: Implement
Private Function QuoteEncode(Text As String) As String

End

Private Function Subject_Read() As String

  If $aHeaders.Exist("subject") Then
    Return $aHeaders["subject"]
  Else If $aHeaders.Exist("Subject")
    Return $aHeaders["Subject"]
  Endif

  Return

End

Private Function To_Read() As String

  If $aHeaders.Exist("to") Then
    Return $aHeaders["to"]
  Else If $aHeaders.Exist("To")
    Return $aHeaders["To"]
  Endif

  Return

End

Private Function Date_Read() As Date

  'Dim MatchDate As New Regexp
  Dim sDate As String

  ' MatchDate.Compile("([0-9]{4})|([A-Z][a-z]{2})|([0-9]{2})", )
  '
  ' If $aHeaders.Exist("date") Then
  '   sDate = $aHeaders["date"]
  ' Else If $aHeaders.Exist("Date")
  '   sDate = $aHeaders["Date"]
  ' Endif

  ' sDate = Mid(sDate, 1, -6)
  '
  ' MatchDate.Exec(sDate)

End

Private Function ContentType_Read() As String[]

  Return [$sType, $sSubtype]

End

Private Function Message_Read() As Variant

End

Private Function isMultipart_Read() As Boolean

  Return ($sType = "multipart")

  'Return ($oMessages Not Is _MIMEPart_Message)

End
