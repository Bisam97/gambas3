' Gambas module file

Export 
'CREATE 

Private $sId As String
Private $sPath As String
Private $cVal As Collection
Private $bModify As Boolean
Private $eTimeout As Float = 1
Private $eStartup As Float
Private $hLock As File

Property Id As String
Property Timeout As Float

Private Sub WriteLength(iLen As Integer)
  
  Dim iByte As Byte
  Dim iShort As Short
  
  If iLen < &H80 Then 
    iByte = iLen
    Write iByte 
  Else If iLen < &H4000 Then
    iByte = Lsr(iLen, 8) Or &H80
    Write iByte
    iByte = iLen And &HFF
    Write iByte 
  Else
    iByte = Lsr(iLen, 24) Or &HC0
    Write iByte
    iByte = Lsr(iLen, 16) And &HFF
    Write iByte 
    iByte = Lsr(iLen, 8) And &HFF
    Write iByte 
    iByte = iLen And &HFF
    Write iByte 
  Endif
  
End

Private Sub ReadLength() As Integer
  
  Dim iByte As Byte
  Dim iLen As Integer
  
  Read iByte
  
  Select Case Lsr(iByte, 6)
  
    Case 0, 1
      Return iByte
    
    Case 2
      iByte = iByte And &H3F
      iLen = Lsl(CInt(iByte), 8)
      Read iByte
      iLen += iByte
  
    Case 3
      iByte = iByte And &H3F
      iLen = Lsl(CLong(iByte), 32)
      Read iByte
      iLen += Lsl(CLong(iByte), 16)
      Read iByte
      iLen += Lsl(CLong(iByte), 8)
      Read iByte
      iLen += iByte
  
  End Select
  
  Return iLen
    
End

Private Sub WriteValue(vVal As Variant)
  
  Dim vElt As Variant
  Dim iType As Byte
  
  If IsObject(vVal) Then 
    If vVal Is Collection Then 
      'Main.Log("WriteValue: Collection (" & vVal.Count & ")")
      Print "C";
      WriteLength(vVal.Count)
      For Each vElt In vVal
        'Main.Log("WriteValue: Key = '" & CStr(vVal.Key) & "' Value = '" & CStr(vElt) & "'")
        Write CStr(vVal.Key)
        WriteValue(vElt)
      Next 
    Else If vVal Is Array Then 
      Print "A";
      iType = vVal.Type
      Write iType
      WriteLength(vVal.Count)
      For Each vElt In vVal
        WriteValue(vElt)
      Next 
    Else 
      Error.Raise("Unserializable datatype")
    Endif
  Else 
    iType = TypeOf(vVal)
    'WRITE iType
    Write vVal
  Endif
  
End

Private Sub LockSession() As File
  
  Dim iInd As Integer
  
  For iInd = 1 To 10
    Try $hLock = Lock $sPath & ".lock"
    If Not Error Then Break
    Sleep 0.1
  Next
  
End

Private Sub UnlockSession()
  
  Try Unlock #$hLock
  
End


Private Sub SaveSession()
  
  Dim hFile As File
  Dim hLock As File
  Dim sTemp As String

  'PRINT "<h2>Save session</h2>"
  'PRINT "<p>"; $sId; "<br>"; $bModify; "<br>"; $sPath; "<br>"; $cVal.Count
  
  If Not $sId Then Return 

  sTemp = Temp$()

  'Startup time is always modified
  If Not $bModify Then 
  
    LockSession
    
    'Main.Log("SaveSession: " & $sPath & ": Just update time stamp : " & Exist($sPath))
    hFile = Open $sPath For Write 
    Write #hFile, CFloat(Now)
    Close #hFile
    
    UnlockSession
    
  Else
  
    'Main.Log("SaveSession: " & $sPath & ": Save all session : " & Exist($sPath))
    hFile = Open sTemp For Write Create 

    Write #hFile, CFloat(Now)
    Write #hFile, $eTimeout

    Output To #hFile
    WriteValue($cVal)
    Output To Default
    
    Close #hFile
    
    LockSession
    Try Kill $sPath
    Move sTemp To $sPath
    UnlockSession
    
  Endif
    
  ' If Exist($sPath) Then
  '   Main.Log("SaveSession: " & $sPath & " (" & Stat($sPath).Size & ")")
  ' Else
  '   Main.Log("SaveSession: " & $sPath & " NOT FOUND!")
  ' Endif
  
End

Private Sub ReadValue() As Variant
  
  Dim bBoolean As Boolean
  Dim iByte As Byte
  Dim iShort As Short
  Dim iInt As Integer
  Dim iLong As Long
  Dim sStr As String
  Dim dDate As Date
  Dim gSingle As Single
  Dim fFloat As Float
  Dim hCol As Collection
  Dim aArr As Object
  Dim iLen As Integer
  Dim vVal As Variant
  
  Read iByte

  Select Case iByte
    Case gb.Boolean
      Read bBoolean
      Return bBoolean
    Case gb.Byte
      Read iByte
      Return iByte
    Case gb.Short
      Read iShort
      Return iShort
    Case gb.Integer
      Read iInt
      Return iInt
    Case gb.Long
      Read iLong
      Return iLong
    Case gb.Single
      Read gSingle
      Return gSingle
    Case gb.Float
      Read fFloat
      Return fFloat
    Case gb.Date
      Read dDate
      Return dDate
    Case gb.String
      Read sStr
      Return sStr
    Case Asc("C")
      'Main.Log("ReadValue: Collection")
      hCol = New Collection
      iLen = ReadLength()
      'Main.Log("ReadValue: " & iLen)
      For iInt = 1 To iLen
        Read sStr
        vVal = ReadValue()
        'Main.Log("ReadValue: Key = '" & sStr & "' Value = '" & CStr(vVal) & "'")
        hCol[sStr] = vVal
      Next
      Return hCol
    Case Asc("A")
      Read iByte
      iLen = ReadLength()
      sStr = ["Boolean", "Byte", "Short", "Integer", "Long", "Single", "Float", "Date", "String", "String", "Variant", "", "", "", "", "Object"][iByte]
      'Main.Log("ReadValue: " & sStr & "[" & iLen & "]")
      aArr = New (sStr & "[]", iLen)
      For iInt = 0 To iLen - 1
        aArr[iInt] = ReadValue()
        'Main.Log("ReadValue: [" & iInt & "] = " & CStr(aArr[iInt]))
      Next
      Return aArr
  End Select  
  
End

Private Sub CheckSession() As Boolean
  
  'Main.Log("TimeOut: " & CStr(CDate($eTimeOut)) & " Startup: " & CStr(CDate($eStartup)) & " Now: " & CStr(Now))
  Return (CFloat(Now) - $eStartup) >= $eTimeout
  
End


Private Sub LoadSession()
  
  Dim hFile As File

  'Main.Log("LoadSession: #1 '" & $sPath & "'")

  If Not Exist($sPath) Then Goto _ABANDON
  
  'Main.Log("LoadSession: #2")
  
  LockSession
  hFile = Open $sPath
  Input From #hFile

  'IF ReadValue() = 1 THEN GOTO _ABANDON
  Read $eStartup
  Read $eTimeout
  If CheckSession() Then 
    'Main.Log("* TimeOut: " & CStr(CDate($eTimeOut)) & " Startup: " & CStr(CDate($eStartup)) & " Now: " & CStr(Now))
    Goto _ABANDON
  Endif
  
  'Main.Log("LoadSession: #3")
  
  $cVal = ReadValue()
  $bModify = False
  Close #hFile
  Input From Default
  UnlockSession
  Return  

Catch

  Main.Log("LoadSession: " & $sId & ": " & Error.Where & ": " & Error.Text)
  'Try File.Save(File.Dir($sPath) &/ "session.error", Error.Where & ": " & Error.Text & "\n")
  'Try Kill $sPath & ".error"
  'Try Copy $sPath To $sPath & ".error"

_ABANDON:

  'Main.Log("LoadSession: #4")

  If hFile Then
    Close #hFile
    Input From Default 
    UnlockSession
  Endif
  
  Try Kill $sPath
  Try Kill $sPath & ".lock"
  $sId = ""
  
End

Private Sub GetPath(Optional sId As String) As String
  
  Return "/tmp/gambas." & System.User.Id &/ "session" &/ sId 
  
End


Private Sub CreateSession()
  
  Dim iInd As Integer
  Dim sPrefix As String
  
  sPrefix = "/tmp/gambas." & System.User.Id
  
  Repeat 
    $sId = ""
    For iInd = 1 To 8
      $sId &= Hex$(Int(Rnd(65536)), 4)
    Next
    $sId &= "@" & CGI["REMOTE_ADDR"]
    '$sId = "TEST"
    $sPath = GetPath($sId) 'sPrefix &/ "session" &/ $sId  
  Until Not Exist($sPath)
  
  
  'TRY MKDIR $sPrefix
  Try Mkdir GetPath() 'sPrefix &/ "session"
  
  Response.SetCookie("SESSION", $sId, "", File.Dir(CGI["SCRIPT_NAME"]))
  
  $cVal = New Collection
  $eStartup = Now
  
End

Private Sub SelectSession()
  
  $sPath = GetPath($sId) '"/tmp/gambas." & System.User.Id &/ "session" &/ $sId
  
  LoadSession

End


Public Sub _init()
  
  $sId = Request.Cookies["SESSION"]
  '$sId = "9E2496B3AB6DDED93ABE6F0CF6E071B3@"
  If Not $sId Then Return
  
  SelectSession
  
'CATCH 
'  CGI.Error(Error.Where & ": " & Error.Text)

End

Public Sub _exit()
  
  SaveSession
  
End


Public Sub Abandon()
  
  'Main.Log("Abandon")  
  
  If Not $sId Then Return
  Try Kill $sPath
  Try Kill $sPath & ".lock"
  Response.RemoveCookie("SESSION", $sId, "", File.Dir(CGI["SCRIPT_NAME"]))
  $sId = ""
  $sPath = ""
  $cVal = Null
  
End

Public Sub _get(Key As String) As Variant
  
  If $cVal Then Return $cVal[Key]
  
End

Public Sub _put(Value As Variant, Key As String)

  If Not $cVal Then CreateSession
  $cVal[Key] = Value
  $bModify = True
    
End

Private Function Id_Read() As String

  Return $sId  

End


Private Sub Id_Write(Value As String)

  Abandon
  $sId = Value
  SelectSession    

End

Private Function Timeout_Read() As Float

  Return Int($eTimeout * 86400 + 0.5)

End

Private Sub Timeout_Write(Value As Float)

  $eTimeout = Value / 86400

End

Public Sub Save()
  
  SaveSession
  
End

Public Sub Load()

  LoadSession
  
End

