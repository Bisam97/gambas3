' Gambas class file
' ' Gambas class file
' " Gambas class file"
' import struct, datetime, decimal, itertools
' 
' def dbfreader(f):
' '     "" "Returns an iterator over records in a Xbase DBF file."
' ' 
' '     The first row returned contains the field names.
' '     The Second row contains field specs: (type, size, decimal places).
' '     Subsequent rows contain the data records.
' '     If a record Is Marked As Deleted, it Is Skipped.
' ' 
' '     File should be opened For Binary reads.
' ' 
' '     "" ""
'     'See DBF Format spec at:
'     'http: / / www.pgts.com.au / download / Public / xbase.htm 'DBF_STRUCT
' 
'     numrec, lenheader = struct.unpack("<xxxxLH22x", f.read(32))    
'     numfields = (lenheader - 33) / / 32
' 
'     fields = []
'     For fieldno In xrange(numfields):
'         name, typ, size, deci = struct.unpack("<11sc4xBB14x", f.read(32))
'         name = name.replace("\0", "") 'eliminate NULs From String   
'         fields.append((name, typ, size, deci))
'     yield[field[0] For field In fields]
'     yield[tuple(field[1: ]) For field In fields]
' 
'     terminator = f.read(1)
'     assert terminator == "\r"
' 
'     fields.insert(0, ("DeletionFlag", "C", 1, 0))
'     fmt = "".join(["%ds" % fieldinfo[2] For fieldinfo In fields])
'     fmtsiz = struct.calcsize(fmt)
'     For i In xrange(numrec):
'         record = struct.unpack(fmt, f.read(fmtsiz))
'         If record[0]! = " ":
'             Continue 'deleted record
'         result = []
'         For (name, typ, size, deci), value In itertools.izip(fields, record):
'             If name == "DeletionFlag":
'                 Continue
'             If typ == "N":
'                 value = value.replace("\0", "").lstrip()
'                 If value == "":
'                     value = 0
'                 elif deci:
'                     value = decimal.Decimal(value)
'                 else:
'                     value = Int(value)
'             elif typ == "D":
'                 y, m, d = Int(value[: 4]), Int(value[4: 6]), Int(value[6: 8])
'                 value = datetime.date(y, m, d)
'             elif typ == "L":
'                 value = (value In "YyTt" And "T") Or (value In "NnFf" And "F") Or "?"
'             result.append(value)
'         yield result
' 
' 
' def dbfwriter(f, fieldnames, fieldspecs, records):
'     "" " Return a string suitable for writing directly to a binary dbf file."
' 
'     File f should be Open For writing In a Binary mode.
' 
'     Fieldnames should be no longer than ten characters And Not include \ x00.
'     Fieldspecs are In the form(type, size, deci)where
'         type Is One of:
'             C For ascii character data
'             M For ascii character memo data(real memo fieldsNot supported)
'             D For datetime objects
'             N For ints Or decimal objects
'             L For logical values "T", "F", Or "?"
'         size Is The field width
'         deci Is The number Of decimal places In the provided decimal object
'     Records can be an iterable over the records(sequences Of field values).
'     
'     "" ""
'     'header info
'     ver = 3
'     Now = datetime.datetime.now()
'     yr, mon, Day = now.year - 1900, now.month, now.day
'     numrec = Len(records)
'     numfields = Len(fieldspecs)
'     lenheader = numfields * 32 + 33
'     lenrecord = sum(field[1] For field In fieldspecs) + 1
'     hdr = struct.pack("<BBBBLHH20x", ver, yr, mon, Day, numrec, lenheader, lenrecord)
'     f.write(hdr)
'                       
'     'field specs
'     For name, (typ, size, deci) In itertools.izip(fieldnames, fieldspecs):
'         name = name.ljust(11, "\x00")
'         fld = struct.pack("<11sc4xBB14x", name, typ, size, deci)
'         f.write(fld)
' 
'     'terminator
'     f.write("\r")
' 
'     'records
'     For record In records:
'         f.write(" ")                        ' deletion flag
'         For (typ, size, deci), value In itertools.izip(fieldspecs, record):
'             If typ == "N":
'                 value = Str(value).rjust(size, " ")
'             elif typ == "D":
'                 value = value.strftime("%Y%m%d")
'             elif typ == "L":
'                 value = Str(value)[0].upper()
'             else:
'                 value = Str(value)[: size].ljust(size, " ")
'             assert Len(value) == size
'             f.write(value)
' 
'     'End Of file
'     f.write("\x1A")