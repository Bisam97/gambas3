' Gambas class file

Export
Inherits _MapLayer

Public Const {Point} As Integer = 1
Public Const MultiPoint As Integer = 8
Public Const Polyline As Integer = 3
Public Const Polygon As Integer = 5
Public Const Circle As Integer = 33

Private $aShapes As New _ShapeItem[]
Private $himgPoint As Image
'Property Points As Shapes
Property {Color} As Integer
Property FillColor As Integer
Private $icolor As Integer
Private $iFillColor As Integer
Property LineWidth As Integer
Private $iLineWidth As Integer = 2
'Private $colKeyShape As New Collection
Private $aShapeNames As New String[]
Property Read Count As Integer
Property Image As Image
Property Read Max As Integer
Private $sLastKey As String
Property Read Key As String
Private $aInView As New Integer[]

Public Sub _new()
  
  $himgPoint = Image.Load("point.png")
  
End

Public Sub Load()
  
  Dim hMap As Map = GetMap()
  Dim i As Integer
  Dim pt1, pt2 As Point
  
  $aInView.Clear
  For i = 0 To $aShapes.Max
    If Not ($aShapes[i].Type = Me.Point) Then
      pt1 = Geo.MapPointToPixel($aShapes[i].Bounds.TopLeft, hMap.Zoom)
      pt2 = Geo.MapPointToPixel($aShapes[i].Bounds.BottomRight, hMap.Zoom)
      If pt2.x - pt1.x < 2 And If pt2.y - pt1.y < 2 Then Continue
    Endif
    With $aShapes[i].Bounds
      If .Lon2 > hMap.Bounds.Lon Then 
        If .lon < hMap.Bounds.lon2
          If .lat2 < hMap.Bounds.Lat Then
            
            If .Lat > hMap.Bounds.Lat2 Then
              
              $aInView.Add(i)
            Endif
          Endif
        Endif
      Endif
    End With
  Next
  'Debug "Nombre d'élément affiché : " & $aInView.Count
  
End

Public Sub AddPoint(Key As String, Points As MapPoint, Optional {Color} As Integer) As _ShapeItem
  
  Dim hItem As _ShapeItem
  
  If $aShapeNames.Exist(Key) Then Error.Raise("This key already exist")
  hItem = New _ShapeItem(Key) As "Item"
  If Not IsMissing({Color}) Then hItem.Color = Color
  hItem.Type = Me.Point
  hItem.Center = Points
  hItem.Points = Points
  hItem.Bounds = MapBounds(Points, Points)
  $aShapes.Add(hItem)
  $aShapeNames.Add(Key)
  
  Return hItem

End

Public Sub AddMultipoint(Key As String, Points As MapPoint[], Optional {Color} As Integer) As _ShapeItem
  
  Dim hItem As _ShapeItem
  
  If $aShapeNames.Exist(Key) Then Error.Raise("This key already exist")
  hItem = New _ShapeItem(Key) As "Item"
  If Not IsMissing({Color}) Then hItem.Color = Color
  hItem.MultiPoint = MultiPoint
  hItem.Center = GetCenter(Points)
  hItem.Points = Points
  hItem.Bounds = GetPointBounds(Points)
  $aShapes.Add(hItem)
  $aShapeNames.Add(Key)
  
End

Public Sub AddPolyLine(Key As String, Points As MapPoint[], Optional {Color} As Integer, Optional LineWidth As Integer) As _ShapeItem
  
  Dim hItem As _ShapeItem
  
  If $aShapeNames.Exist(Key) Then Error.Raise("This key already exist")
  hItem = New _ShapeItem(Key) As "Item"
  If Not IsMissing({Color}) Then hItem.Color = Color
  If Not IsMissing(LineWidth) Then hItem.LineWidth = LineWidth
  hItem.Type = Polyline
  hItem.Center = GetCenter(Points)
  hItem.Bounds = GetPointBounds(Points)
  hItem.Points = Points
  $aShapes.Add(hItem)
  $aShapeNames.Add(Key)
  
  Return hItem

End

Public Sub AddPolygon(Key As String, Points As MapPoint[][], Optional {Color} As Integer, Optional LineWidth As Integer) As _ShapeItem
  
  Dim hItem As _ShapeItem
  
  If $aShapeNames.Exist(Key) Then Error.Raise("This key already exist")
  hItem = New _ShapeItem(Key) As "Item"
  If Not IsMissing({Color}) Then hItem.Color = Color
  If Not IsMissing(LineWidth) Then hItem.LineWidth = LineWidth
  hItem.Type = Polygon
  hItem.Center = GetCenter(Points[0])
  hItem.Bounds = GetPointBounds(Points[0])
  hItem.Points = Points
  $aShapes.Add(hItem)
  $aShapeNames.Add(Key)
  
  Return hItem
  
End

Public Sub AddCircle(Key As String, Center As MapPoint, Radius As Float, Optional {Color} As Integer, Optional LineWidth As Integer) As _ShapeItem

  Dim hItem As _ShapeItem
  Dim P1, P2, P3, P4 As MapPoint
  If $aShapeNames.Exist(Key) Then Error.Raise("This key already exist")
  hItem = New _ShapeItem(Key) As "Item"
  If Not IsMissing({Color}) Then hItem.Color = Color
  If Not IsMissing(LineWidth) Then hItem.LineWidth = LineWidth
  hItem.Type = Circle
  hItem.Center = Center
  
  P1 = MapPoint.From(Center, 0, Radius)
  P2 = MapPoint.From(Center, 90, Radius)
  P3 = MapPoint.From(Center, 180, Radius)
  P4 = MapPoint.From(Center, 270, Radius)  
  
  hItem.Bounds.TopLeft = MapPoint(P1.Lat, P4.Lon)
  hItem.Bounds.BottomRight = MapPoint(P3.Lat, P2.Lon)
  
  $aShapes.Add(hItem)
  $aShapeNames.Add(Key)
  
  Return hItem

End

Public Sub _Draw()
  
  Dim i, j As Integer
  Dim pt, pt2 As Point
  Dim hMap As Map = GetMap()
  Dim hPoly As Integer[]
  Dim iColor, iBack As Integer
  Dim hShape As _ShapeItem
  Dim iAlpha As Integer
  
  If $aShapes.Count = 0 Then Return
  For i = 0 To $aInView.Max
    
    hShape = $aShapes[$aInView[i]]
    'Set ForeColor
    iColor = IIf(hShape.Color = -1, $icolor, hShape.Color)
    iAlpha = Color.GetAlpha(icolor)
    iColor = Color.SetAlpha(icolor, Min(iAlpha + (255 - (255 * Me.Opacity)), 255))
    
    'SetBackColor
    iBack = IIf(hShape.FillColor = -1, $iFillColor, hShape.FillColor)
    If iBack = -1 Then iBack = Color.transparent
    'If hShape.Type = Circle Then Stop
    iAlpha = Color.GetAlpha(iBack)
    iBack = Color.SetAlpha(iBack, Min(iAlpha + (255 - (255 * Me.Opacity)), 255))
    
    'SetLineWidth
    Paint.LineWidth = IIf(hShape.LineWidth > -1, hShape.LineWidth, $iLineWidth)
    
'TODO: Allow to define color for selected item
    'Force Color for selected
    If hShape.Selected Then icolor = Color.White
    
    'Draw 
    Select Case hShape.Type
      Case Me.Point
        pt = Geo.MapPointToPixel(hShape.Points, hMap.zoom)
        If hShape.Image Then
          Paint.DrawImage(hShape.Image, pt.X - hMap.PixelBox.X - 16, pt.Y - hMap.PixelBox.Y - 32)
        Else
          Paint.DrawImage($himgPoint, pt.X - hMap.PixelBox.X - 16, pt.Y - hMap.PixelBox.Y - 32)
        Endif
        
      Case MultiPoint
        For j = 0 To hShape.Points.Max
          pt = Geo.MapPointToPixel(hShape.Points[j], hMap.zoom)
          If hShape.Image Then
            Paint.DrawImage(hShape.Image, pt.X - hMap.PixelBox.X - 16, pt.Y - hMap.PixelBox.Y - 32)
          Else
            Paint.DrawImage($himgPoint, pt.X - hMap.PixelBox.X - 16, pt.Y - hMap.PixelBox.Y - 32)
          Endif
        Next
        
      Case Polygon
        hPoly = New Integer[]
        For j = 0 To hShape.Points[0].Max
          pt = Geo.MapPointToPixel(hShape.Points[0][j], hMap.zoom)
          hPoly.Add(pt.x - hMap.PixelBox.X)
          hPoly.Add(pt.y - hMap.PixelBox.Y)
        Next
        Paint.LineWidth = hShape.LineWidth
        Paint.Brush = Paint.Color(iBack)
        Paint.Polygon(hPoly)
        Paint.fill(True)
        Paint.Brush = Paint.Color(icolor)
        Paint.Stroke
        
      Case Me.Polyline
        If hShape.Points.Count = 0 Then Continue
        pt = Geo.MapPointToPixel(hShape.Points[0], hMap.zoom)
        Paint.MoveTo(pt.x - hMap.PixelBox.X, pt.y - hMap.PixelBox.Y)
        For j = 1 To hShape.Points.Max
          pt = Geo.MapPointToPixel(hShape.Points[j], hMap.zoom)
          Paint.LineTo(pt.x - hMap.PixelBox.X, pt.y - hMap.PixelBox.Y)

        Next
        
        Paint.Brush = Paint.Color(icolor)
        Paint.Stroke
        
      Case Me.Circle
        pt = hMap.MapPointToPixelRel(hShape.Bounds.TopLeft)
        pt2 = hMap.MapPointToPixelRel(hShape.Bounds.BottomRight)
        Paint.Ellipse(pt.x, pt.y, pt2.x - pt.x, pt2.y - pt.y)
        Paint.Brush = Paint.Color(iBack)
        Paint.Fill(True)
        Paint.Brush = Paint.Color(icolor)
        Paint.Stroke
    End Select
    

    
  Next
  
End






Public Function _get(Key As String) As _ShapeItem

  Dim iRet As Integer
  iRet = $aShapeNames.Find(key)
  If iRet = -1 Then
    Return Null
  Else
    Return $aShapes[iRet]
  Endif
  
End

Private Function GetMap() As Map
  
  Return Object.Parent(Me)
  
End

Private Function Color_Read() As Integer
  
  Return $icolor
  
End

Private Sub Color_Write(Value As Integer)
  
  $icolor = Value
  
End

Static Public Function GetCenter(hPoints As MapPoint[]) As MapPoint

  
  Dim tmpA, A, Gx, Gy As Float
  Dim j, k As Integer
  'calcul du centre
  A = 0
  gx = 0
  Gy = 0
  For k = 0 To hPoints.Max
    j = IIf(k + 1 <= hPoints.Max, k + 1, 0)
    tmpA = (hPoints[k].Lon * hPoints[j].Lat) - (hPoints[j].Lon * hPoints[k].Lat)
    A += tmpA
    Gx += tmpA * (hPoints[k].Lon + hPoints[j].Lon)
    Gy += tmpA * (hPoints[k].Lat + hPoints[j].Lat)
  Next
  A = A / 2
  gx = gx / (6 * A) 
  gy = gy / (6 * A) 
  
  Return MapPoint(GY, GX)
Catch
  
End

Private Function GetPointBounds(hMapPoints As MapPoint[]) As MapBounds
  
  Dim hPoint As MapPoint
  Dim X, Y, X2, Y2 As Float
  
  X = hMapPoints[0].Lon
  Y = hMapPoints[0].Lat
  X2 = X
  Y2 = Y
  For Each hPoint In hMapPoints
    X = Min(hPoint.lon, X)
    Y2 = Min(hPoint.lat, Y2)
    X2 = Max(hPoint.lon, X2)
    Y = Max(hPoint.lat, Y)
  Next
  Return MapBounds(MapPoint(Y, X), MapPoint(Y2, X2))
  
End

Private Function Count_Read() As Integer
  
  Return $aShapes.Count
  
End

Public Sub Remove(Key As String)
  Dim iRet As Integer
  iRet = $aShapeNames.Find(key)
  If iRet = -1 Then Return
  $aShapeNames.Remove(iRet)
  $aShapes.Remove(iRet)
  Load
  
End

Public Sub Exist(Key As String) As Boolean
  
  Return $aShapeNames.Exist(Key)
  
End

Private Function Image_Read() As Image
  
  Return $himgPoint
  
End

Private Sub Image_Write(Value As Image)
  
  $himgPoint = Value
  
End

Public Sub Refresh()
  
  Dim hItem As _ShapeItem
  
  For Each hItem In $aShapes
    Select Case hItem.Type
        
      Case Me.Point
        hItem.Center = hItem.Points
        hItem.Bounds = MapBounds(hItem.Points, hItem.Points)
      Case Polyline, MultiPoint
        hItem.Center = GetCenter(hItem.Points)
        hItem.Bounds = GetPointBounds(hItem.Points)
      Case Polygon
        hItem.Center = GetCenter(hItem.Points[0])
        hItem.Bounds = GetPointBounds(hItem.Points[0])

    End Select
  Next
  
End

Private Function Max_Read() As Integer
  
  Return $aShapes.Max
  
End

Public Function GetSelected() As _ShapeItem[]
  
  Dim aShapeItem As New _ShapeItem[]
  Dim i As Integer
  
  For i = 0 To $aShapes.Max
    If $aShapes[i].Selected Then aShapeItem.Add($aShapes[i])
  Next
  
  Return aShapeItem
  
End

Public Sub UnselectAll()
  
  Dim i As Integer
  
  For i = 0 To $aShapes.Max
    $aShapes[i].Selected = False
  Next
  
End

Public Sub SelectAll()
  
  Dim i As Integer
  
  For i = 0 To $aShapes.Max
    $aShapes[i].Selected = True
  Next
  
End

Public Sub Item_Select()
  
  If $sLastKey <> Last.key Then 
    Try Me._get($sLastKey).Selected = False
    
    $sLastKey = Last.Key
  Endif
  
End

Private Function Key_Read() As String
  
  Return $sLastKey
  
End

Public Function Find(hMp As MapPoint) As _ShapeItem
  
  Dim i As Integer
  Dim hShape As _ShapeItem
  Dim hMap As Map = GetMap()
  'Optimize by just looking in the view zone
  If hMap.Bounds.InBounds(hMp) Then 
    For i = 0 To $aInView.Max
      hShape = $aInView[i]
      If hShape.Type = Me.Point Then
        If hShape.Near(hMp, hMap.Zoom, 10) Then Return hShape
      Else
        If hShape.Contains(hMp) Then Return hShape
      Endif
    Next
  Else
    For i = 0 To $aShapes.Max
      hShape = $aShapes[i]
      If hShape.Type = Me.Point Then
        If hShape.Near(hMp, hMap.Zoom, 10) Then Return hShape
      Else
        If hShape.Contains(hMp) Then Return hShape
      Endif
    Next
    
  Endif
  
End

Public Sub Clear()
  
  $aShapes.Clear
  $aShapeNames.Clear
  
End

Private Function LineWidth_Read() As Integer
  
  Return $iLineWidth
  
End

Private Sub LineWidth_Write(Value As Integer)
  
  $iLineWidth = Max(Value, 1)
  
End

Private Function FillColor_Read() As Integer

  Return $iFillColor

End

Private Sub FillColor_Write(Value As Integer)

  $iFillColor = Value

End
