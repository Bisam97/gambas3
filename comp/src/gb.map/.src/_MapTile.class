' Gambas class file

Inherits _MapLayer
Private $aClients As New HttpClient[]
Private $iClientCount As Integer = 4
Private $sCachePath As String = User.Home &/ ".cache/gb.map"
Private $tmrGet As New Timer As "tmrGet"
Private $aTiles As New String[]
Private $colTiles As New Collection
Public $aStack As New String[]
Private $sPattern As String
Private $aSubDomains As String[] = ["a", "b", "c"]
Property SubDomains As String[]
Property Opacity As Float
Private $fOpacity As Float = 1
Private $aPreload As New String[]
Private $bPreloadMode As Boolean
Private $fGradStep As Float = 0.1
Private $bIsQuadKey As Boolean
Event Refresh

Public Sub _new(Optional CacheName As String)
  
  Dim sTempPath As String
  Dim hClient As HttpClient
  Dim i As Integer
  
  If CacheName Then
    sTempPath = $sCachePath &/ CacheName 
  Else
    sTempPath = Temp() 
  Endif
  
  If Not Exist(sTempPath) Then
    If MakeDir(sTempPath) Then Error.Raise("Cannot create Cache Path: \n" & sTempPath)
  Endif
  $sCachePath = sTempPath
  
  $aClients.Resize($iClientCount)
  For i = 0 To $aClients.Max
    hClient = New HttpClient As "Client"
    hClient.Async = True
    $aClients[i] = hClient
    'hClient.Timeout = 1
  Next
  
  
End
' svn checkout --username=gambix svn+ssh://gambas@svn.code.sf.net/p/gambas/code/gambas/trunk
' 
' 
Public Sub ClearCache()
  
  Try Exec ["rm", $sCachePath &/ "*.png"]
  
End

Public Sub _Draw()
  
  Dim s As String
  Dim hTile As _Tile
  Dim hMap As Map = GetMap()
  
  For Each s In $aTiles
    hTile = $coltiles[s]
    Select Case hTile.Status
      Case _Tile.Normal
        If hmap._ShowWithEffect Then
        Try Paint.DrawImage(hTile.Image, hTile.X * 256 - hMap.PixelBox.X, hTile.Y * 256 - hMap.PixelBox.Y,,, Min(hTile.Opacity, $fOpacity))
        
        If hTile.Opacity < $fOpacity Then 
          hTile.Opacity += $fGradStep
          Raise Refresh
        Endif
        Else
          Try Paint.DrawImage(hTile.Image, hTile.X * 256 - hMap.PixelBox.X, hTile.Y * 256 - hMap.PixelBox.Y,,, $fOpacity)
        Endif
        
        'Draw.Foreground = Color.Green
        'Draw.Text("TileOK", hTile.X * 256 - hMap.PixelBox.X, hTile.Y * 256 - hMap.PixelBox.Y)
      Case _Tile.Error
        Paint.Brush = Paint.Color(Color.SetAlpha(Color.White, Min(125, (255 * $fOpacity))))
        Paint.Rectangle(hTile.X * 256 - hMap.PixelBox.X, hTile.Y * 256 - hMap.PixelBox.Y, 256, 256)
        Paint.Fill
        'Draw.Image(Picture["icon:/256/cancel"].Image, hTile.X * 256 - hMap.PixelBox.X, hTile.Y * 256 - hMap.PixelBox.Y)
      Case _Tile.Loading
        ' Draw.Foreground = Color.Red
        ' Draw.Font.Bold = True
        ' Draw.Text("Loading: " & hTile.x & " / " & hTile.y, hTile.X * 256 - hMap.PixelBox.X, hTile.Y * 256 - hMap.PixelBox.Y)
    End Select
    
  Next
  
End

Public Sub Load()
  
  Dim ptFirst, ptLast As Point
  Dim hMap As Map = GetMap()
  Dim iX, iY As Integer
  Dim hTile As New _Tile
  Dim sTileName As String
  Dim aTileOrder As New String[]
  Dim iDist As Integer
  Dim ptTileCenter As Point
  Dim ars As String[]
  Dim mpFirst As MapPoint
  Dim mpLast As MapPoint
  
  mpFirst = Geo.PixelToMapPoint(Point(hMap.PixelBox.x, hMap.PixelBox.y), hmap.Zoom)
  mpLast = Geo.PixelToMapPoint(Point(hMap.PixelBox.Right, hMap.PixelBox.Bottom), hmap.Zoom)
  ptTileCenter = Geo.MapPointToTile(hMap.Center, hMap.Zoom)
  ptFirst = Geo.MapPointToTile(mpFirst, hmap.Zoom)
  ptLast = Geo.MapPointToTile(mpLast, hmap.Zoom)
  
  $aPreload.Clear
  
  For iX = ptFirst.X - 1 To ptLast.X + 1
    For iY = ptFirst.Y - 1 To ptLast.Y + 1
      iDist = Sqr((iX - ptTileCenter.X) ^ 2 + (iY - ptTileCenter.Y) ^ 2)
      aTileOrder.Add(Subst("&1/&2/&3", iDist, iY, iX))
    Next
  Next
  aTileOrder.Sort(gb.Descent)
  
  $aTiles.Clear
  '$aStack.Clear
  'ptTileCenter = Geo.MapPointToTile(hMap.Center, hMap.Zoom)
  'Print "Tile Center = " & ptTileCenter.x & "   " & ptTileCenter.Y
  For Each sTileName In aTileOrder
    ars = Split(sTileName, "/") 
    iY = CInt(ars[1])
    iX = CInt(ars[2])
    sTileName = Subst("&1-&2-&3.png", hMap.Zoom, iY, iX)
    If Not $coltiles.Exist(sTileName) Then
      hTile = New _Tile
      hTile.X = iX
      hTile.Y = iY
      hTile.Z = hMap.Zoom
      hTile.Name = sTileName
      If Exist($sCachePath &/ hTile.Name) Then 
        hTile.Status = _Tile.Normal
        Try hTile.Image = Image.Load($sCachePath &/ hTile.Name)
        If Error Then 
          'Error "Image illisible  -> " & hTile.Name
          ReLoadTile(hTile)
        Else
          hTile.Opacity = $fOpacity
        Endif
      Else
        hTile.Status = _Tile.Loading
        'Debug "loading of : " & hTile.Name
        If Not $aStack.Exist(hTile.Name) Then
          $aStack.Push(hTile.Name)
          $aStack.Push(GetTileUrl(hTile))
        Endif
      Endif
      
      $coltiles[hTile.Name] = hTile
      
    Else
      hTile = $coltiles[sTileName]
      ' If hTile.Status = _Tile.Loading Then
      '   hTile.TryCount = 0
      '   ReLoadTile(hTile)
      ' Endif
    Endif 
    
    $aTiles.Add(sTileName)
  Next
  
  'Loading of uppers tiles
  If hmap.Zoom > 1 Then
    ptFirst = Geo.MapPointToTile(mpFirst, hmap.Zoom - 1)
    ptLast = Geo.MapPointToTile(mpLast, hmap.Zoom - 1)
    For iX = ptFirst.X To ptLast.X 
      For iY = ptFirst.Y To ptLast.Y 
        sTileName = Subst("&1-&2-&3.png", hMap.Zoom - 1, iY, iX)
        If Exist($sCachePath &/ sTileName) Then Continue
        $aPreload.Push(sTileName)
        $aPreload.Push(GetTileUrlpt(iX, iY, hMap.Zoom - 1))
      Next
    Next
  Endif
  If hmap.Zoom < 18 Then
    ptFirst = Geo.MapPointToTile(mpFirst, hmap.Zoom + 1)
    ptLast = Geo.MapPointToTile(mpLast, hmap.Zoom + 1)
    For iX = ptFirst.X To ptLast.X 
      For iY = ptFirst.Y To ptLast.Y 
        sTileName = Subst("&1-&2-&3.png", hMap.Zoom + 1, iY, iX)
        If Exist($sCachePath &/ sTileName) Then Continue
        $aPreload.Push(sTileName)
        $aPreload.Push(GetTileUrlpt(iX, iY, hMap.Zoom + 1))
      Next
    Next
  Endif
  
  $bPreloadMode = False
  $tmrGet.Trigger
  
End

Private Sub ReLoadTile(hTile As _Tile)
  
  If hTile.TryCount > 3 Then 
    hTile.Status = _Tile.Error
    $tmrGet.Trigger
    Raise Refresh
    Return
  Endif
  
  If Exist($sCachePath &/ hTile.Name) Then Kill $sCachePath &/ hTile.Name
  If Not $aStack.Exist(hTile.Name) Then
    hTile.Status = _Tile.Loading
    Inc hTile.TryCount
    'Error "rechargement de : " & hTile.Name
    
    $aStack.Push(hTile.Name)
    $aStack.Push(GetTileUrl(hTile))
    $bPreloadMode = False
  Endif
  $tmrGet.Trigger
  
End

Private Function MakeDir(Path As String) As Boolean
  
  Dim ars As String[]
  Dim sDir, s As String
  
  sDir = "/"
  
  ars = Split(Path, "/")
  For Each s In ars
    sDir &/= s
    If Not Exist(sDir) Then
      Mkdir sDir
    Endif
    
  Next
  
  If _MapTileCache.Debug Then Debug "Création du Dossier: " & sDir
  
Catch
  
  Return True
  
End

Private Function GetMap() As Map
  
  Return Object.Parent(Me)
  
End

Public Sub tmrGet_Timer()
  
  Dim sUrl, sFile As String
  Dim hClient As HttpClient
  
  Do
    
    If $bPreloadMode Then
      If $aPreload.Count = 0 Then Return
      hClient = GetClient()
      If Not hClient Then Return
      sUrl = $aPreload.Pop()
      sFile = $aPreload.Pop()
    Else
      If $aStack.count = 0 Then 
        $bPreloadMode = True
        Return
      Endif
      hClient = GetClient()
      If Not hClient Then Return
      sUrl = $aStack.Pop()
      sFile = $aStack.Pop()
    Endif
    
    hClient.Url = sUrl
    hClient.Tag = sFile
    hClient.Get(Null, $sCachePath &/ sFile)
    
  Loop
  
End

Private Sub GetClient() As HttpClient
  
  Dim i As Integer
  
  For i = 0 To $aClients.max
    If $aClients[i].Status = Net.Inactive Then Return $aClients[i]
  Next
  
End

Public Sub Client_Finished()
  
  Dim hTile As _Tile 
  
  'If Not $bPreloadMode Then
  hTile = $colTiles[Last.Tag]
  If Not hTile Then Goto Skip
  Try hTile.Image = Image.Load($sCachePath &/ hTile.Name)
  If Error Then 
    'Error "Image illisible  -> " & hTile.Name
    ReLoadTile(hTile)
    Return
  Endif
  hTile.Status = _Tile.Normal
  Raise Refresh
  'Endif
Skip:
  $tmrGet.Trigger
  'Debug "Fichier téléchargé et chargé: " & Last.Tag
  
End

Public Sub Client_Error()
  
  Dim hTile As _Tile
  
  'If Not $bPreloadMode Then
  hTile = $coltiles[Last.Tag]
  If Not hTile Then Goto Skip
  Debug "erreur : " & hTile.Name
  ReLoadTile(hTile)
  'Endif
Skip:
  $tmrGet.Trigger
  
End

Public Sub Refresh()
  
  Dim i As Integer
  
  $coltiles.Clear
  $aTiles.Clear
  $aStack.Clear
  $aPreload.Clear
  For i = 0 To $aClients.Max  
    $aClients[i].Stop
    Try Kill $sCachePath &/ $aClients[i].Tag
  Next
  
End

Private Function GetTileUrl(hTile As _Tile) As String
  
  Return GetTileUrlpt(hTile.X, hTile.Y, hTile.Z)
  
End

Private Function GetTileUrlpt(X As Integer, Y As Integer, Z As Integer) As String
  
  Dim sTemp As String
  If $bIsQuadKey Then
    sTemp = Replace($sPattern, "{q}", TileToQuadKey(X, Y, Z))
  Else
    sTemp = Replace($sPattern, "{x}", CStr(X))
    sTemp = Replace(sTemp, "{y}", CStr(Y))
    sTemp = Replace(sTemp, "{z}", CStr(Z))
  Endif
  sTemp = Replace(sTemp, "{s}", $aSubDomains[Round(Rnd(0, $aSubDomains.Max))])
  Return sTemp
  
End

Public Sub SetPattern(sPattern As String, Optional cArgs As Collection)
  
  Dim s As Variant
  
  $sPattern = sPattern
  
  If InStr($sPattern, "{q}") Then 
    $bIsQuadKey = True
  Else
    $bIsQuadKey = False
  Endif
  
  If cArgs Then
    For Each s In cArgs
      $sPattern = Replace($sPattern, "{" & cArgs.Key & "}", s)
    Next
  Endif
  
End

Private Function SubDomains_Read() As String[]
  
  Return $aSubDomains
  
End

Private Sub SubDomains_Write(Value As String[])
  
  $aSubDomains = Value
  
End

Public Function CountActiveClients() As Integer
  
  Dim i, j As Integer
  
  For i = 0 To $aClients.Max
    If $aClients[i].Status <> Net.Inactive Then Inc j
  Next
  Return j
  
End

Private Function TileToQuadKey(X As Integer, Y As Integer, Z As Integer) As String
  
  
  Dim quadKey As String
  Dim i, digit, mask As Integer


    For i = z To 1 Step -1
    digit = 0
    mask = Lsl(1, (i - 1))
    If (x And mask) <> 0 Then digit += 1
    If (y And mask) <> 0 Then digit += 2
    quadKey &= digit
    
     Next
    Return quadKey
End


Private Function Opacity_Read() As Float

  Return $fOpacity

End

Private Sub Opacity_Write(Value As Float)

  $fOpacity = Min(1, Max(0, Value))
  $fGradStep = $fOpacity / 10

End

Public Sub _free()
  Dim hClient As HttpClient
  For Each hClient In $aClients
    hClient.Stop
    
  Next
  $aClients.Clear
End

