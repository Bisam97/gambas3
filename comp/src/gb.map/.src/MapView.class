' Gambas class file

Export
Inherits UserControl

Public Const _Properties As String = "*,Border{Border.*}"
Public Const _Group As String = "View"

Private $hCenter As MapPoint
Private $hMap As New Map As "Map"
Private $hView As DrawingArea
Private $hPan As New Panel(Me)
Private hWatch As New Watcher(Me) As "Watcher"
Private $pCurCenterPx As Point
Private $iX As Integer
Private $iY As Integer
Property Lock As Boolean
Property Border As Integer
Private $bLock As Boolean
Property Read {Map} As Map
Private $hZoomBuffer As New Image
Private $bZoomEffect As Boolean
Private $tmrZoom As New Timer As "tmrZoom"
Private $tmrOnMove As New Timer As "tmrOnMove"
Private $fZoomEffect As Float = 1
Private $ZX As Integer
Private $ZY As Integer
Private $iZoomWay As Integer
Private $fZoomStep As Float
Private $iSpeedX As Integer
Private $iSpeedY As Integer
Private $fInertia As Float = 0.9
Private $bShowInertia As Boolean
Private $tX As Integer
Private $tY As Integer
Event Click
Event Draw

Public Sub _new()
  
  $hPan.Arrangement = Arrange.Fill
  $hView = New DrawingArea($hPan) As "View"
  Me.Proxy = $hView
  $hMap.resize($hView.ClientW, $hView.ClientH)
  $hmap._ShowWithEffect = True
  $hView.Tracking = True
  $hView.Padding = True
  $hView.Background = Color.DarkGray
  $tmrZoom.Delay = 30
  $tmrOnMove.Delay = 30
  
  '$hmap.Padding = 256
  
End

Public Sub SetCenter(hMapPoint As MapPoint)
  
  $hCenter = hMapPoint
  
End

Private Function Map_Read() As Map
  
  Return $hMap
  
End

Public Sub View_Draw()
  

  
  If Not $bZoomEffect Then 

    If $iZoomWay <> 0 Then 
    Paint.DrawImage($hZoomBuffer, 0, 0)
    Endif
    $hMap.Draw
    Raise Draw
  Else
    If $iZoomWay = 1 Then

      Paint.DrawImage($hZoomBuffer, ($ZX - $ZX * $fZoomEffect), ($ZY - $ZY * $fZoomEffect), $hZoomBuffer.Width * $fZoomEffect, $hZoomBuffer.Height * $fZoomEffect)
      $fZoomEffect += 0.1
      If $fZoomEffect < 2 Then 

      Else
        $bZoomEffect = False
        Draw.Begin($hZoomBuffer)
        Paint.DrawImage($hZoomBuffer, ($ZX - $ZX * $fZoomEffect), ($ZY - $ZY * $fZoomEffect), $hZoomBuffer.Width * $fZoomEffect, $hZoomBuffer.Height * $fZoomEffect)
        Draw.End
        $fZoomEffect = 1
        $tmrZoom.Stop
        $tmrZoom.Trigger
      Endif
    Else
      Paint.DrawImage($hZoomBuffer, (Paint.Width - $hZoomBuffer.Width * $fZoomEffect) / 2, (Paint.Height - $hZoomBuffer.Height * $fZoomEffect) / 2, $hZoomBuffer.Width * $fZoomEffect, $hZoomBuffer.Height * $fZoomEffect)
      $fZoomEffect -= 0.04
      If $fZoomEffect > 0.5 Then 
        '$tmrZoom.Trigger
      Else
        $bZoomEffect = False
        Draw.Begin($hZoomBuffer)
        Paint.DrawImage($hZoomBuffer, (Paint.Width - $hZoomBuffer.Width * $fZoomEffect) / 2, (Paint.Height - $hZoomBuffer.Height * $fZoomEffect) / 2, $hZoomBuffer.Width * $fZoomEffect, $hZoomBuffer.Height * $fZoomEffect)
        Draw.End
        $fZoomEffect = 1
        $tmrZoom.Stop
        $tmrZoom.Trigger
      Endif
    Endif
  Endif
  
End


Public Sub View_MouseWheel()
  
  Dim hpix As Point
  $ZX = Mouse.X 
  $ZY = Mouse.Y 
  Draw.Begin($hZoomBuffer)
    Draw.FillRect(0, 0, Draw.Width, Draw.Height, Color.Transparent)
    $hmap.Draw
  Draw.End
  
  $iZoomWay = Mouse.Delta
  
  $hMap.Zoom += Mouse.Delta
  
  hPix = New Point($hMap.PixelBox.X + Mouse.X, $hMap.PixelBox.Y + Mouse.Y)
  
  If Mouse.Delta > 0 Then $hMap.Center = Geo.PixelToMapPoint(hpix, $hmap.Zoom) 'Mercator.MetersToMapPointFP(Mercator.PixelsToMetersP(hpix, $hMap.Zoom))
  
  If $hmap.Zoom > 1 And If $hmap.Zoom <= 18 Then $bZoomEffect = True
  $tmrZoom.Start
  $hView.Refresh
  
End

Public Sub Map_Refresh()
  
  $hView.Refresh
  
End

Public Sub View_MouseDown()
  
  $hView.Mouse = Mouse.Pointing
  $iX = Mouse.X 
  $iY = Mouse.Y 
  $pCurCenterPx = Geo.MapPointToPixel($hmap.Center, $hmap.Zoom) 
  $bShowInertia = False
  $tmrOnMove.Stop 
  Raise MouseDown
  
End

Public Sub View_MouseUp()
  
  Last.Mouse = Mouse.Default
   If Abs($iSpeedx) > 4 Or If Abs($iSpeedY) > 4 Then $tmrOnMove.Start

  Raise MouseUp
  
End

Public Sub View_MouseMove()
  
  Dim hPix As Point
  
  If Mouse.Left And Not $bLock Then
    
    hPix = New Point($pCurCenterPx.X, $pCurCenterPx.Y)
    
    $iSpeedX = $tx - Mouse.X
    $iSpeedY = $ty - Mouse.y

    hPix.X += $ix - Mouse.X
    hPix.Y += $iY - Mouse.Y
    $hmap.Center = Geo.PixelToMapPoint(hpix, $hmap.Zoom)
    $iZoomWay = 0
    $hView.Refresh
  Endif
  $tx = Mouse.X
  $ty = Mouse.y

  Raise MouseMove
  
End

Public Sub View_Arrange()
  
  $hMap.Resize($hView.ClientW, $hView.ClientH)
  $hZoomBuffer.Resize($hView.ClientW, $hView.ClientH)
  $iZoomWay = 0
  $hmap.Refresh
  $hView.Refresh
  
End

Private Function Lock_Read() As Boolean
  
  Return $bLock
  
End

Private Sub Lock_Write(Value As Boolean)
  
  $bLock = Value
  
End

Public Sub Refresh()
  
  $hView.Refresh
  
End

Private Function Border_Read() As Integer
  
  Return $hPan.Border
  
End

Private Sub Border_Write(Value As Integer)
  
  $hPan.Border = Value
  
End

Public Sub tmrZoom_Timer()
  
  'Wait 3
  $hView.Refresh
  
End

Public Sub tmrOnMove_Timer()
  Dim hpix As Point
  'Print "triger"
hPix = Geo.MapPointToPixel($hmap.Center, $hmap.Zoom)
  $iSpeedX *= $fInertia
  $iSpeedY *= $fInertia
  
  If Abs($iSpeedX) < 1 Or If Abs($iSpeedY) < 1 Then 
    $tmrOnMove.stop
    $bShowInertia = False
  Endif

  hPix.X += $iSpeedX
    hPix.Y += $iSpeedY
    $hmap.Center = Geo.PixelToMapPoint(hpix, $hmap.Zoom)
  $hView.Refresh

End
