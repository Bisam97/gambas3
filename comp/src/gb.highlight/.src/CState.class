' Gambas class file

Static Public Path As String
Static Public Keywords As New String[]

Static Private $iIndent As Integer
Static Private $sLastCode As String

Static Private $cState As New Collection
Static Private $aStateName As New String[]

Static Private $aLabel As New String[]
Static Private $cTitle As New Collection

Static Private $aInclude As New String[]

Static Private $cSubst As New Collection

Public Name As String
Public ColorIndex As Integer
Public Indent As Integer
Public Parent As CState
Public Commands As New CCommand[]
Public Children As New CState[]

Private $iCurrentCommand As Integer
Private $iCurrentChild As Integer
Private $sContinue As String

Static Public Sub Init(sPath As String)
  
  Path = sPath
  $cSubst.Clear
  $cState.Clear
  $aStateName.Clear
  $aLabel.Clear
  $cTitle.Clear
  $aInclude.Clear
  Keywords.Clear
  
End

Static Public Sub Subst(sValue As String) As String
  
  Dim sReplace As String
  
  If InStr(sValue, "$(") = 0 Then Return sValue
  
  For Each sReplace In $cSubst
    sValue = Replace(sValue, "$(" & $cSubst.Key & ")", sReplace)
  Next
  
  Return sValue
  
End


Static Public Sub Define(sVar As String, sValue As String)
  
  $cSubst[sVar] = Me.Subst(sValue)
  
End


Public Sub _new(Optional sLine As String)
  
  Dim iPos As Integer
  Dim sColor As String
  
  If Not sLine Then Return
  
  If sLine Ends "}" Then
    iPos = InStr(sLine, "{")
    If iPos = 0 Then Error.Raise("Syntax error")
    sColor = Mid$(sLine, iPos + 1, -1)
    sLine = Left(sLine, iPos - 1)
  Else
    sColor = String.UCaseFirst(sLine)
  Endif
  
  If sLine Not Match "[A-Za-z][A-Za-z0-9.]*" Then Error.Raise("Incorrect character in state name")
  Name = Replace(sLine, ".", "_")
  
  ColorIndex = TextHighlighterTheme._Register(sColor)
  
  ' If sTitle Then 
  '   sCurrent = $cTitle[Name]
  '   If Not sCurrent Then
  '     $cTitle[Name] = sTitle
  '   Else If sCurrent <> sTitle Then
  '     Error.Raise("Ambiguous state display name")
  '   Endif
  ' Endif
  
End

Public Sub AddCommand(sText As String)

  Dim hCommand As CCommand
  Dim iPos As Integer
  Dim sCommand As String
  Dim aArg As String[]
  Dim I As Integer
  
  iPos = InStr(sText, " ")
  If iPos = 0 Then Return
  
  sCommand = Left(sText, iPos - 1)
  
  Try hCommand = Object.New("CCommand" & UCase(Left(sCommand)) & Mid$(sCommand, 2))
  If Error Then Error.Raise("Unknown command: " & sCommand)
  
  aArg = Split(Mid$(sText, iPos + 1), " ", "", True)
  For I = 0 To aArg.Max
    aArg[I] = CState.Subst(aArg[I])
  Next
  
  hCommand.SetArgs(aArg)
  hCommand.Init()
  Commands.Add(hCommand)
  
End

Static Public Sub Print(Optional sCode As String)
  
  sCode = Trim(sCode)
  
  If Not sCode Then
    If $sLastCode Then
      Print
      $sLastCode = ""
    Endif 
    Return
  Endif
  
  If sCode = "Loop" Or If sCode = "Endif" Or If sCode = "Next" Or If sCode = "End" Or If sCode Ends ":" Or If sCode = "Catch" Then 
    Dec $iIndent
  Endif
  
  'Print #File.Out, Space($iIndent * 2); sCode
  Print Space($iIndent * 2); sCode
  $sLastCode = sCode
  
  Do
    If sCode Begins "Static " Or If sCode Begins "Private " Or If sCode Begins "Public " Then
      sCode = Mid$(sCode, InStr(sCode, " ") + 1)
    Else 
      Break 
    Endif
  Loop 
  
  If sCode = "Do" Or If sCode Begins "For " Or If sCode Begins "Sub " Or If sCode Ends ":" Or If sCode = "Catch" Then
    Inc $iIndent
  Else If sCode Begins "If " And If sCode Ends "Then" Then
    Inc $iIndent
  Endif
  
End

Static Public Sub IfStartWith(sStr As String, Optional sLabel As String)
  
  If sLabel Then
    Print("If Mid$($sText, $iPos, " & CStr(Len(sStr)) & ") <> " & Quote(sStr) & " Then Goto " & sLabel)
  Else
    Print("If Mid$($sText, $iPos, " & CStr(Len(sStr)) & ") = " & Quote(sStr) & " Then")
  Endif
  
End

Static Public Sub Peek(sLen As String) As String
  
  Return "Mid$($sText, $iPos, " & sLen & ")"
  
End

Static Public Sub PrintLabel(sLabel As String, Optional bNoState As Boolean) As String
  
  If Not bNoState Then
    If $aLabel.Count = 256 Then Error.Raise("Highlight too complex")
    $aLabel.Add(sLabel)
  Endif

  Print()
  Print(sLabel & ":")
  If Not bNoState Then Print("aState[0] = " & CStr($aLabel.Max))
  Print()
  
End

Public Sub Forward(Optional sLen As String)
  
  If sLen And If sLen <> "1" Then
    Print("Forward(" & CStr(ColorIndex) & ", " & sLen & ")")  
  Else 
    Print("Forward(" & CStr(ColorIndex) & ")")
  Endif
  
End

Public Sub GetLabel() As String

  Dim sLabel As String
  
  If Not Name Then 
    sLabel = "STATE_$"
  Else
    If Parent Then
      sLabel = Parent.GetLabel()
    Else 
      sLabel = "STATE"
    Endif
    If Name = "*" Then
      sLabel &= "_$"
    Else
      sLabel &= "_" & UCase(Name)
    Endif
  Endif 
  
  If $iCurrentCommand > 0 Then sLabel &= "_" & CStr($iCurrentCommand)
  
  Return sLabel
  
End

Public Sub GetNextLabel() As String
  
  Dim sLabel As String
  Dim iSaveCurrentCommand As Integer
  
  If $iCurrentCommand >= Commands.Count Then
    iSaveCurrentCommand = $iCurrentCommand
    $iCurrentCommand = 0
    sLabel = GetLabel() & "_$END"
    $iCurrentCommand = iSaveCurrentCommand
  Else If $iCurrentCommand > 0 Then
    Inc $iCurrentCommand
    sLabel = GetLabel()
    Dec $iCurrentCommand
  Else If $iCurrentChild = Children.Count Then
    sLabel = GetLabel() & "_$END"
  Else If $iCurrentChild Then
    sLabel = GetLabel()
  Endif
  
  Return sLabel
  
End


Public Sub Continue()
  
  If $sContinue Then
    Print("Goto " & $sContinue)
  Else
    Print("Goto " & Parent.GetLabel())
  Endif
  
End

Public Sub Compile(Optional sContinue As String)
  
  Dim hChild As CState
  Dim I As Integer
  'Dim sOldContinue As String
  
  If Commands.Count Then
  
    'sOldContinue = $sContinue
    $sContinue = sContinue
    For I = 0 To Commands.Max
      Inc $iCurrentCommand
      PrintLabel(GetLabel())
      Commands[I].Compile(Me)
    Next
    '$sContinue = sOldContinue
    $iCurrentCommand = 0
    PrintLabel(GetLabel() & "_$END")
    
  Else
    
    PrintLabel(GetLabel())
    Print()
  
    Print("If IgnoreSpaces() Then Goto " & GetLabel() & "_$END")

    Print("If $sTextLimit Then")
      Print("If $bMatchLimit Then")
        Print("If Match($sTextLimit) Then")
          Print("aState.Remove(0)")
          Print("Return")
        Print("Endif")
      Print("Else")
        Print("If $sTextLimit And If Mid$($sText, $iPos) Begins $sTextLimit Then")
          Print("aState.Remove(0)")
          Print("Return")
        Print("Endif")
      Print("Endif")
    Print("Endif")
  
    CompileChildren()
    
    PrintLabel(GetLabel() & "_$END", True)
    Print("aState[0] = 0")
    Print("If $bEof Then Return")
    Print()
    Print("Forward(0)")
    Print("Goto " & GetLabel())
    
  Endif
  
  For Each hChild In Children
    hChild.Parent = Null
  Next
  
End

Public Sub CompileChildren(Optional bElse As Boolean)

  Dim hState As CState
  Dim sLabel As String
  
  If Name = "*" Then
    Print("Compile(aState)")
    Return
  Endif
  
  If bElse Then sLabel = GetLabel() & "_LOOP"
  
  $iCurrentChild = 0
  For Each hState In Children
    Inc $iCurrentChild
    hState.Compile(sLabel)
  Next
  
  If bElse Then
    Print()
    Forward()
    Print("Goto " & sLabel)
  Endif
  
End

Public Sub AddChild(hChild As CState)
  
  Children.Add(hChild)
  hChild.Parent = Me
  
End

Static Public Sub GetStateNames() As String

  Dim I As Integer
  Dim aResult As String[]
  
  aResult = New String[]
  aResult.Add("\"*\"")
  For I = 0 To $aStateName.Max
    aResult.Add(Quote($aStateName[I]))
  Next
  
  Return "[" & aResult.Join(", ") & "]"
  
End

' Static Public Sub GetStateFromNames() As String
' 
'   Dim I As Integer
'   Dim aResult As New String[]
'   
'   For I = 0 To $aStateName.Max
'     aResult.Add(Quote($aStateName[I]) & ": " & CStr(I + 1))
'   Next
'   
'   Return "[" & aResult.Join(", ") & "]"
'   
' End
' 
Static Public Sub GetLabels() As String[]
  
  Return $aLabel
  
End

Static Public Sub GetKeywords() As String
  
  Dim aResult As New String[]
  Dim I As Integer
  
  For I = 0 To Keywords.Max
    aResult.Add(Quote(Keywords[I]))
  Next
  
  Return "[" & aResult.Join(", ") & "]"
  
End

Static Public Sub AddInclude(sInclude As String) As Integer
  
  $aInclude.Add(sInclude)
  Return $aInclude.Count
  
End
