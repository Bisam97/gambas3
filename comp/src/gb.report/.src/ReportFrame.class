' Gambas class file

Export
Create Private
Inherits ReportControl
Static Private iLevel As Integer
Public Const _Properties As String = "*,Border,Background{ReportBrush}"

' Private $fLeftBorderWidth As Float
' Private $fRightBorderWidth As Float
' Private $fTopBorderWidth As Float
' Private $fBottomBorderWidth As Float

Private $hBorder As New ReportBorder

Private $hBackGround As ReportBrush

Property Border As ReportBorder

Property BackGround As ReportBrush
'Property Read _BorderWidth As Float

Private Function Border_Read() As ReportBorder

  Return $hBorder

End

Private Sub Border_Write(Value As ReportBorder)

  $hBorder = Value

End

Public Sub _PaintBefore(Page As Integer, X As Float, Y As Float, hControl As TControl, VirtualId As Integer)

  Dim X1, Y1, X2, Y2 As Float
  Dim hImage As Picture
  Dim fradius As Float

  'If Me.tag = "*" Then Stop

  X1 = (x + hControl.RealLeft)
  Y1 = (y + hControl.RealTop)
  X2 = (x + hControl.RealLeft + hControl.RealWidth)
  Y2 = (y + hControl.RealTop + hControl.RealHeight)
  'Clipping
  paint.save

  ' Print String(iLevel, " ") & "sauvé"
  ' Inc iLevel
  ' Paint.Rectangle(X1, Y1, X2 - X1, Y2 - Y1)
  ' paint.Clip(True)

  If Report.Debug Then

    Paint.Brush = Paint.Color(Color.Green)
    'Paint.Dash = MTools.GetBorder(Line.Dot)
    Paint.Rectangle(X1, Y1, X2 - X1, Y2 - Y1)
    Paint.Stroke

  Else

    If $hBorder.RoundCorner._Active Then
      RoundRect(X1, Y1, hControl.RealWidth, hControl.RealHeight,
        [MTools.UnitsToPixels($hBorder.RoundCorner._TopLeft1),
        MTools.UnitsToPixels($hBorder.RoundCorner._TopRight1),
        MTools.UnitsToPixels($hBorder.RoundCorner._BottomRight1),
        MTools.UnitsToPixels($hBorder.RoundCorner._BottomLeft1)],
        [MTools.UnitsToPixels($hBorder.RoundCorner._TopLeft2),
        MTools.UnitsToPixels($hBorder.RoundCorner._TopRight2),
        MTools.UnitsToPixels($hBorder.RoundCorner._BottomRight2),
        MTools.UnitsToPixels($hBorder.RoundCorner._BottomRight2)])
    Else
      Paint.Rectangle(X1, Y1, X2 - X1, Y2 - Y1)
    Endif

    If Me.BackGround = Null Then
      paint.Clip
      Return
    Else
      paint.Clip(True)
    Endif
    paint.Brush = Me.BackGround._PaintBrush(X1, Y1, X2, Y2)

    Paint.Fill

  Endif

End

Public Sub _PaintFrame(Page As Integer, X As Float, Y As Float, hControl As TControl, VirtualId As Integer)

  _PaintBefore(Page, X, Y, hControl, VirtualId)
  Me._Paint(Page, X, Y, hControl, VirtualId)
  _PaintAfter(Page, X, Y, hControl, VirtualId)

End

Public Sub _PaintAfter(Page As Integer, X As Float, Y As Float, hControl As TControl, VirtualId As Integer)

  Dim X1, Y1, X2, Y2 As Float
  'Dim fWidth As Float

  Dim fTopWidth, fBottomWidth, fLeftWidth, fRighWidth As Float

  'Fin du clipping
  paint.Restore

  X1 = (x + hControl.RealLeft)
  Y1 = (y + hControl.RealTop)
  X2 = (x + hControl.RealLeft + hControl.RealWidth)
  Y2 = (y + hControl.RealTop + hControl.RealHeight)

  If $hBorder.RoundCorner._Active Then
    fLeftWidth = MTools.UnitsToPixels($hBorder._Left) / 2
    paint.LineWidth = fLeftWidth * 2
    paint.Brush = $hBorder.Left.Brush._PaintBrush(X1, Y1, X2, Y2)
    RoundRect(X1 + fLeftWidth, Y1 + fLeftWidth, hControl.RealWidth - fLeftWidth, hControl.RealHeight - fLeftWidth,
      [MTools.UnitsToPixels($hBorder.RoundCorner._TopLeft1),
      MTools.UnitsToPixels($hBorder.RoundCorner._TopRight1),
      MTools.UnitsToPixels($hBorder.RoundCorner._BottomRight1),
      MTools.UnitsToPixels($hBorder.RoundCorner._BottomLeft1)],
      [MTools.UnitsToPixels($hBorder.RoundCorner._TopLeft2),
      MTools.UnitsToPixels($hBorder.RoundCorner._TopRight2),
      MTools.UnitsToPixels($hBorder.RoundCorner._BottomRight2),
      MTools.UnitsToPixels($hBorder.RoundCorner._BottomRight2)])
    paint.Stroke

  Else
    fLeftWidth = MTools.UnitsToPixels($hBorder._Left)
    fRighWidth = MTools.UnitsToPixels($hBorder._Right)
    fTopWidth = MTools.UnitsToPixels($hBorder._Top)
    fBottomWidth = MTools.UnitsToPixels($hBorder._Bottom)

    'If $hBorder.Style <> Line.None Then

    'fWidth = MTools.UnitsToPixels($fBorderWidth)

    'Paint.Brush = Paint.Color($hBorder.Brush._iValue)

    If fTopWidth > 0 Then
      paint.Brush = $hBorder.Top.Brush._PaintBrush(X1, Y1, X2, Y2)
      paint.Rectangle(X1, Y1, X2 - X1, fTopWidth)
      paint.Fill
    Endif
    If fRighWidth > 0 Then
      paint.Brush = $hBorder.Right.Brush._PaintBrush(X1, Y1, X2, Y2)
      paint.Rectangle(X2 - fRighWidth, Y1, fRighWidth, Y2 - Y1)
      paint.Fill
    Endif
    If fBottomWidth > 0 Then
      paint.Brush = $hBorder.Bottom.Brush._PaintBrush(X1, Y1, X2, Y2)
      paint.Rectangle(X1, Y2 - fBottomWidth, X2 - X1, fBottomWidth)
      paint.Fill
    Endif
    If fLeftWidth > 0 Then
      paint.Brush = $hBorder.Left.Brush._PaintBrush(X1, Y1, X2, Y2)
      paint.Rectangle(X1, Y1, fLeftWidth, Y2 - Y1)
      paint.Fill
    Endif
  Endif
  'Dec iLevel
  'Print String(iLevel, " ") & "restoré"

  'Endif

End

Private Function BackGround_Read() As ReportBrush

  Return $hBackGround

End

Private Sub BackGround_Write(Value As ReportBrush)

  $hBackGround = Value

End

Public Sub _SetUnifiedValues()

  Dim hSizeParse As TSizeParse
  Dim sValue As String
  Dim ars As String[]

  Super._SetUnifiedValues()

  hSizeParse = New TSizeParse($hBorder.Left.Width)
  $hBorder._Left = hSizeParse.GetValue()
  hSizeParse = New TSizeParse($hBorder.Right.Width)
  $hBorder._Right = hSizeParse.GetValue()
  hSizeParse = New TSizeParse($hBorder.Top.Width)
  $hBorder._Top = hSizeParse.GetValue()
  hSizeParse = New TSizeParse($hBorder.Bottom.Width)
  $hBorder._Bottom = hSizeParse.GetValue()
  $hBorder.RoundCorner._SetUnifiedValues()

End

Public Sub _GetSizeHints(AvailableW As Float, AvailableH As Float, TotalWidth As Float, TotalHeight As Float) As TSizeHint

  Dim hMyHints As TSizeHint

  hMyHints = Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight)

  If hMyHints.Height <= 0 Then
    hMyHints.Height = Me.Padding._Top + Me.Padding._Bottom + Me.Border._Top + Me.Border._Bottom
  Endif

  If hMyHints.Width <= 0 Then
    hMyHints.Width = Me.Padding._Left + Me.Padding._Right + Me.Border._Left + Me.Border._Right
  Endif

  Return hMyHints

End

Private Sub RoundRect(x As Integer, y As Integer, w As Integer, h As Integer, Radius_X As Float[], radius_y As Float[])

  Dim ARC_TO_BEZIER As Float = 0.55228475
  Dim c1, c2 As Float
  Dim i As Integer

  For i = 0 To 3
    If radius_x[i] > w - radius_x[i] Then
      radius_x[i] = w / 2
    Endif

    If radius_y[i] > h - radius_y[i] Then
      radius_y[i] = h / 2
    Endif
  Next
  'approximate(quite Close )the arc using a bezier curve

  '        A**********B
  '       H            C
  '       *            *
  '       *            *
  '       G            D
  '        F**********E

  '-->A
  paint.moveto(x + radius_x[0], y)

  '-->B
  paint.rellineto(w - radius_x[0] - radius_x[1], 0.0)

  '-->C
  c1 = ARC_TO_BEZIER * radius_x[1]
  c2 = ARC_TO_BEZIER * radius_y[1]
  paint.relcurveto(c1, 0.0, radius_x[1], c2, radius_x[1], radius_y[1])

  '-->D
  paint.rellineto(0, h - radius_y[1] - radius_y[2])

  '-->E
  c1 = ARC_TO_BEZIER * radius_x[2]
  c2 = ARC_TO_BEZIER * radius_y[2]
  paint.relcurveto(0.0, c2, c1 - radius_x[2], radius_y[2], - radius_x[2], radius_y[2])

  '-->F
  paint.rellineto(- w + radius_x[2] + Radius_X[3], 0)

  '-->G
  c1 = ARC_TO_BEZIER * radius_x[3]
  c2 = ARC_TO_BEZIER * radius_y[3]
  paint.relcurveto(- c1, 0, - radius_x[3], - c2, - radius_x[3], - radius_y[3])
  '-->H
  paint.rellineto(0, - h + radius_y[3] + radius_y[0])

  '-->A
  c1 = ARC_TO_BEZIER * radius_x[0]
  c2 = ARC_TO_BEZIER * radius_y[0]
  paint.relcurveto(0.0, - c2, radius_x[0] - c1, - radius_y[0], radius_x[0], - radius_y[0])

  'paint.closepath()

End
