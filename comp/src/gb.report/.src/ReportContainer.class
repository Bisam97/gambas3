' Gambas class file

Export
Create Private
Inherits ReportFrame

Public Const _IsContainer As Boolean = True
Public Const _Group As String = "Container"
Public Const _Properties As String = "*,Spacing{ReportCoord}"
'Public Const _DefaultEvent As String = "Data"
Private $bDataIsResult As Boolean
'Private $iCount As Integer
Public _PageChildren As New Collection
Public _CurItem As Integer

Public _Arrangement As Integer

Private $aChild As New ReportControl[]
Private $fSpacing As Float
Private $sSpacing As String
Private $bRelativeSpacing As Boolean
Private $bRepeat As Boolean
Private $aChildCopy As TControl[]

Private $iIndex As Integer
Private $hData As Object
Private $fFixedSize As Integer

Property DataCount As Integer

Property Read Children As ReportControl[]
'Property Read Index As Integer
Property Spacing As String
'Property Data As Object  '<==== remettre pour automation

Property Read _Spacing As Float
Property Read _RelativeSpacing As Boolean

Public _RealSpacing As Integer
Static Private $iLevel As Integer
Event Data

Public Function _Add(cControl As ReportControl) 'As TControl

  'Dim hTControl As New TControl

  'hTControl.Ctrl = cControl
  $aChild.Add(cControl)
  ReportControl._ObjectFromId[cControl.Id] = cControl
  'Return hTControl

End

Public Sub _Remove(id As Integer)

  $aChild.Remove($aChild.Find(ReportControl._ObjectFromId[id]))

End

Public Sub _Free()

End

Private Function Children_Read() As ReportControl[]

  Return $aChild

End

Private Function Spacing_Read() As String

  Return $sSpacing

End

Private Sub Spacing_Write(Value As String)

  $sSpacing = Value

End

Public Sub _ClipChildren(Page As Integer, X As Float, Y As Float, hControl As TControl, VirtualId As Integer, fScale As Float)

  Dim hChild As TControl
  Dim vi As Integer

  Dim CX1, CX2, CY1, CY2 As Float
  Dim hCont As ReportContainer

  With Paint.ClipExtents
    CX1 = .X
    CY1 = .Y
    CX2 = .X2
    CY2 = .Y2
  End With

  X += hControl.RealLeft
  Y += hControl.RealTop

  For Each hChild In Me.Children
    vi = VirtualId
    If hControl.VirtualId > -1 Then vi = hControl.VirtualId

    hChild._SkipPainting = False

    If Not Paint.Device Is Printer And If CX2 > CX1 And If CY2 > CY1 Then
      If (X + hChild.RealLeft) > CX2 Then
        hChild._SkipPainting = True
        Continue
      Endif
      If (X + hChild.RealLeft + hChild.RealWidth) < CX1 Then
        hChild._SkipPainting = True
        Continue
      Endif
      If (Y + hChild.RealTop) > CY2 Then
        hChild._SkipPainting = True
        Continue
      Endif
      If (Y + hChild.RealTop + hChild.RealHeight) < CY1 Then
        hChild._SkipPainting = True
        Continue
      Endif
    Endif

    If hChild.RelPage >= 0 And If (hChild.RelPage + hControl.RealPage) <> Page Then
      hChild._SkipPainting = True
      Continue
    Endif

    If hChild.Ctrl Is ReportContainer Then
      hCont = hChild.Ctrl
      hCont._ClipChildren(Page, X, Y, hChild, vi, fScale)
    Endif

  Next

End

Public Sub _Paint(Page As Integer, X As Float, Y As Float, hControl As TControl, VirtualId As Integer)

  Dim hChild As TControl

  X += hControl.RealLeft
  Y += hControl.RealTop
  If Not Me._PageChildren.Exist(Page) Then Return
  Me._Index = hControl.Index
  For Each hChild In Me._PageChildren[Page]
    'Print object.Type(hchild.Ctrl), hControl.RelPage, hControl.RealPage + hchild.RelPage, Page - 1

    'If hchild.RelPage = -1 Or hControl.RealPage + hchild.RelPage = Page - 1 Then

    'Inc MTools.DrawCount

    '$iIndex = VirtualId
    'If hControl.VirtualId > -1 Then $iIndex = hControl.VirtualId

    hChild.Ctrl._Paintframe(Page, X, Y, hChild, $iIndex)

  Next

End

Private Function _Spacing_Read() As Float

  Return $fSpacing

End

Private Function _RelativeSpacing_Read() As Boolean

  Return $bRelativeSpacing

End

Public Sub _SetUnifiedValues()

  Dim hChild As ReportControl
  Dim hSizeParse As TSizeParse

  Super._SetUnifiedValues()

  hSizeParse = New TSizeParse($sSpacing, True)
  $fSpacing = hSizeParse.GetValue()
  $bRelativeSpacing = hSizeParse.IsRelative()

  For Each hChild In $aChild
    'hchild.SizeHint = Null
    hChild._SetUnifiedValues()
  Next

End

Public Sub _GenerateClones()

  Dim hTControl, hNewTControl, hTc As TControl
  Dim o As Object
  Dim i As Integer
  Dim hCont As ReportContainer
  Dim aNewChild As TControl[]
  Dim bRaiseRet As Boolean
  Dim aCopy As TControl[]

  If $aChildCopy Then
    $aChild = $aChildCopy.Copy()
  Endif
  aCopy = $aChild.Copy()

  For Each hTc In aCopy
    If hTc.Ctrl Is ReportContainer Then
      hCont = hTc.Ctrl
      If hCont.Data Then
        aNewChild = New TControl[]

        For i = 0 To hCont.Data.Count - 1

          hNewTControl = New TControl
          hNewTControl.Ctrl = hTc.Ctrl
          hNewTControl.VirtualId = i
          aNewChild.Add(hNewTControl)

        Next
        $aChild = $aChild.Insert(aNewChild, $aChild.Find(hTc))
        $aChild.Remove($aChild.Find(hTc))

      Endif
      hCont._GenerateClones
    Endif
  Next
  If $aChild.Count <> aCopy.Count Then $aChildCopy = aCopy

End

Public Sub pause()

  ' '********************************************************
  ' If _Arrangement = Arrange.Fill Then
  '   '*******************************************************
  '
  '   fPdg = Me._Padding
  '
  '   X = fPdg
  '   Y = fPdg
  '   W -= fPdg * 2
  '   H -= fPdg * 2
  '
  '   For Each hChild In Me.Children
  '     If hChild.Ctrl.Ignore Then
  '       aIgnored.Add(hChild)
  '       Continue
  '     Endif
  '     hChildHints = hChild.ctrl._GetSizeHints(W - X, H, W, H)
  '     hchild._SetGeometry(X, Y, W, H)
  '   Next
  '
  '   For Each hChild In aIgnored
  '     hchild._SetGeometry(hchild.Ctrl._Left, hchild.Ctrl._Top, hchild.Ctrl._Width, hchild.Ctrl._Height)
  '   Next
  '
  ' Endif

End

Public Sub _GetSizeHints(AvailableW As Float, AvailableH As Float, TotalWidth As Float, TotalHeight As Float) As TSizeHint

  Dim hChild As TControl
  Dim fHeight As Float
  Dim hChildHints As TSizeHint
  Dim hMyHints As New TSizeHint
  Dim fSpacing As Float
  Dim fPadding As Float

  'If Me._SizeInt.StoreSize Then Return Me._SizeInt

  Select Case _Arrangement

    Case Arrange.Vertical
      Return GetVSizeInt(AvailableW, AvailableH, TotalWidth, TotalHeight)

    Case Arrange.Horizontal
      Return GetHSizeInt(AvailableW, AvailableH, TotalWidth, TotalHeight)

    Case Arrange.Fill, Arrange.None
      Return Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight)
      'hMyHints.Height = AvailableH
      'Me._SizeInt.StoreSize = True
      'Me._SizeInt = hMyHints
      Return hMyHints

  End Select

End

Private Function GetHSizeInt(AvailableW As Float, AvailableH As Float, TotalWidth As Float, TotalHeight As Float) As TSizeHint

  Dim hChild As ReportControl
  Dim fHeight, fWidth As Float
  Dim hChildHints As TSizeHint
  Dim hMyHints As New TSizeHint
  Dim fSpacing As Float

  'D'abord utiliser la méthode du controle pour définir la taille
  hMyHints = Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight)

  'Puis si besoins voir le besoin des enfants
  If Me.Autoresize Then
    fSpacing = IIf(Me._RelativeSpacing, TotalWidth * Me._Spacing / 100, Me._Spacing)
    For Each hChild In Me.Children
      hChildHints = hchild._GetSizeHints(AvailableW - fWidth, AvailableH, AvailableW, AvailableH)
      fWidth += hChildHints.Width + fSpacing
      If fHeight < hChildHints.Height Then fHeight = hChildHints.Height
    Next
    fWidth -= fSpacing
    hMyHints.Height = fHeight
    hMyHints.Width = fWidth
  Endif

  Return hMyHints

End

Private Function GetVSizeInt(AvailableW As Float, AvailableH As Float, TotalWidth As Float, TotalHeight As Float) As TSizeHint

  Dim hSizeInt As New TSizeHint
  Dim htmpInts As TSizeHint
  Dim hChild As ReportControl         ''Enfants
  Dim fHeight, fSpacing, fWidth As Float
  Dim i, j As Integer
  Dim bExitLoop As Boolean

  'D'abord utiliser la méthode du controle pour définir la taille
  hSizeInt = Super._GetSizeHints(AvailableW, AvailableH, TotalWidth, TotalHeight)

  fSpacing = IIf(Me._RelativeSpacing, TotalHeight * Me._Spacing / 100, Me._Spacing)

  ' Si ce n'est pas fait on enregistre la place nécéssaire a tout les éléments fixes
  If Not $fFixedSize Then
    For i = 0 To Me.Children.Max
      hChild = Me.Children[i]
      htmpInts = hChild._GetSizeHints(AvailableW, AvailableH, AvailableW, AvailableH)
      If hchild.Fixed Then $fFixedSize += htmpInts.Height + fSpacing
    Next

  Endif

  'La taille ne peut être inférieur a celle de tout les éléments fixes
  hSizeInt.Height = Max(hSizeInt.Height, $fFixedSize)

  'On ajoute la taille des objets fixes précédents
  fHeight = $fFixedSize

  If Me.Autoresize Then
    'On définit la taille au besoins des enfants
    For i = Me._CurItem To Me.Children.Max
      hChild = Me.Children[i]
      For j = hchild._DataIndex To hchild._Count - 1
        Me._Index = j
        If hChild.Ignore Then Continue
        If hChild.Fixed Then Continue
        htmpInts = hChild._GetSizeHints(AvailableW, AvailableH - fHeight, AvailableW, AvailableH)
        'on ajoute la hauteur aux besoins
        fHeight += htmpInts.Height + fSpacing
        If fHeight - fSpacing > AvailableH Then
          Break
          bExitLoop = True
        Endif
        'On récupère la largeur de l'enfant le plus large
        If fWidth < htmpInts.Width Then fWidth = htmpInts.Width
      Next
      If bExitLoop Then Break
    Next

    'on enlève le dernier espace
    If fHeight > 0 Then fHeight -= fSpacing
    'bogue bizzard
    fHeight += 0.01

    'On indique la place nécéssaire aux enfants+les éléments fixes
    hSizeInt.Height = fHeight
    hSizeInt.Width = fWidth
  Endif

  'On ne peut pas dépasser la taille disponible (report sur prochaine page)
  hSizeInt.Height = Min(hSizeInt.Height, AvailableH)

  Me._SizeInt = hSizeInt

  Return hSizeInt

End

Public Function _GetData(sKey As String) As Variant

  If $bDataIsResult Then
    If $hData.Fields.Exist(sKey) Then
      $hData.MoveTo(Me._Index)
      Return $hData[skey]
    Endif
  Else
    If $hdata <> Null And If $hData[0].Exist(sKey) Then
      Return $hdata[Me._Index][skey]
    Endif
  Endif

  Try Return Me.Parent._GetData(sKey)

  Return Null

End

Private Function Data_Read() As Object

  Return $hData

End

Private Sub Data_Write(Value As Object)

  If Not (Object.Type(Value) = "Collection[]") Then
    If Object.Type(Value) = "Result" Then
      $bDataIsResult = True
    Else
      Print Error.Text
      $bDataIsResult = False

    Endif
    If Not $bDataIsResult Then
      Error.Raise("You must give a Collection[] object or a Result Object")
      Return
    Endif
  Endif
  Me._Count = Value.Count
  $hData = Value

End

Public Sub _Reset()

  Dim hChild As ReportControl

  Me._CurItem = 0
  Me._PageChildren.Clear

  For Each hChild In Me.Children

    hChild._Reset

  Next

End

Public Sub _SetChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, bInFixed As Boolean)
  'If Me.Tag = "*" Then Stop
  'Print "Geometry " & Object.Type(Me)

  Select Case _Arrangement
    Case Arrange.Vertical
      SetVChildGeometry(X, Y, W, H, ContPage, bInFixed)
    Case Arrange.Horizontal
      SetHChildGeometry(X, Y, W, H, ContPage, bInFixed)
    Case Arrange.Fill
      SetFChildGeometry(X, Y, W, H, ContPage, bInFixed)
    Case Arrange.None
      SetNChildGeometry(X, Y, W, H, ContPage, bInFixed)
  End Select

End

Private Sub SetVChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, bInFixed As Boolean)

  Dim aPageItems As New TControl[] ''Éléments contenu par cette page
  Dim hChildHints As TSizeHint ''Besoins en hauteur/largeur de l'enfant
  Dim hChild As ReportControl  ''Un enfant reportcontrol
  Dim oChild As Object
  Dim TH, fHeight, fSpc As Float
  Dim fExp As Float
  Dim iNExp As Integer
  Dim O As Object
  Dim i, j As Integer
  Dim hTItem As TControl
  'Dim bPass As Boolean
  Dim fX, fY, fTmpY As Float
  Dim bExitLoop As Boolean

  ' If Me.Tag = "*" Then
  '   Print H
  '   Stop
  ' Endif
  'If Me.tag = "Contenu1" Then Print "H= " & H
  'Initialisation des variables
  fSpc = IIf(Me._RelativeSpacing, H * Me._Spacing / 100, Me._Spacing) 'ME._Spacing
  'On retire les marges a la hauteur et les bordures
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  'on retire a la largeur les paddings (et les bordure ?)
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right

  'On positionne le curseur de position au coin a gauche
  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top

  'On initialise la hauteur total avec la hauteur disponible
  TH = H
  'If Me.Tag = "Contenu1" Then Print TH
  'On va retirer a la hauteur totale les éléments fixes
  'If Me.Tag = "ListeElements" Then Stop
  For i = 0 To Me.Children.Max
    hChild = Me.Children[i]
    If hChild.Fixed Then
      hChildHints = hChild._GetSizeHints(W, TH, W, H)
      'Print "Ajout de :" & Object.Type(hChild)
      'si l'index courant est inférieur a l'objet en cour du conteneur alors
      'on l'ajoute a la page et on incrémente la place des objet étendu si il est étendu

      If Not hchild.Ignore Then TH = TH - hChildHints.Height - fspc

      If i < Me._CurItem Then
        'If Me._CurItem = 0 Then itmpItem = i
        hTItem = New TControl
        hTItem.Ctrl = hChild
        hTItem.SizeHint = hChildHints
        'On l'ajoute a la page
        aPageItems.Add(hTItem)
        'Si l'enfant est étendu alors on en tien compte :
        If hChild.Expand And Not hchild.Ignore Then
          fExp += hChildHints.Height
          Inc iNexp
        Endif
      Endif

    Endif

  Next

  'If Me._CurItem = 0 Then Me._CurItem = itmpItem
  For i = Me._CurItem To Me.Children.Max

    hChild = Me.Children[i]
    For j = hchild._DataIndex To hchild._Count - 1
      'If hChild.Tag = "Contenu1" Then Stop
      'If hChild.Tag = "Contenu1" Then Stop
      hChildHints = hChild._GetSizeHints(W, TH, W, H)

      'Si on ne l'a pas déja compté comme fixé
      If Not hChild.Fixed And If Not hChild.Ignore Then
        If (TH - hChildHints.Height + fspc) < 0 Then
          Print "stop"
          hchild._DataIndex = j
          bExitLoop = True
          Break
        Endif
        TH = TH - hChildHints.Height - fspc

      Endif

      hTItem = New TControl
      hTItem.Ctrl = hChild
      hTItem.SizeHint = hChildHints
      hTItem.Index = j
      'On l'ajoute a la page
      aPageItems.Add(hTItem)
      'Si l'enfant est étendu alors on en tien compte :
      If hChild.Expand Then
        fExp += hChildHints.Height
        Inc iNexp
      Endif
      'un élément fixe ou ignore ne peut être répété
      If hchild.Fixed Or hchild.Ignore Then Break
    Next
    If bExitLoop Then Break
    Inc Me._CurItem
  Next

  If (H - TH) > 0 Then
    TH += fspc
  Endif

  For i = Max(Me._CurItem, 0) To Me.Children.Max
    hChild = Me.Children[i]
    If hChild.Fixed Then
      hChildHints = hChild._GetSizeHints(W, TH, W, H)
      hTItem = New TControl
      hTItem.Ctrl = hChild
      hTItem.SizeHint = hChildHints
      'On l'ajoute a la page
      aPageItems.Add(hTItem)
      'Si l'enfant est étendu alors on en tien compte :
      If hChild.Expand And Not hchild.Ignore Then
        fExp += hChildHints.Height
        Inc iNexp
      Endif
    Endif
  Next

  'On va mettre en page a présent
  'On définit la taille des éléments étendus
  If iNexp Then
    fExp = (TH + fExp) / iNexp
  Endif

  fTmpY = Y

  For Each hTItem In aPageItems

    oChild = hTItem.Ctrl
    'Si l'élément est étendu on lui applique la taille répartie
    If oChild.Expand And Not oChild.Ignore Then
      'If Me.Tag = "*" Then Stop
      fHeight = fExp
    Else
      'sinon il maintien sa taille
      fHeight = hTItem.SizeHint.Height
    Endif

    'Print Object.Type(hChild) & "  " & fHeight
    If Not oChild.Ignore Then
      hTItem._SetGeometry(X, fTmpY, W, fHeight)

      oChild._SetChildGeometry(X, fTmpY, W, fHeight, ContPage, bInFixed Or Me.Fixed)
      fTmpY += fHeight + fspc
    Else
      fX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
      fY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)
      hTItem._SetGeometry(fX, fY, hTItem.SizeHint.Width, fHeight)
      oChild._SetChildGeometry(fX, fY, hTItem.SizeHint.Width, fHeight, ContPage, bInFixed Or Me.Fixed)
    Endif

    If oChild Is ReportContainer Then

      If oChild._CurItem <= oChild.Children.max Then
        'Print "il reste des éléments dans " & oChild.Tag & " a la page " & ContPage
        'Print ochild.Children.max - ochild._CurItem
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(Me._CurItem, j)
      Endif

    Endif

  Next

  'Fin du processus
  'On ajoute cette page au dossier du conteneur
  Me._PageChildren[ContPage] = aPageItems

End

Private Function SetFChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, bInFixed As Boolean)

  Dim hChild As ReportControl
  Dim hTItem As TControl
  Dim hChildHints As TSizeHint
  Dim aPageItems As New TControl[]
  Dim oChild As Object
  Dim j As Integer

  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  For Each hChild In Me.Children
    hChildHints = hchild._GetSizeHints(W, H, W, H)
    hTItem = New TControl
    hTItem.Ctrl = hchild
    hTItem.SizeHint = hChildHints

    Inc Me._CurItem
    aPageItems.Add(hTItem)

  Next
  For Each oChild In aPageItems
    hTItem._SetGeometry(X, Y, W, H)
    hChild._SetChildGeometry(X, Y, W, H, ContPage, bInFixed Or Me.Fixed)
    If oChild Is ReportContainer Then

      If oChild._CurItem < oChild.Children.count Then
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(j, Me._CurItem)
      Endif

    End If
  Next

  Me._PageChildren[ContPage] = aPageItems

End

Private Function SetNChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, bInFixed As Boolean)

  Dim hChild As ReportControl
  Dim ochild As Object
  Dim hTItem As TControl
  Dim hChildHints As TSizeHint
  Dim aPageItems As New TControl[]
  Dim iX, iY As Integer
  Dim J As Integer

  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom

  For Each hChild In Me.Children

    hChildHints = hchild._GetSizeHints(W, H, W, H)
    hTItem = New TControl
    hTItem.Ctrl = hchild
    hTItem.SizeHint = hChildHints
    Inc Me._CurItem
    aPageItems.Add(hTItem)

  Next

  For Each hTItem In aPageItems
    oChild = hTItem.Ctrl
    hChildHints = hTItem.SizeHint
    iX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
    iY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)

    hTItem._SetGeometry(iX, iY, hChildHints.Width, hChildHints.Height)
    hChild._SetChildGeometry(iX, iY, hChildHints.Width, hChildHints.Height, ContPage, bInFixed Or Me.Fixed)

    If oChild Is ReportContainer Then

      If oChild._CurItem < oChild.Children.count Then
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(j, Me._CurItem)
      Endif

    End If
  Next
  Me._PageChildren[ContPage] = aPageItems

End

Private Sub SetHChildGeometry(X As Float, Y As Float, W As Float, H As Float, ContPage As Integer, bInFixed As Boolean)

  Dim aPageItems As New TControl[] ''Éléments contenu par cette page
  Dim hChildHints As TSizeHint ''Besoins en hauteur/largeur de l'enfant
  Dim hChild As ReportControl  ''Un enfant reportcontrol
  Dim oChild As Object
  Dim TW, fWidth, fSpc As Float
  Dim fExp As Float
  Dim iNExp As Integer
  Dim O As Object
  Dim i, j, itmpItem As Integer
  Dim fTmpX, fX, fY As Float
  Dim hTItem As TControl

  'Initialisation des variables
  fSpc = IIf(Me._RelativeSpacing, H * Me._Spacing / 100, Me._Spacing) 'ME._Spacing
  'On retire les marges a la hauteur et les bordures
  H = H - Me.Padding._Top - Me.Padding._Bottom - Me.Border._Top - Me.Border._Bottom
  'Print H
  'on retire a la largeur les paddings (et les bordure ?)
  W = W - Me.Padding._Left - Me.Padding._Right - Me.Border._Left - Me.Border._Right

  'On positionne le curseur de position au coin a gauche
  X = Me.Padding._Left + Me.Border._Left
  Y = Me.Padding._Top + Me.Border._Top

  'On initialise la largeur totale avec la largeur disponible
  TW = W

  For i = 0 To Me.Children.Max

    hChild = Me.Children[i]

    hChildHints = hChild._GetSizeHints(w, h, w, h)

    'Si l' éléments ne loge pas on quitte et on s'en moque
    If TW - hChildHints.Width < 0 Then Break

    'Si l'élément n'est pas ignoré
    If Not hChild.Ignore Then
      TW = TW - hChildHints.Width - fSpc
      'Si il est étendu on en tient compte
      If hChild.Expand Then
        Inc iNExp
        fExp += hChildHints.Width
      Endif
    Endif

    'On ajoute l'élément a la page
    hTItem = New TControl
    hTItem.Ctrl = hChild
    hTItem.SizeHint = hChildHints
    aPageItems.Add(hTItem)

  Next

  'De toute les façon je ne cherche pas a parcourir tout
  'Les objet donc j'indique que j'ai tout vu
  Me._CurItem = Me.Children.count

  If (W - TW) > 0 Then
    TW += fspc
  Endif

  'On va mettre en page a présent
  'On définit la taille des éléments étendus
  If iNexp Then
    fExp = (TW + fExp) / iNexp
  Endif

  fTmpX = X
  For Each hTItem In aPageItems
    oChild = hTItem.Ctrl
    'Si l'élément est étendu on lui applique la taille répartie
    If oChild.Expand And Not oChild.Ignore Then
      'If Me.Tag = "*" Then Stop
      fWidth = fExp
    Else
      'sinon il maintien sa taille
      fWidth = hTItem.SizeHint.Width
    Endif
    If Not oChild.Ignore Then
      hTItem._SetGeometry(fTmpX, Y, fWidth, H)
      oChild._SetChildGeometry(fTmpX, Y, fWidth, H, ContPage, bInFixed Or Me.Fixed)
      fTmpX += fWidth + fspc
    Else
      fX = X + IIf(oChild._RelativeLeft, W * oChild._Left / 100, oChild._Left)
      fY = Y + IIf(oChild._RelativeTop, H * oChild._Top / 100, oChild._Top)
      hTItem._SetGeometry(fX, fY, fWidth, hTItem.SizeHint.Height)
      oChild._SetChildGeometry(fX, fY, fWidth, hTItem.SizeHint.Height, ContPage, bInFixed Or Me.Fixed)
    Endif

    If oChild Is ReportContainer Then

      If oChild._CurItem <= oChild.Children.max Then
        j = Me.Children.Find(oChild)
        Me._CurItem = Min(Me._CurItem, j)
      Endif

    Endif
  Next

  'On ajoute la page a la collection de page du conteneur
  Me._PageChildren[ContPage] = aPageItems

End

Private Function DataCount_Read() As Integer

  Return Me._Count

End

Private Sub DataCount_Write(Value As Integer)

  Me._Count = Value

End

Public Function _GetIndex() As Integer

  If Me._Count > 0 Then
    Return Me._Index
  Else
    Try Return Me.Parent._GetIndex
  Endif

End
