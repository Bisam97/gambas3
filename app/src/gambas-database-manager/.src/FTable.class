' Gambas class file

Public Connection As CConnection
Public Table As String

Private $hConn As CConnection
Private $sTable As String
Private $bCreate As Boolean
Private $sName As String
Private $sType As String

Private $aField As New Object[]
Private $cFieldName As Collection
Private $aIndexField As New Object[]

Private $hFieldEditor As CTableViewEditor
Private $hIndexEditor As CTableViewEditor

Private $bModify As Boolean
Private $bReadOnly As Boolean

Private frmData As FData

Static Private $hNullValue As Object ' Used for representing the NULL value in a Collection

Static Public Sub _init()

  $hNullValue = New Integer[]

End


Public Sub _new(hConn As CConnection, sTable As String, Optional bReadOnly As Boolean)

  $cFieldName = New Collection

  $hConn = hConn
  $sTable = sTable
  $sName = sTable
  $bCreate = hConn.Tables.Find($sTable) < 0
  $bReadOnly = bReadOnly
  $sType = hConn.Handle.Tables[$sTable].Type

  Connection = hConn
  Table = sTable

  With tbvField

    .Columns.Count = 5

    With tbvField.Columns[0]
      .Text = " "
      .Width = 24
    End With

    With tbvField.Columns[1]
      .Text = ("Name")
      .Width = 160
    End With

    With tbvField.Columns[2]
      .Text = ("Type")
      .Width = 96
    End With

    With tbvField.Columns[3]
      .Text = ("Length")
      .Width = 80
    End With

    With tbvField.Columns[4]
      .Text = ("Default value")
      .Width = 160
    End With

  End With

  With tbvIndex

    .Columns.Count = 3

    With tbvIndex.Columns[0]
      .Text = ("Index")
      .Width = 160
    End With

    With tbvIndex.Columns[1]
      .Text = ("Unique")
      .Width = 64
    End With

    With tbvIndex.Columns[2]
      .Text = ("Field")
      .Width = 160
    End With

  End With

  If Not $bReadOnly Then

    tabTable.Index = 0
    $hFieldEditor = New CTableViewEditor(tbvField) As "tbvField"
    tabTable.Index = 1
    $hIndexEditor = New CTableViewEditor(tbvIndex) As "tbvIndex"

  Endif

  tabTable.Index = 0

  RefreshTitle

  ReadTable

  'FMain.MoveRandom(ME)

End

Private Function IsModified() As Boolean

  Dim bModify As Boolean

  bModify = $bModify
  If frmData Then bModify = bModify Or frmData.IsModified()

  Return bModify

End


Public Sub RefreshTitle()

  Dim sTitle As String

  sTitle = $hConn.Server.Name & " - " & $hConn.Name & " - " & $sName
  If IsModified() Then sTitle = sTitle & " [" & ("modified") & "]"

  Me.Title = sTitle

End

Public Sub Modify(Optional bModify As Boolean = True)

  $bModify = bModify
  RefreshTitle

End


Private Sub ReadTable()

  Dim hTable As Table
  Dim hField As Field
  Dim hIndex As Index
  Dim hCField As CField
  Dim hCIndexField As CIndexField
  Dim sField As String
  Dim bCreate As Boolean

  If Not $bReadOnly Then
    $hFieldEditor.Hide
    $hIndexEditor.Hide
  Endif

  $aField.Clear
  $cFieldName.Clear
  $aIndexField.Clear

  hTable = $hConn.Handle.Tables[$sTable]

  For Each hField In hTable.Fields
    hCField = New CField(hField)
    $aField.Add(hCField)
    $cFieldName[hField.Name] = True
  Next

  For Each hIndex In hTable.Indexes

    If hIndex.Primary Then Continue

    hCIndexField = New CIndexField(hIndex)
    $aIndexField.Add(hCIndexField)
    bCreate = False

    For Each sField In Split(hIndex.Fields)
      If bCreate Then
        hCIndexField = New CIndexField
        $aIndexField.Add(hCIndexField)
      Else
        bCreate = True
      Endif
      hCIndexField.Field = sField
    Next

  Next

  tbvField.Rows.Count = $aField.Count
  'tbvField.Columns.Width = -1
  tbvField.MoveTo(0, 1)

  tbvIndex.Rows.Count = $aIndexField.Count

  $bModify = False
  RefreshTitle

End


Private Sub WriteTableDef(sName As String, sType As String, aPrimaryKey As String[], Optional bKill As Boolean)

  Dim hTable As Table
  Dim hCField As CField
  Dim hCIndex As CIndexField
  Dim hLastCIndex As CIndexField
  Dim sError As String

  Try $hConn.Handle.Tables.Remove(sName)
  hTable = $hConn.Handle.Tables.Add(sName, sType)

  With hTable

    For Each hCField In $aField
      .Fields.Add(hCField.Name, hCField.Type, hCField.Length, hCField.DefaultValue)
    Next

    .PrimaryKey = aPrimaryKey
    .Update

  End With

  For Each hCIndex In $aIndexField
    If hCIndex.Index Then
      hCIndex.List = hCIndex.Field
      hLastCIndex = hCIndex
    Else
      hLastCIndex.List = hLastCIndex.List & "," & hCIndex.Field
    Endif
  Next

  For Each hCIndex In $aIndexField
    If Not hCIndex.Index Then Continue
    hTable.Indexes.Add(hCIndex.Index, hCIndex.List, hCIndex.Unique)
  Next

Finally

  sError = Replace(Error.Text, sName, $sName)
  If bKill Then
    Try $hConn.Handle.Tables.Remove(sName)
  Endif

Catch

  Error.Raise(sError)

End



Private Function WriteTable() As Boolean

  Dim aPrimaryKey As New String[]
  Dim hCField As CField
  Dim sTemp As String
  Dim rTemp As Result
  Dim rTable As Result
  Dim hForm As Object
  Dim sType As String
  Dim sError As String

  If $hFieldEditor.Hide() Then Return True
  If $hIndexEditor.Hide() Then Return True

  For Each hCField In $aField
    If hCField.Key Then
      aPrimaryKey.Add(hCField.Name)
    Endif
  Next

  If aPrimaryKey.Count = 0 Then
    Message.Warning(("You must define a primary key."))
    Return True
  Endif

  If frmData Then
    If frmData.IsModified() Then frmData.btnSaveData_Click
    frmData.Delete
    frmData = Null
  Endif

'   FOR EACH hForm IN FMain.Container.Children
'     IF Object.Type(hForm) = "FData" THEN
'       IF hForm.Table = Table THEN
'         IF hForm.Close() THEN RETURN TRUE
'         BREAK
'       ENDIF
'     ENDIF
'   NEXT

  Inc Application.Busy

  If $hConn.CountTableData($sTable) Then
    sTemp = $hConn.CopyTableData($sTable)
  Endif

  sType = $hConn.Handle.Tables[$sTable].Type

  WriteTableDef($hConn.GetTempTableName(), sType, aPrimaryKey, True)
  WriteTableDef($sName, sType, aPrimaryKey)

  'hTable = $hConn.Handle.Tables.Add($sName, sType)

  If sTemp Then

    $hConn.Handle.Begin

    rTemp = $hConn.Handle.Find(sTemp)
    rTable = $hConn.Handle.Create($sName)

    For Each rTemp

      For Each hCField In $aField
        If hCField.OldName Then
          Try rTable[hCField.Name] = rTemp[hCField.OldName]
          'IF Error THEN PRINT hField.OldName; "->"; hField.OldName; ": "; Error.Text
        Endif
      Next

      Try rTable.Update
      'IF Error THEN PRINT "Update: "; Error.Text

    Next

    $hConn.Handle.Commit

  Endif

  'IF frmData THEN
  '  frmData.btnRefresh_Click
  'ENDIF
  tabTable_Click

  Modify(False)

Finally

  sError = Error.Text

  If sTemp Then
    Try $hConn.Handle.Tables.Remove(sTemp)
    'IF Error THEN PRINT "Delete temporary table: "; Error.Text
  Endif

  If $sTable <> $sName Then
    Try Connection.RefreshTree
    $sTable = $sName
    Table = $sName
  Endif

  Dec Application.Busy

Catch

  Message.Error(("Cannot write table.") & "\n\n" & sError)
  Return True

End


Private Function FindField(sField As String) As CField

  Dim hCField As CField

  For Each hCField In $aField
    If hCField.Name = sField Then Return hCField
  Next

End


Public Sub Form_Delete()

  If Not $bReadOnly Then
    $hFieldEditor.Close
    $hIndexEditor.Close
  Endif

  'Connection = NULL
  '$hConn = NULL

End


Public Sub Form_Resize()

  tbvField.Resize(tabTable.ClientW, tabTable.ClientH - tbvField.Y)
  tbvIndex.Resize(tabTable.ClientW, tabTable.ClientH - tbvIndex.Y)
  If frmData Then 
    frmData.Move(0, 0, tabTable.ClientW, tabTable.ClientH)
  Endif 

  If Not $bReadOnly Then
    $hFieldEditor.Resize
    $hIndexEditor.Resize
  Endif

End

Public Sub tbvField_Data(Row As Integer, Column As Integer)

  Dim hCField As CField

  Try hCField = $aField[Row]
  If Not hCField Then Return

  With tbvField.Data

    Select Case Column

      Case 0
        If hCField.Key Then
          .Picture = Picture["img/16/key.png"]
          .Alignment = Align.Center
        Endif

      Case 1
        .Text = hCField.Name

      Case 2
        .Text = TypeToString(hCField.Type)

      Case 3
        If hCField.Type = gb.String Then
          If hCField.Length Then
            .Text = hCField.Length
          Else
            .Text = ("unlimited")
          Endif
        Endif

      Case 4
        .Text = Str(hCField.DefaultValue)

    End Select

  End With

End


Private Function TypeToString(iType As Integer) As String

  Select Case iType
    Case db.Integer
      Return ("Integer")
    Case db.Long
      Return ("Long")
    Case db.Float
      Return ("Float")
    Case db.Date
      Return ("Date")
    Case db.Boolean
      Return ("Boolean")
    Case db.String
      Return ("String")
    Case db.Serial
      Return ("Serial")
    Case db.Blob
      Return ("Blob")
    Default
      Return "?"
  End Select

End

Private Function TypeFromString(sType As String) As Integer

  Select Case sType
    Case ("Integer")
      Return db.Integer
    Case ("Long")
      Return db.Long
    Case ("Float")
      Return db.Float
    Case ("Date")
      Return db.Date
    Case ("Boolean")
      Return db.Boolean
    Case ("String")
      Return db.String
    Case ("Serial")
      Return db.Serial
    Case ("Blob")
      Return db.Blob
    Default
      Return db.Integer
  End Select

End

Public Sub tbvField_Click()

  Dim hField As CField

  If $bReadOnly Then Return

  If tbvField.Column = 0 Then
    hField = $aField[tbvField.Row]
    hField.Key = Not hField.Key
    tbvField.Current.Refresh
    Modify
  Endif

End

Public Sub tbvField_Change()

  Dim hField As CField

  If $bReadOnly Then Return

  hField = $aField[tbvField.Row]

  With $hFieldEditor

    Select Case tbvField.Column

      Case 0
        .Hide

      Case 1
        .ShowTextBox(True, True)

      Case 2
        .ShowComboBox([("Boolean"), ("Integer"), ("Long"), ("Serial"), ("Float"), ("String"), ("Date"), ("Blob")], True, True)

      Case 3
        If hField.Type = gb.String Then
          .ShowComboBox([("unlimited")])
        Else
          .Hide
        Endif

      Case 4
        If hField.Type = gb.Boolean Then
          .ShowComboBox(["True", "False"]) ' Non traduisible !
        Else
          .ShowTextBox()
        Endif

    End Select

  End With

End


Private Sub RenameField(hField As CField, sNewName As String)

  Dim hCIndex As CIndexField

  For Each hCIndex In $aIndexField
    If UCase(hCIndex.Field) = UCase(hField.Name) Then
      hCIndex.Field = sNewName
    Endif
  Next

  $cFieldName[hField.Name] = Null
  hField.Name = sNewName
  $cFieldName[sNewName] = True

End



Public Sub tbvField_Save(Row As Integer, Column As Integer, sData As String) 

  Dim hField As CField
  Dim iVal As Integer
  Dim vVal As Variant

  hField = $aField[Row]

  Select Column

    Case 1
      If $cFieldName.Exist(sData) Then
        Message.Warning(("This name already exists."))
        Stop Event
        Return
      Endif

      If hField.Name <> sData Then
        RenameField(hField, sData)
      Endif

    Case 2

      'PRINT sData; " -> "; TypeFromString(sData)
      hField.Type = TypeFromString(sData)
      hField.DefaultValue = Null
      hField.Length = 0

      tbvField[Row, 3].Refresh
      tbvField[Row, 4].Refresh

    Case 3
      If sData = ("unlimited") Then
        hField.Length = 0
      Else
        Try iVal = CInt(sData)
        If Error Then
          Message.Warning(("Please enter a number."))
          Stop Event
          Return
        Endif
        If iVal < 1 Or iVal > 255 Then
          Message.Warning(("The length must be greater than 1 and lower than 255."))
          Stop Event
          Return
        Endif
        hField.Length = iVal
      Endif

    Case 4

      If hField.Type <> gb.String Then
        If sData Then

          vVal = Val(sData)

          If hField.Type = gb.Float Then
            If TypeOf(vVal) = gb.Integer Or If TypeOf(vVal) = gb.Long Then
              vVal = CFloat(vVal)
            Endif
          Else If hField.Type = gb.Long Then
            If TypeOf(vVal) = gb.Integer Then
              vVal = CLong(vVal)
            Endif
          Endif

          If TypeOf(vVal) <> hField.Type Then
            Message.Warning(("Incorrect value."))
            Stop Event
            Return
          Endif

        Endif
      Else
        vVal = sData
      Endif

      hField.DefaultValue = vVal

  End Select

  Modify

End

Public Sub btnNewField_Click()

  Dim hField As CField
  Dim iInd As Integer

  If $bReadOnly Then Return

  If $hFieldEditor.Hide() Then Return

  hField = New CField

  With hField

    For iInd = 1 To 1000
      .Name = ("Field") & CStr(iInd)
      If Not $cFieldName.Exist(.Name) Then Break
    Next

    .Type = gb.Integer

    $cFieldName[.Name] = True

  End With

  $aField.Add(hField, tbvField.Row + 1)
  Inc tbvField.Rows.Count

  tbvField.MoveTo(tbvField.Row + 1, 1)

  Modify

End

Public Sub btnKillField_Click()

  Dim iRow As Integer

  If $bReadOnly Then Return

  If $aField.Count <= 1 Then Return

  If $hFieldEditor.Hide() Then Return

  iRow = tbvField.Row

  If IsFieldUsedInIndex($aField[iRow].Name) Then
    Message.Warning(("This field is used in an index."))
    Return
  Endif

  $cFieldName[$aField[iRow].Name] = Null
  $aField.Remove(iRow)
  Dec tbvField.Rows.Count

  Modify

End


Public Sub btnDownField_Click()

  If $bReadOnly Then Return

  If tbvField.Row = (tbvField.Rows.Count - 1) Then Return

  Swap $aField[tbvField.Row], $aField[tbvField.Row + 1]

  tbvField.Rows[tbvField.Row].Refresh
  tbvField.Rows[tbvField.Row + 1].Refresh

  Inc tbvField.Row

  Modify

End

Public Sub btnUpField_Click()

  If $bReadOnly Then Return

  If tbvField.Row = 0 Then Return

  Swap $aField[tbvField.Row], $aField[tbvField.Row - 1]

  tbvField.Rows[tbvField.Row].Refresh
  tbvField.Rows[tbvField.Row - 1].Refresh

  Dec tbvField.Row

  Modify

End

Public Sub btnKey_Click()

  If $bReadOnly Then Return

  With $aField[tbvField.Row]
    .Key = Not .Key
  End With

  tbvField[tbvField.Row, 0].Refresh

  Modify

End

Public Sub btnCancelField_Click()

  If tabTable.Index = 2 Then

    frmData.btnRefresh_Click

  Else

    If $bReadOnly Then Return

    If Message.Question(("Do you really want to reload the table definition ?"), ("Reload"), ("Cancel")) <> 1 Then Return

    ReadTable

  Endif

End


Public Sub tbvIndex_Data(Row As Integer, Column As Integer)

  Dim hIndexField As CIndexField

  Try hIndexField = $aIndexField[Row]
  If Not hIndexField Then Return

  With tbvIndex.Data

    Select Case Column

      Case 0
        .Text = hIndexField.Index

      Case 1
        If hIndexField.Index Then .Text = Str(hIndexField.Unique)

      Case 2
        .Text = hIndexField.Field

    End Select

  End With

End


Private Function FindIndex(sName As String) As Boolean

  Dim hIndexField As CIndexField

  For Each hIndexField In $aIndexField
    If sName = hIndexField.Index Then Return True
  Next

End


Private Function FreeIndexFields(Optional bExcept As Boolean) As String[]

  Dim iRow As Integer
  Dim hField As CField
  Dim cField As New Collection
  Dim bVal As Boolean
  Dim aField As New String[]

  For Each hField In $aField
    cField[hField.Name] = True
  Next

  iRow = tbvIndex.row
  Do
    If $aIndexField[iRow].Index Then Break
    Dec iRow
  Loop

  Do
    If Not bExcept Or iRow <> tbvIndex.Row Then
      cField[$aIndexField[iRow].Field] = Null
    Endif
    Inc iRow
    If iRow >= $aIndexField.Count Then Break
    If $aIndexField[iRow].Index Then Break
  Loop

  For Each bVal In cField
    aField.Add(cField.Key)
  Next

  Return aField

End


Private Function IsFieldUsedInIndex(sField As String) As Boolean

  Dim iRow As Integer

  For iRow = 0 To $aIndexField.Max
    If sField = $aIndexField[iRow].Field Then Return True
  Next

End



Public Sub btnNewIndex_Click()

  Dim hIndexField As CIndexField
  Dim iInd As Integer

  If $bReadOnly Then Return

  hIndexField = New CIndexField

  With hIndexField

    For iInd = 1 To 1000
      .Index = $sTable & "_" & ("Index") & CStr(iInd)
      If Not FindIndex(.Index) Then Break
    Next

    .Field = $aField[0].Name

  End With

  $aIndexField.Add(hIndexField)
  Inc tbvIndex.Rows.Count

  tbvIndex.MoveTo(tbvIndex.Rows.Count - 1, 0)

  Modify

End

Public Sub btnNewIndexField_Click()

  Dim hIndexField As CIndexField
  Dim iRow As Integer
  Dim aField As String[]

  If $bReadOnly Then Return
  If $aIndexField.Count = 0 Then Return

  iRow = tbvIndex.Row
  If iRow < 0 Then Return

  aField = FreeIndexFields(False)
  If aField.Count = 0 Then Return

  hIndexField = New CIndexField

  With hIndexField

    .Field = aField[0]

  End With

  Do
    Inc iRow
    If iRow >= tbvIndex.Rows.Count Then Break
    If $aIndexField[iRow].Index Then Break
  Loop

  $aIndexField.Add(hIndexField, iRow)
  Inc tbvIndex.Rows.Count

  tbvIndex.MoveTo(iRow, 1)

  Modify

End

Public Sub btnKillIndex_Click()

  Dim sIndex As String
  Dim bUnique As Boolean
  Dim iRow As Integer
  Dim hIndex As CIndexField

  If $bReadOnly Then Return
  If $aIndexField.Count = 0 Then Return

  iRow = tbvIndex.Row
  If iRow < 0 Then Return

  $hIndexEditor.Hide

  With $aIndexField[iRow]
    sIndex = .Index
    bUnique = .Unique
  End With

  $aIndexField.Remove(iRow)

  If iRow < $aIndexField.Count Then

    With $aIndexField[iRow]
      If Not .Index Then
        .Index = sIndex
        .Unique = bUnique
      Endif
    End With

  Endif

  Dec tbvIndex.Rows.Count
  tbvIndex.Refresh

  Modify

End

Public Sub btnDownIndex_Click()

  Dim iRow As Integer

  If $bReadOnly Then Return

  iRow = tbvIndex.Row
  If iRow < 0 Then Return

  If iRow = ($aIndexField.Count - 1) Then Return
  If $aIndexField[iRow + 1].Index Then Return

  Swap $aIndexField[iRow].Field, $aIndexField[iRow + 1].Field
  Inc tbvIndex.Row

  tbvIndex.Refresh

End

Public Sub btnUpIndex_Click()

  Dim iRow As Integer

  If $bReadOnly Then Return

  iRow = tbvIndex.Row
  If iRow < 0 Then Return

  If iRow = 0 Then Return
  If $aIndexField[iRow].Index Then Return

  Swap $aIndexField[iRow].Field, $aIndexField[iRow - 1].Field
  Dec tbvIndex.Row

  tbvIndex.Refresh

End

Public Sub tbvIndex_Change()

  Dim hIndex As CIndexField

  If $bReadOnly Then Return

  hIndex = $aIndexField[tbvIndex.Row]

  With $hIndexEditor

    Select Case tbvIndex.Column

      Case 0
        If hIndex.Index Then
          .ShowTextBox(True, True)
        Else
          .Hide
        Endif

      Case 1
        If hIndex.Index Then
          .ShowComboBox(["True", "False"], True)
        Else
          .Hide
        Endif

      Case 2

        .ShowComboBox(FreeIndexFields(True), True, True)

    End Select

  End With

End


Public Sub tbvIndex_Save(Row As Integer, Column As Integer, sData As String)

  Dim hIndex As CIndexField

  hIndex = $aIndexField[Row]

  Select Column

    Case 0

      If FindIndex(sData) Then
        Message.Warning(("This name already exists."))
        Stop Event
        Return
      Endif
      hIndex.Index = sData

    Case 1

      hIndex.Unique = sData = "True"

    Case 2

      hIndex.Field = sData

  End Select

  Modify

End

Public Sub btnSaveField_Click()

  SaveTable

End


Public Sub Form_Close()

  Dim bCancel As Boolean

  If IsModified() Then
    Select Case Message.Question($hConn.Server.Name & " - " & $hConn.Name & "\n\n" & Subst(("The table '&1' has been modified.\nDo you want to save it ?"), $sTable), ("Save"), ("Do not save"), ("Cancel"))
      Case 1
        If frmData Then
          If frmData.IsModified() Then
            bCancel = frmData.WriteData()
          Endif
        Endif
        If Not bCancel Then
          If $bModify Then
            bCancel = WriteTable()
          Endif
        Endif
      Case 3
        bCancel = True
    End Select
  Endif

'   IF NOT bCancel THEN
'     'Connection = NULL
'     '$hConn = NULL
'   ENDIF

  If bCancel Then
    Stop Event
  Else If frmData Then
    frmData.Close
  Endif

End



Public Sub btnData_Click()

  $hConn.OpenTable($sTable, True)

End

Public Sub btnRename_Click()

  Dim sNewName As String
  Dim sOldName As String

  If $bReadOnly Then Return

  If FNewTable.Run($sName, $sType) Then Return

  sNewName = FNewTable.Name
  If Not sNewName Then Return
  If sNewName = $sTable Then Return

  If Connection.Handle.Tables.Exist(sNewName) Then
    Message.Warning(("This table name is already in use."))
    Return
  Endif

  sOldName = $sName
  $sName = sNewName
  Modify

  If SaveTable() Then
    $sName = sOldName
    Return
  Endif

  Try $hConn.DeleteTable(sOldName)
  $hConn.RefreshTree

End

Public Sub tabTable_Click()

  If tabTable.Index = 2 Then
    If Not frmData Then
      frmData = New FData(Me, $hConn, $sTable, $bReadOnly, tabTable)
      Form_Resize
    Endif
  Endif

End

Public Sub btnClose_Click()

  Me.Close

End


Public Sub btnRequest_Click()

  Connection.OpenRequest

End

Private Function SaveTable() As Boolean

  If $bReadOnly Then Return

  If $hFieldEditor.Hide() Then Return True
  If $hIndexEditor.Hide() Then Return True

  If WriteTable() Then Return True

End

Public Sub tbvField_LostFocus()

  'PRINT "tbvField_LostFocus"

End
