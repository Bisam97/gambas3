' Gambas module file

''' Changes the project in Path (given by args) to start with a random method,
''' runs tests and restores the project afterwards

Private $hHarness As New TestHarness
Private $bVerbose As Boolean

Public Sub Main()

    Dim sPath, sCompilerPath, sExecutorPath, sBuf, sTestCmd, sRand As String
    Dim sSingleTestModule, sSingleTestMethod, sNewStartupFile, sStartupSequence As String
    Dim hTestee As Process

    With Args
        .Begin(Application.Name & " <options> [path to poject]\n\nType " & Application.Name & " -h for help")
        Try sSingleTestModule = .Get("m", "testmodule", "Single Testmodule")
        Try sSingleTestMethod = .Get("t", "testmethod", "Method of a single testmodule")
        Try $bVerbose = .Has("v", "verbose", "Echo the TAP stream")
        .End
    End With

    sPath = Args[Args.Max]

    sCompilerPath = GetPath("gbc3")
    sExecutorPath = GetPath("gbx3")

    ' ------------------------------------------------- Tests

    If sPath = Null Then
        Error.Raise("Error: Path to project is Null.")
    Endif

    If Not Exist(sPath) Then
        Error.Raise("Error: Path to project not found.")
    Endif

    If sSingleTestMethod And If sSingleTestModule = Null Then
        Error.Raise("Error: Testmodule not defined")
    Endif

    If sSingleTestModule Then
        sTestCmd = "\"" & sSingleTestModule & "" "\""
    Endif

    If sSingleTestMethod Then
        sTestCmd &= ", \"" & sSingleTestMethod & "" "\""
    Endif

    ' ------------------------------------------------- New startup file
    sTestCmd = "Unittest.Main(" & sTestCmd & ")"

    Do
        sRand = "TEST" & Randstr()
        sNewStartupFile = sPath &/ ".src" &/ sRand & ".module"
    Loop While Exist(sNewStartupFile)

    'create test startup module
    sStartupSequence = "'Gambas module" & gb.Lf & gb.Lf &
        "Public Sub Main()" & gb.Lf & gb.Lf &
        sTestCmd & gb.Lf & gb.Lf &
        "End" & gb.Lf

    File.Save(sNewStartupFile, sStartupSequence)

    ' ------------------------------------------------- run tests

    'To sBuf: use sBuf as buffer just that gbc3's "OK" is not printed
    Exec [sCompilerPath, sPath] Wait To sBuf

    'run tests
    hTestee = Exec [sExecutorPath, "-s", sRand, sPath] For Read
    $hHarness.Read(hTestee, File.Name(sPath))
    PrintSummary()

    ' ------------------------------------------------- Restore project

    'restore project
    Kill sNewStartupFile

    'compile again
    Exec [sCompilerPath, sPath] Wait To sBuf

Catch
    Print Error.Text

End

Private Sub PrintSummary()

    With $hHarness.Current
        If $bVerbose Then
            Dim sLine As String
            Print "Transcript of the TAP stream:"
            Print
            For Each sLine In .Lines
                Print sLine
            Next
            Print
            Print String$(80, "*")
            Print
        Endif

        Print .Name;;
        If .BailedOut Then
            Print "bailed out";
            If .BailMessage Then Print " with message";; .BailMessage
        Else
            Print IIf(.Success, "PASSED", "FAILED")
        Endif
        Print "Ran";; .Run;; Plural(.Run, "test");;
        Print "("; "exit code";; .ExitCode; ",";;
        Print "runtime";; Format$(DateDiff(.Started, .Ended, gb.Second), "0.00s"); ")"

        If Not .BailedOut Then
            If .Run <> .Planned Then
                Print "Planned";; .Planned;; Plural(.Planned, "test");; "but ran";; .Run
            Endif

            If .Failed > 0 Then
                Dim iInd As Integer
                Print "Failed";; .Failed;; "out of";; .Run;; Plural(.Run, "test");; ":";;
                For iInd = 0 To .Failures.Max
                    Print .Failures[iInd];
                    If iInd < .Failures.Max Then Print ",";;
                Next
                Print
            Endif

            If .Bonus Then
                Print "Passed";; .Bonus;; "additional";; Plural(.Bonus, "test");; "marked as TODO"
            Endif
        Endif

        If $bVerbose Then
            Print
            Print String$(80, "*")
            Print
        Endif

    End With

End

'' **Regular English** plural: just appends an "s" to _Word_ if _Count_ is not 1.
Private Function Plural(Count As Integer, Word As String) As String

    Return Word & IIf(Count = 1, "", "s")

End

Private Function Randstr() As String

    Dim j As Byte
    Dim s As String

    For j = 1 To 5
        If Fix(Rnd(0, 2)) Then
            s &= Chr(Rnd(48, 58))
        Else
            s &= Chr(Rnd(65, 91))
        Endif
    Next
    Return s

End

Private Function GetPath(Prog As String) As String

    Dim sPath As String

    Exec ["which", Prog] To sPath
    sPath = Trim(sPath)
    If Not Exist(sPath) Then Error.Raise(Subst$(("Program '&1' not found."), Prog))
    Return sPath

End
