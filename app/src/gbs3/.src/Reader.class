' Gambas class file

Public Enum rText, rTokens, rTypes, rPosition

Public ProgramLines As New String[]                                     ' List of all program lines
Public ProgramSymbols As New Variant[]                                  ' List of all tokens
Public ProgramTypes As New Variant[]                                    ' List of all 
Public ProgramPositions As New Variant[]                                ' Position of token text in each line
Public GlobalItemPosition As New Integer[]                              ' Position of each Globaly define variable
Public sSourceFile As String = ""                                       ' The Source File

Private CurrentLineNumber As New Integer[]                              ' Current line number of text in a file

Public CurrentLine As Integer = -1                                                   ' current line being processed
Public CurrentToken As Integer = -1                                               '  we have not gotten first token yet
Public key As Integer = -1                                                                   '  the key to the datasets
Private MainDef As New Collection(gb.ignorecase)                         '  Points to main if found in this file

Private ClassList As New Integer[]                                       '  List of all discovered class definitions start
Private ClassLineNumbers As New Integer[]                                ' Line number of the definition
Private ClassNames As New String[]                                       '  List of the class names being created
Public ClassesDefined As New Collection(gb.ignorecase)                   '  Collection of defined classes

Private ModuleList As New Integer[]                                       '  List of all discovered Module definitions start
Private ModuleLineNumbers As New Integer[]                                ' Line number of the definition
Private ModuleNames As New String[]                                       '  List of the Module names being created
Public ModulesDefined As New Collection(gb.ignorecase)                    '  Collection of defined Modules
Public bModuleStartup As Boolean = False

Private FormList As New Integer[]                                        ' List of all discovered Forms definitions start
Private FormLineNumbers As New Integer[]                                 ' Line number of the definition
Private FormNames As New String[]                                        ' List of the Forms names being created
Public FormsDefined As New Collection(gb.ignorecase)                     ' Collection of defined Forms

Private ConnectionList As New Integer[]                                   ' List of all discovered Connections definitions start
Private ConnectionLineNumbers As New Integer[]                            ' Line number of the definition
Private ConnectionNames As New String[]                                   ' List of the Connection names being created
Public ConnectionDefined As New Collection(gb.ignorecase)                 ' Collection of defined Connections



Private bInClass As Boolean = False                                                '  Processing a class block
Private cIncludedFiles As New Collection(gb.Ignorecase)                   ' List of already included files, only load included files once
Private cIncludeStack As New String[]                                           ' List of files included into this build, to check for circular refrence
Private sDefaultFilePath As String = ""                                          ' Directory to look for included file with no full path defined
Private bPublicOrSubDef As Boolean = False                               ' Used to indicate that the script contained public or Subroutines
Private aWarnings As New String[]                                                  ' Builds an array of possible warnings
' Public bFast As Boolean = False                                                       ' found a fast definition compiler option
' Public bUnsafe As Boolean = False                                                 ' Found an unsafe compiler option 
Private $oContext As Context                                                             ' all the global variables

Public Sub _New(cContext As Context, Optional SourceFile As String = "")
  Dim SourceBuffer As String
  
  $oContext = cContext                                                                         ' Access to global variables
  cIncludeStack.Push(SourceFile)                                                       ' Add this file to the stack for processing
  sDefaultFilePath = File.Dir(SourceFile)                                         ' Set the default file path to use for includes
  sSourceFile = SourceFile
  
  If SourceFile = "" Then 
      SourceBuffer = GetStdio()
  Else
     $oContext.$aIncFiles.Add(SourceFile)
     $oContext.$aIncFiles.Add(Stat(SourceFile).LastModified)
     SourceBuffer = GetFile(SourceFile)
     Verbose("Processing Script File : " & File.Name(SourceFile))
  Endif
  
  TokenizeFile(SourceBuffer)
  
End

Public Sub GetStdio() As String

  Dim buffer As String
  Dim SourceBuffer As String = ""
  
  While Not Eof(File.in)
    buffer = Read -256
    SourceBuffer &= buffer
  Wend
  
  Return SourceBuffer
  
End

Private Sub GetFile(SourceFile As String) As String
  Dim buffer As String 
  
  Try Buffer = File.Load(SourceFile)
  
  If Error Then
    Error.Raise("Unable to read file : \"" & SourceFile & "\"")
  Endif
  
  Return buffer
  
End

Private $cKeywords As Collection = ["PRIVATE": True, "PUBLIC": True, "STATIC": True, "SUB": True, "FUNCTION": True, "PROCEDURE": True, "STRUCT": True, "ENUM": True]
Private $cSegments As Collection = ["FORM": True, "MODULE": True, "CONNECTION": True]
Private Sub TokenizeFile(SourceBuffer As String)
  Dim SourceList As String[]
  Dim sClassName As String = ""
  Dim MainPos As Integer = 1
  $cKeywords.default = False
  $cSegments.Default = False
 
  CurrentLineNumber.Push(0)
  
  SourceList = Split(SourceBuffer, "\n", "", True)
  For Each sLine As String In SourceList
    Inc CurrentLineNumber.last
    
    If Left(sLine, 3) = "#!/" Then sLine = "' " & sLine  ' eliminate the script header
    
    Highlight.Analyze(sLine)
    '' Here we look for any definition which will be a seperate source type or includes other sources
    '' Building the source pool as we go
   
    '' Check for The definition of main, Knowing this speeds up process of program portion of the script
    If Highlight.Types.count >= 4 And If Highlight.Types[0] = Highlight.Keyword Then
      MainPos = 1
      If Highlight.Symbols[0] = "PUBLIC" And Highlight.Types[1] = Highlight.keyword Or If Highlight.Types[1] = Highlight.symbol Then
        If Highlight.Types[1] = Highlight.symbol Then MainPos = 0
        If Highlight.Symbols[MainPos] = "SUB" Or If Highlight.Symbols[MainPos] = "PROCEDURE" Or If Highlight.Symbols[MainPos] = "FUNCTION" Then
          If Upper(Highlight.Symbols[MainPos + 1]) = "MAIN" Then
              If Highlight.Types.count = 4 Then
                Warning("Main Was Not Declared as Public, assuming public")
                sLine = "Public " & sline 
              Endif
              MainDef.Add(CurrentLineNumber.last, cIncludeStack.last)
              If MainDef.count > 1 Then 
                Warning("Multiple Main Definitions :", True)
                For Each i As Integer In MainDef       
                  Verbose("Main Defined : " & Quote(MainDef.key) & "." & i, True)
                Next
                CompileError(cIncludeStack.last, CurrentLineNumber.last, "Too Many Main Definitions")
              Else
                Verbose("Main Defined  : " & cIncludeStack.last & "." & CurrentLineNumber.last)
              Endif
          Endif
        Endif
      Endif
    Endif
    
    '' Check for specifickeywords that trigger reliance upon MAIN being defined
    
     If Highlight.Symbols.count > 0 And If Highlight.Types[0] = Highlight.keyword Or $cSegments.Exist(Upper(Highlight.Symbols[0])) Then
       
        If Highlight.Symbols[0] = "EXPORT" Then
          $oContext.$bExport = True
          sLine = "' " & sLine
        Else If Not bInClass And If $cKeywords[Highlight.Symbols[0]] Then
            aWarnings.Add("Warning : Defined without main : " & Highlight.Symbols[0] & ":" & File.name(cIncludeStack.last) & "." & CurrentLineNumber.last & " : " & sline)
            bPublicOrSubDef = True
            GlobalItemPosition.Add(ProgramLines.count)
        Else If Not bInClass And If Highlight.Symbols[0] = "FAST" Then
          
          If Highlight.Types.count > 2 Then
               aWarnings.Add("Warning : Defined without main : " & Highlight.Symbols[0] & ":" & File.Name(cIncludeStack.last) & "." & CurrentLineNumber.last & " : " & sline)
             bPublicOrSubDef = True
          Else If $oContext.$bFast = True Then   ' already defined
               Verbose("FAST Duplicate Definition at " & File.Name(cIncludeStack.last) & "." & CurrentLineNumber.last)
          Else If Highlight.types.count = 1 Then
             Verbose("FAST(Jit) activated for Module:" & File.name(cIncludeStack.last) & "." & CurrentLineNumber.last)
             $oContext.$bFast = True
             sLine = "' " & sline
          Else If Highlight.Types.count = 2 And If Highlight.Symbols[1] = "UNSAFE" Then
            Verbose("FAST UNSAFE(Jit and nochecks) activated for Module:" & File.name(cIncludeStack.last) & "." & CurrentLineNumber.last)
            $oContext.$bFast = True
            $oContext.$bUnsafe = True
            sLine = "' " & sline
          Else
            CompileError(cIncludeStack.last, CurrentLineNumber.last, "UnKnown Entry : " & Highlight.Symbols[0] & " Following 'FAST'  Definition")
          Endif
        Endif
         
    '' check for inclusion of Components or libraries
    
        If Highlight.Symbols[0] = "USE" 
            If Highlight.Symbols.count >= 2 Then
                 ProcessUse(Highlight.Symbols, Highlight.types, sLine)
                Continue
            Else
                CompileError(cIncludeStack.last, CurrentLineNumber.last, "USE statement without component or library definitions")
            Endif 
        Endif
        
        '' Check for the end of a class definition      
        If Highlight.Symbols[0] = "END" And Highlight.Symbols.count = 2 Then
          If Highlight.types[1] = Highlight.keyword And If Highlight.Symbols[1] = "CLASS" Then
             If Not bInClass Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Syntax error : Unexpected END CLASS: " & sLine)
             Endif
             sClassName = ClassNames.Pop()
             ClassesDefined.Add(ProcessClass(sClassName, ClassList.Pop(), ClassLineNumbers.Pop(), ClassDef.asClass), sClassName)
             bInClass = False
             Continue
          Else If Highlight.types[1] = Highlight.symbol And If Upper(Highlight.Symbols[1]) = "MODULE" Then
             If Not bInClass Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Syntax error : Unexpected END MODULE: " & sLine)
             Endif
             sClassName = ModuleNames.Pop()
             ModulesDefined.Add(ProcessClass(sClassName, ModuleList.Pop(), ModuleLineNumbers.Pop(), ClassDef.asModule), sClassName)
             bInClass = False
             Continue
          Else If Highlight.types[1] = Highlight.symbol And If Upper(Highlight.Symbols[1]) = "FORM" Then
             If Not bInClass Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Syntax error : Unexpected END FORM: " & sLine)
             Endif
             sClassName = FormNames.Pop()
             FormsDefined.Add(ProcessClass(sClassName, FormList.Pop(), FormLineNumbers.Pop(), ClassDef.asForm), sClassName)
             bInClass = False
             Continue
          Else If Highlight.types[1] = Highlight.symbol And If Upper(Highlight.Symbols[1]) = "CONNECTION" Then
             If Not bInClass Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Syntax error : Unexpected END CONNECTION: " & sLine)
             Endif
             sClassName = ConnectionNames.Pop()
             ConnectionDefined.Add(ProcessClass(sClassName, ConnectionList.Pop(), ConnectionLineNumbers.Pop(), ClassDef.asConnection), sClassName)
             bInClass = False
             Continue
          Endif
        Endif
        
        '' Check for the definition of a class and make where it is defined
        If Highlight.Symbols[0] = "CLASS" Then
          If Highlight.Symbols.count < 2 Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Class : Name Missing ")
          Else If Highlight.Types[1] = Highlight.symbol Then
             If bInClass Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, " Class : Unexpected class definition inside Class definition : " & sLine)
             Endif
             If ClassesDefined[Highlight.Symbols[1]] Then 
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Class : " & Highlight.Symbols[1] & " Already defined")
             Endif
             ClassList.Push(ProgramSymbols.Count)
             ClassNames.Push(Highlight.Symbols[1])
             ClassLineNumbers.Push(CurrentLineNumber.last)
             If Highlight.Symbols.count = 3 And If Upper(Highlight.Symbols[2]) = "STARTUP" Then
               ScriptPreProcess.SetStartup(Highlight.Symbols[1])
               bModuleStartup = True
             Endif
             bInClass = True
             Continue
          Else
             CompileError(cIncludeStack.last, CurrentLineNumber.last, "Unexpected  : " & Highlight.Symbols[1] & " In Class definition")
          Endif
        Else If Upper(Highlight.Symbols[0]) = "MODULE" Then
          If Highlight.Symbols.count < 2 Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Module : Name Missing ")
          Else If Highlight.Types[1] = Highlight.symbol Then
             If bInClass Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, " Module : Unexpected Module definition inside Module definition : " & sLine)
             Endif
             If ModulesDefined[Highlight.Symbols[1]] Then 
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Module : " & Highlight.Symbols[1] & " Already defined")
             Endif
             ModuleList.Push(ProgramSymbols.Count)
             ModuleNames.Push(Highlight.Symbols[1])
             ModuleLineNumbers.Push(CurrentLineNumber.last)
             If Highlight.Symbols.count = 3 And If Upper(Highlight.Symbols[2]) = "STARTUP" Then
               ScriptPreProcess.SetStartup(Highlight.Symbols[1])
               bModuleStartup = True
             Endif
             bInClass = True
             Continue
          Else
             CompileError(cIncludeStack.last, CurrentLineNumber.last, "Unexpected  : " & Highlight.Symbols[1] & " In Module definition")
          Endif
        Else If Upper(Highlight.Symbols[0]) = "FORM" Then
          If Highlight.Symbols.count <> 2 Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Form : Name Missing ")
          Else If Highlight.Types[1] = Highlight.symbol Then
             If bInClass Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, " Form : Unexpected Form definition inside Form definition : " & sLine)
             Endif
             If FormsDefined[Highlight.Symbols[1]] Then 
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Form : " & Highlight.Symbols[1] & " Already defined")
             Endif
             FormList.Push(ProgramSymbols.Count)
             FormNames.Push(Highlight.Symbols[1])
             FormLineNumbers.Push(CurrentLineNumber.last)
             bInClass = True
             Continue
          Else
             CompileError(cIncludeStack.last, CurrentLineNumber.last, "Unexpected  : " & Highlight.Symbols[1] & " In Form definition")
          Endif
        Else If Upper(Highlight.Symbols[0]) = "CONNECTION" Then
          If Highlight.Symbols.count <> 2 Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Connection : Name Missing ")
          Else If Highlight.Types[1] = Highlight.symbol Then
             If bInClass Then
               CompileError(cIncludeStack.last, CurrentLineNumber.last, " Connection : Unexpected Form definition inside Form definition : " & sLine)
             Endif
             If ConnectionDefined[Highlight.Symbols[1]] Then 
               CompileError(cIncludeStack.last, CurrentLineNumber.last, "Connection : " & Highlight.Symbols[1] & " Already defined")
             Endif
             ConnectionList.Push(ProgramSymbols.Count)
             ConnectionNames.Push(Highlight.Symbols[1])
             ConnectionLineNumbers.Push(CurrentLineNumber.last)
             bInClass = True
             Continue
          Else
             CompileError(cIncludeStack.last, CurrentLineNumber.last, "Unexpected  : " & Highlight.Symbols[1] & " In Connection definition")
          Endif
        Endif
        
    Endif
    
    ''Check for an include statement -- Include is not a keyword, perhaps it should be
    If Highlight.types.count >= 2 And If Highlight.Types[0] = Highlight.Preprocessor And If Highlight.Symbols[0] = "#INCLUDE" Then
         ProcessInclude(Highlight.symbols, Highlight.types, sDefaultFilePath)
         sLine = "'" & sLine
         Continue
    Else If Highlight.Types.count >= 2 And If Highlight.Types[0] = Highlight.symbol And If Highlight.Types[1] = Highlight.string Then
      If Upper(Highlight.symbols[0]) = "INCLUDE" Then
         Warning("'Include' is Replaced by '#Include' and may not be supported in future releases")
         ProcessInclude(Highlight.symbols, Highlight.types, sDefaultFilePath)
         Continue
      Endif
    Endif
    
    '' Check for out of stream lines
    If Highlight.Types.count >= 2 And If Highlight.Types[0] = Highlight.Preprocessor Then
      If Highlight.Types.count >= 2 And If Highlight.Symbols[0] = "#SCRIPT" Then 
         'ProjectOptions(Split(sLine, "# ,", "\"\",true,true"), CurrentLineNumber.last, cIncludeStack.last)
         Highlight.Analyze(Right(Trim(sline), -1))
         ScriptPreProcess(Highlight.symbols, Highlight.types, CurrentLineNumber.last, cIncludeStack.last)
        sLine = "'" & sline
      Endif
    Endif
    
    ProgramLines.Add(sLine)
    ProgramSymbols.Add(Highlight.Symbols)
    ProgramTypes.Add(Highlight.types)
    ProgramPositions.Add(Highlight.Positions)
    
  Next
  
  If ClassNames.count > 0 Then 
    CompileError(cIncludeStack.last, CurrentLineNumber.last, "Missing 'END CLASS' for Class :" & ClassNames.Pop())
  Endif
  
  CurrentLineNumber.Pop()
End

Public Sub ProcessClass(name As String, Start As Integer, DefLine As Integer, Optional ClassType As Integer = ClassDef.asClass) As ClassDef
   Dim cDef As ClassDef
   
   Verbose("Defining " & ClassDef.FileExtention[ClassType] & " : " & name & " in script file : " & UnQuote(File.Name(cIncludeStack.last)) & "." & DefLine)
   cDef = New ClassDef(name, ProgramLines.Extract(start, -1), ProgramSymbols.Extract(start, -1), ProgramTypes.Extract(start, -1), ProgramPositions.Extract(start, -1), ClassType)
   cDef.iLineNumber = DefLine
   cDef.sDefinedIn = cIncludeStack.last
   Return cDef
End

Public Sub ProcessUse(Symbols As String[], aTypes As Integer[], sLine As String)
  
  Warning("Use :" & File.Name(cIncludeStack.last & "." & CurrentLineNumber.last & ":" & sLine))
  UseLibComp(cIncludeStack.last, CurrentLineNumber.last, Symbols, aTypes)
  
End

Public Sub UseList() As String

Dim UseCompLibList As String = ""

If UseLibComp.HasComponents Then
  UseCompLibList = CComponent.ComponentEntries()
Endif

If UseLibComp.HasLibraries Then
  UseCompLibList &= Libraries.LibraryEntries()
Endif
  
Return UseCompLibList

End


Public Sub ProcessInclude(Includes As String[], atypes As Integer[], sDefaultPath As String)
  Dim buffer As String
  Dim sFilePath As String
  Dim Start As Integer = IIf(Includes[0] = "#", 1, 1)
  For i As Integer = Start To Includes.Max
    If Includes[i] = " " Or If Includes[i] = "" Then Continue
    If Includes[i] = "," Then Continue
    If aTypes[i] = Highlight.comment Then Break
    
    sFilePath = UnQuote(Includes[i])
    If File.Dir(sFilePath) = "" Then 
            sFilePath = sDefaultPath &/ sFilePath 
    Endif
    
    If cIncludedFiles[sFilePath] Then Continue                                  ' we only include things once
    
    If cIncludeStack.Find(sFilePath) > 0 Then
       CompileError(cIncludeStack.last, CurrentLineNumber.last, "Include \"" & sFilePath & "\" Circular Refrence")
    Else
       Verbose("Including script file :  " & sFilePath & " From File : " & cIncludeStack[cIncludeStack.max] & "." & CurrentLineNumber.last)
       cIncludeStack.Push(sFilePath)
    Endif
   
    $oContext.$aIncFiles.Add(sFilePath)
    $oContext.$aIncFiles.Add(Stat(sFilePath).LastModified)
    buffer = GetFile(sFilePath)
    TokenizeFile(buffer)  
    
     cincludedFiles.Add(CurrentLineNumber.last, cIncludeStack.Pop())          ' Keep Track of what is already included
     
  Next
  
End


Public Sub Eof() As Boolean
  
  If currentLine + 1 > ProgramLines.max Then
     Return True
  Endif
  Return False
  
End

Public Sub advance() As String[]
  If currentline = ProgramLines.max Then
    Return Null
  Endif

   Inc CurrentLine
   CurrentToken = -1
  Return ProgramSymbols[CurrentLine]
  
End

Public Sub NextToken() As String
  
  If CurrentToken + 1 > ProgramSymbols[CurrentLine].max Then
    advance()
  Else
    Inc CurrentToken
  Endif
  Return ProgramSymbols[CurrentLine][CurrentToken]
  
End

Public Sub backToken() 
  
  If CurrentToken = 0 Then
    back()
  Else
    Dec CurrentToken
  Endif
  
End


Public Sub back(Optional count As Integer = 1)
  
  If CurrentLine - count >= 0 Then
    CurrentLine -= count
  Else
    CurrentLine = -1
  Endif
  CurrentToken = ProgramSymbols[CurrentLine].max
End


Public Sub Text(Optional index As Integer = CurrentLine) As String
  
  If index >= 0 And index <= ProgramLines.max Then
    Return ProgramLines[index]
  Else
    Error.Raise("Out of bounds Program Text Line Number : " & index)
  Endif
  
End

Public Sub Tokens(Optional index As Integer = CurrentLine) As String[]
  
   If index >= 0 And index <= ProgramLines.max Then
    Return ProgramSymbols[index]
  Else
    Error.Raise("Out of bounds Program Tokens Line Number : " & index)
  Endif
  
End

 Public Sub Types(Optional index As Integer = CurrentLine) As Integer[]
 
  If index >= 0 And index <= ProgramLines.max Then
    Return ProgramTypes[index]
  Else
    Error.Raise("Out of bounds Program Types  Line Number : " & index)
  Endif
  
End

Public Sub Positions(Optional index As Integer = CurrentLine) As Integer[]
 
  If index >= 0 And index <= ProgramLines.max Then
    Return ProgramPositions[index]
  Else
    Error.Raise("Out of bounds Program Positions  Line Number : " & index)
  Endif
  
End

Public Sub _get(index As Integer, Optional Setof As Integer = rText, SubIndex As Integer = -1) As Variant
  
  Dim result As Variant[]
  
  Select Case Setof
    Case rText
      Return Text(index)
    Case rTokens
      Result = Tokens(index)
    Case rTypes
      Result = Types(index)
    Case rPosition
      Result = Positions(index)
  End Select
  
  If SubIndex >= 0 Then
    If subIndex < result.Count Then
       Return result[SubIndex]
    Else
      Error.Raise("Out of bounds Program  Get Line Number : " & index)
    Endif
    
  Endif
End

Public Sub _next() As String[]
  
  If Enum.index = Null Then
    Enum.index = 0
  Else
    Inc Enum.index
  Endif
  If Enum.index > ProgramLines.max Then
     Enum.Stop
  Else
    Return ProgramSymbols[Enum.Index]
  Endif
End

Public Sub IsMainDefined() As Boolean
  
  If MainDef.count > 0 Then
    Return True
  Endif
  Return False
End

Public Sub HasClasses() As Boolean
  
  If ClassesDefined.count > 0 Then
    Return True
  Endif
  Return False
End

Public Sub HasModules() As Boolean
  
  If ModulesDefined.count > 0 Then
    Return True
  Endif
  Return False
End

Public Sub HasForms() As Boolean
  
  If FormsDefined.count > 0 Then
    Return True
  Endif
  Return False
End

Public Sub HasConnections() As Boolean
  
  If ConnectionDefined.count > 0 Then
    Return True
  Endif
  Return False
End

Public Sub HasPublicOrSub() As Boolean
  
  Return bPublicOrSubDef
  
End

Public Sub getClasses() As Collection
  
  Return ClassesDefined
  
End

Public Sub getModules() As Collection
  
  Return ModulesDefined
  
End

Public Sub getForms() As Collection
  
  Return FormsDefined
  
End

Public Sub getConnections() As Collection
  
  Return ConnectionDefined
  
End

Public Sub GetProgram() As String
  
  Return ProgramLines.Join("\n")
  
End

Public Sub DisplayWarnings()
  
  For Each sMessage As String In aWarnings
    Warning(sMessage)
  Next
  
End

