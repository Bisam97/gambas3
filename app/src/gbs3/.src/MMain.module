' Gambas module file

Public $oContext As New Context
Public $sPath As String 
Private $sPrjPath As String 
Public $sArchivepath As String           ' When Create Executable option is used this is the destination for the archive from gba3
Public $sMd5 As String                   ' Project md5 string to check if needs to rebuild or just execute
Public $aAppArgs As New String[]         ' This is a list of all args on the script command line after the script name, these are passed to the executing project based on the script file

Public Sub _ResetAll()
  
  $oContext._ResetAll()
  $aAppArgs.Clear()
  $sPath = ""
  $sPrjPath = ""
  $sArchivePath = ""
  $sMd5 = ""

End

Public Sub Main() As Integer

  Dim sName As String
  Dim sCacheDir As String = File.Dir(File.Dir(Temp$())) &/ "script-cache"
  Dim sRes As String
  Dim bCompile As Boolean
  
 With $oContext 
  ' System.language = "fr_FR"

  If Not Exist(sCacheDir) Then Mkdir sCacheDir

  If Not .$bTestMode Then        ' for testmode the test suite will set the parameters and paths
    $sPath = ParseArgs($oContext)
    
   If ParseArgs.$bExit Then
      Quit 0
    Endif
    
  Endif

  sName = File.Name($sPath)

  If Not $sPath Then
    verbose("Reading from default Stdin")
    $sPath = Read Lof(File.In)           ' This is invoked when cmd line is like  ' gbs -e < filename'
    verbose(" Input read :\n" & $sPath)
    If Not $sPath Then
      Warning(("no input file specified"), True)
      Return 1
    Else
      $oContext.$bExecuteFromArgs = True
      verbose("execute from command line: " & $sPath)
      sName = File.Name($sPath)
    Endif

  Endif
  
  If Not $oContext.$bExecuteFromArgs And If Not $oContext.$bScriptSourceStdIn Then
    ' md5sum requires the absolute path unless we are using a shell which expands it so ./ddd and ~/ can not be calculated for md5sum Process
    sName = File.Name($sPath)
    $sPath = File.RealPath($sPath)
    If Not Exist($sPath) Then
      $sPath = Application.Dir &/ IIf($sPath = "", sName, $spath)
      If Not Exist($sPath) Then
        Warning(("input file does not exist") & ": " & sName, True)
        Return 1
      Endif
    Else
      Exec ["md5sum", $sPath] To $sMd5
    Endif

  Else

    Shell ("echo '" & $sPath & "'|md5sum") To $sMd5

  Endif

  If $sMd5 = "" Then    ' when there is no path or the source inside the archive then this returns nil
    bCompile = True
  Else
    $sMd5 = Scan($sMd5, "* *")[0]
    If $oContext.$bFast Then $sMd5 &= "-f"

    If $oContext.$bNoCache Or $oContext.$bExecuteFromArgs Then

      bCompile = True

    Else

      If Not Exist(sCacheDir &/ $sMd5 &/ sName) Then
        bCompile = True
      Else
        bCompile = Not IsValid(sCacheDir &/ $sMd5 & ".info")
      Endif
      If Not bCompile Then
         verbose("Executing Script from Cache: " & $sPath)
      Endif
    Endif
  Endif

  If bCompile Then

    If $oContext.$bWebPage Then
      If $oContext.$bVerbose Then Print "gbw: " & ("compiling server page")
      $sPath = MServerPage.Make($sPath)
      If $oContext.$bVerbose Then
        Print String$(20, "-")
        Print File.Load($sPath)
        Print String$(20, "-")
      Endif
    Endif

    $sPrjPath = MakeVirtualProject($oContext, $sPath)
    
    If $sPath = "-" Then
      $sPath = "mStdIoSource"
      sName = $sPath
      $oContext.$aIncFiles.push($sPath)
    Endif 
     
    Dim parmstring As String = "-a"
    If $oContext.$bdebug Then parmstring &= "g"
    If $oContext.$bWarning Then parmstring &= "w"
    'If $oContext.$bVerbose Then Parmstring &= "v"


    Verbose(System.Path &/ "bin/gbc" & System.Version & " " & parmstring & " " & $sPrjPath & " 2>&1")
    'Shell (System.Path &/ "bin/gbc" & System.Version & " " & parmstring & " " & $oContext.$sPrjPath & " 2>&1") To sRes
    sRes = Compile(parmstring, $sPrjPath)
    'Dim sResLines As String[] = Split(sRes, "\n", "", True)   ' added to only check the last line from compiler, ignore all others
    If Not Compile.GoodCompile Then
    '  Error sRes
      If Not $oContext.$bTerseListing Then 
          Print File.Load($sPrjPath &/ ".project")
      Endif
      
      Print MakeListing($oContext, $sPrjPath, sRes)
      
      Return 1
    Endif

    Try Mkdir sCacheDir &/ $sMd5
     $sArchivePath = sCacheDir &/ $sMd5 &/ sName
     Dim ArchiveCmd As String[] = [System.Path &/ "bin/gba" & System.Version, "-o", $sArchivePath, $sPrjPath]
     If $oContext.$bVerbose Then ArchiveCmd.Add("-v", 1)
     Verbose(ArchiveCmd.Join(" "))
   
    Exec ArchiveCmd To sRes
    'Exec [System.Path &/ "bin/gba" & System.Version, "-o", $oContext.$sArchivePath, $oContext.$sPrjPath] To sRes
    File.Save(sCacheDir &/ $sMd5 & ".info", $oContext.$aIncFiles.Join("\n"))

  Endif

  If Not $oContext.$bBuildOnly Then
    $sArchivePath = sCacheDir &/ $sMd5 &/ sName
    Dim RunParms As String[] = [System.Path &/ "bin/gbr" & System.Version, "-a", $sPath, $sArchivePath]
    If $oContext.$bTrace Then RunParms.add("-t", 1)
    $aAppArgs.Insert(RunParms, 0)
  
    Verbose($aAppArgs.Join(" "))
    verbose("***************** Script Output Begins Bellow This Line **************************")
    If $oContext.$bTestMode Then
      Exec $aAppArgs To $oContext.$sTestModeCapture
    Else
      Exec $aAppArgs Wait
    Endif
    verbose("***************** Script Output Ends  **************************")
    
    If Process.LastState = Process.Crashed Then
      Warning(("Script had Segmentation fault, Code=" & Process.LastValue), True)
    Endif

    If $oContext.$bTestMode Then
      Return Process.LastValue
    Else
      Quit Process.LastValue
    Endif

  Endif

  If $oContext.$bTestMode Then
    Return 0
  Else
    Quit 0
  Endif

Catch

  Error Error.Text; " : "; Error.where          ' added for debugging
  If UseLibComp.HasComponents Then  '' added because get circular ref from ccomponent otherwise on exit
    CComponent.All.Clear()
  Endif
  
  If $oContext.$bTestMode Then
    Return -2
  Else
    Quit -2
  Endif
  
  
  End With
  
End


Public Function IsValid(sPath As String) As Boolean

  Dim aFileInfo As String[]
  Dim i As Integer

  If Not Exist(sPath) Then Return False

  aFileInfo = Split(File.Load(sPath), "\n")

  For i = 0 To aFileInfo.Max Step 2
    If Stat(aFileInfo[i]).LastModified > CDate(aFileInfo[i + 1]) Then Return False
  Next

  Return True

Catch
  Return False

End



