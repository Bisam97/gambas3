' Gambas module file

Private $sMd5 As String
Private $sPrjPath As String
Private $hOutFile As File
Private $sPath As String
'PRIVATE $aComponents AS NEW String[]
Private $iClassCount As Integer
Private $hOutClass As File
Private $sMainScriptPath As String
Private $aIncFiles As New String[]
Private $iLevel As Integer
Private $cComponents As New collection
Private $aSortKey As New Integer[]
Private $aAppArgs As New String[]
Private $bNoCache As Boolean
Private $bVerbose As Boolean

Public Sub Main()

  Dim s As Integer
  Dim sCacheDir As String = File.Dir(File.Dir(Temp$())) &/ "script-cache"
  Dim sRes As String
  Dim bCompile As Boolean
  
  If Not Exist(sCacheDir) Then Mkdir sCacheDir
  
  $sPath = ParseArgs()
  
  If IsNull($sPath) Then 
    Error "gbs: No script file specified"
    Error "Type 'gbs"; System.Version; " --help' for more information."
    Application.Return = 1
    Return 
  Endif
  
  If Not Exist($sPath) Then 
    $sPath = Application.Dir &/ $sPath
    If Not Exist($sPath) Then 
      Error "gbs: Script file does not exist: " & Application.Args[1]
      Application.Return = 1
      Return 
    Endif
  Endif 
  
  $sMainScriptPath = File.Dir($sPath)

  'Extract the sum md5
  Exec ["md5sum", $sPath] To $sMd5
  $sMd5 = Scan($sMd5, "* *")[0]
    
  If $bNoCache Then 
  
    bCompile = True
  
  Else  
    
    'Verify if the project was compiled
    If Not Exist(sCacheDir &/ $sMd5) Then 
      bCompile = True
    Else
      'Verify the cache file
      bCompile = Not IsValid(sCacheDir &/ $sMd5 & ".info") 
    Endif
    
  Endif
  
  If bCompile Then 
  
    'If we are run as 'gbw2', then we have a server page to compile!
  
    If File.Name(Application.Args[0]) = "gbw2" Then 
      If $bVerbose Then Print "gbs: compiling server page"
      $sPath = MServerPage.Make($sPath)
      If $bVerbose Then 
        Print String$(20, "-")
        Print File.Load($sPath)
        Print String$(20, "-")
      Endif 
    Endif
  
    'If not we Make and Compile it
    MakeVirtualProject
    
    'compile
    'EXEC [System.Path &/ "bin/gbc" & System.Version, "-a", $sPrjPath] TO sRes 
    Shell (System.Path &/ "bin/gbc" & System.Version & " -ag " & $sPrjPath & " 2>&1") To sRes
    
    If sRes <> "OK\n" Then 
      Error sRes
      Print File.Load($sPrjPath &/ "MMain.module")
      Application.Return = 1
      Return 
    Endif
    
    'Make package
    Exec [System.Path &/ "bin/gba" & system.Version, "-o", sCacheDir &/ $sMd5, $sPrjPath] To sRes 
    'Save the FileInfo Cache
    File.Save(sCacheDir &/ $sMd5 & ".info", $aIncFiles.Join("\n"))
    
  Endif
  
  
  'Execute it
  $aAppArgs.Add(sCacheDir &/ $sMd5, 0)
  Exec $aAppArgs
  
End

Private Function ParseArgs() As String
  
  Dim s As String
  Dim i As Integer
  Dim sApp As String
  For i = 1 To Application.Args.Count - 1
    s = Application.Args[i]

    If Left(s) = "-" Then 
      If s = "--version" Or If s = "-V" Then 
        Print Application.Version
        Quit
      Else If s = "--help" Or If s = "-h" Then
        Print "GAMBAS Scripter version " & Application.Version 
        Print File.Load("helptext")
        Quit
      Else If s = "--nocache" Or If s = "-c" Then
        $bNoCache = True
      Else If s = "--verbose" Or If s = "-v" Then
        $bVerbose = True
      Endif
    Else 
      If Not IsNull(sApp) Then 
        $aAppArgs.Add(s)
        Continue 
      Endif
      sApp = s
      'RETURN a
    Endif
    
  Next
  
  Return sApp
End



Private Sub MakeVirtualProject()
  
  Dim hFile As File
  Dim s As String
  Dim sPrjFileContent As String
  Dim i As Integer
  $sPrjPath = Temp("project") 

  If $bVerbose Then Print "gbs: create project"
  
  'Make the Virtual directory
  Try Mkdir $sPrjPath
  'File the .project content var
  sPrjFileContent = "# Gambas Project File 2.0\n"
  sPrjFileContent &= "Title=Gambas Script\n"
  sPrjFileContent &= "Startup=MMain\n"
  
  'Open a Main module
  $hOutFile = Open $sPrjPath &/ "MMain.module" For Write Create 
  Print #$hOutFile, "' Gambas module file\n"
  'Fill it and create class as need
  $iLevel = 0
  GenerateFiles($sPath)
  
  'Complete the components list
  For Each s In $cComponents
    GetNeededComp(s)
  Next
  
  For Each s In $cComponents
    GetRequiredComp(s)
  Next
  
  CComponent.Exit
  
  'Sort components
  $aSortKey.Sort
  
  'Now make the component list with the info collected
  For Each i In $aSortKey
     sPrjFileContent &= "Library=" & $cComponents[i] & "\n"
     'PRINT $cComponents[i]
  Next
  
  'Save the .Project File
  File.Save($sPrjPath &/ ".project", sPrjFileContent)
  
  Close $hOutFile
  'PRINT file.Load($sPrjPath &/ "MMain.module")
End

Private Sub CompileError(sPath As String, iLine As Integer, sMessage As String)
  
  Error sPath; "."; iLine; ": "; sMessage
  CComponent.Exit
  Quit
  
End


Private Sub GenerateFiles(Path As String)
  
  Dim hFile As File
  Dim sLine As String
  Dim sPath As String
  Dim sClass As String
  Dim bInClass As Boolean = False
  Dim s As String
  Dim sCodeBuf As String
  Dim bAutoMain As Boolean = True
  Dim aSym As String[]
  Dim iInd As Integer
  Dim iLine As Integer
  
  If Not Exist(Path) Then Return 
  'Check if this file is already included: if true not include it
  If $aIncFiles.Exist(Path) Then Return 
      
  If $bVerbose Then Print "gbs: process file: "; Path

  'Increment Recursion level index
  Inc $iLevel
  
  'Add file info for file cache
  $aIncFiles.Add(Path)
  $aIncFiles.Add(Stat(Path).LastModified)
  
  hFile = Open Path For Read 
  
  While Not Eof(hFile)
    
    Inc iLine
    Line Input #hFile, sLine
    If sLine Like "#!*" Then Continue 
    
    aSym = Highlight.Analyze(sLine)
    
    'Look for file inclusion 
    ' if true call this function recursively
    If aSym.Count = 2 And If aSym[0] = "INCLUDE" And If Highlight.Types[1] = Highlight.String Then 
      sPath = Mid$(aSym[1], 2, -1) 'Trim(Scan(sLine, "INCLUDE *")[0])
      If Not Exist(sPath) Then sPath = $sMainScriptPath &/ sPath
      If $bVerbose Then Print "gbs: include script file: " & sPath
      
      GenerateFiles(sPath)
      Continue 
    Endif
    
    'Close The Class
    If aSym.Count = 2 And If aSym[0] = "END" And If aSym[1] = "CLASS" And If bInClass Then 
      Close #$hOutClass
      'PRINT File.Load($sPrjPath &/ sClass & ".class")
      bInClass = False
      Continue 
    Endif
    
    'Open a new Class
    If aSym.Count = 2 And If aSym[0] = "CLASS" And If Highlight.Types[1] = Highlight.Symbol Then 
       'IF NOT IsNull(sCodeBuf) THEN ERROR.Raise("You can't declare a CLASS in a SUB or FUNCTION")
      sClass = aSym[1] 'Trim(Scan(sLine, "CLASS *")[0])
      If IsNull(sClass) Then 
        CompileError(Path, iLine, "Class name missing")
        Continue
      Endif
      If $bVerbose Then Print "gbs: create class: "; sClass
      $hOutClass = Open $sPrjPath &/ sClass & ".class" For Write Create
      bInClass = True
      Continue       
    Endif
    
    'Add a new component
    If aSym.Count >= 2 And If aSym[0] = "USE" Then 
      'aSym.Remove(0) 's = aSym[1] 'Trim(Scan(sLine, "USE *")[0])
      For iInd = 1 To aSym.Max Step 2
        If Highlight.Types[iInd] <> Highlight.String Then CompileError(Path, iLine, "Syntax error")
        s = Mid$(aSym[iInd], 2, -1)
        If $bVerbose Then Print "gbs: use component: "; s
        '$aComponents.Add(Trim(s))
        If Not CComponent.All.Exist(s) Then CompileError(Path, iLine, Subst("Unknown component: &1", s))
        $cComponents[CComponent.All[s].SortKey] = s
        $aSortKey.Add(CComponent.All[s].SortKey)
        If iInd < aSym.Max Then
          s = aSym[iInd + 1]
          If s <> "," Then CompileError(Path, iLine, "Comma missing")
        Endif
      Next
      Continue 
    Endif
    
    'Control if the user have not done a Main Sub itself
    If aSym.Count = 4 And If (aSym[0] = "SUB" Or aSym[0] = "PROCEDURE") And If aSym[1] = "Main" And If aSym[2] = "(" And If aSym[3] = ")" Then 
      If $bVerbose Then Print "gbs: Main procedure already defined"
      bAutoMain = False
    Endif
    
    'if in class write directly in file ... else use buffer
    If bInClass Then 
      Print #$hOutClass, sLine
    Else 
      sCodeBuf &= sLine & "\n"
      'if END detected then write to module file
      If aSym.Count = 1 And If aSym[0] = "END" Then 
        Print #$hOutFile, sCodeBuf
        sCodeBuf = Null
      Endif
    Endif
    
      
  Wend
  
  If bInClass Then CompileError(Path, iLine, "END CLASS missing")
  
  'If not exist a Main sub and buffer not empty then generate a Main sub
  'With the Buffer content.. if we are not in an include file
  'In this case the free code is forgotten
  If bAutoMain And Not IsNull(sCodeBuf) And $iLevel = 1 Then 
    If $bVerbose Then Print "gbs: Main procedure not defined, create it"
    Print #$hOutFile, "PUBLIC SUB Main()"
    Print #$hOutFile, sCodeBuf
    Print #$hOutFile, "END"
  Endif
  
  Close #hFile
  
  Dec $iLevel
  
End



Public Function IsValid(sPath As String) As Boolean
  
  Dim aFileInfo As String[]
  Dim i As Integer
  
  If Not Exist(sPath) Then Return False
  
  aFileInfo = Split(File.Load(sPath), "\n")
  
  For i = 0 To aFileInfo.Max Step 2
    If Stat(aFileInfo[i]).LastModified > CDate(aFileInfo[i + 1]) Then Return False
  Next
  
  Return True

 Catch
   Return False
  
End


Public Sub GetRequiredComp(sComp As String)
  
  Dim hComp As CComponent  
  Dim s As String
  
  If Not CComponent.All.Exist(sComp) Then Return
  
  For Each s In CComponent.All[sComp].Require
    If Not $cComponents.Exist(s) Then      
      $cComponents.Add(s, CComponent.All[s].Sortkey)
      $aSortKey.add(CComponent.All[s].SortKey)
      GetRequiredComp(s)   
    Endif
  
  Next
  
End


Private Sub GetNeededComp(sComp As String)
  Dim s, t As String
  Dim bExist As Boolean
  
  If Not CComponent.All.Exist(sComp) Then Return

  For Each s In CComponent.All[sComp].Need
    For Each t In CComponent.WhoImplement[s]
      If $cComponents.Exist(t) Then 
        bExist = True
        Break 
      Endif
      
    Next 
  
    If Not bExist Then  
      t = CComponent.WhoImplement[s][0]
      $cComponents.Add(t, CComponent.All[t].SortKey)
      $aSortKey.add(CComponent.All[t].SortKey)
    Endif
    
    GetNeededComp(t)
    
  Next
  
End




