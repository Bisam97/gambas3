' Gambas class file

Static Public All As New Collection
Static Public Classes As Collection
Static Private $iKey As Integer

Public Const STABLE As Integer = 0
Public Const STABLE_NOT_FINISHED As Integer = 1
Public Const UNSTABLE As Integer = 2

Public Key As String
Public Name As String
Public Authors As New String[]
Public Type As String
Public Controls As New String[]
Public Containers As New String[]
Public MultiContainers As New String[]
Public Virtuals As New String[]
Public Require As New String[]
Public Exclude As New String[]
Public Implement As New String[]
Public Need As New String[]
Public Loaded As Boolean
Public ClassList As New String[]
Public State As Integer
Public SortKey As Integer
Public User As Boolean

Static Private $cName As Collection
Static Public Features As New Collection

Static Private Sub SortComponents()

  Dim iMax As Integer
  Dim hComponent As CComponent
  Dim cNewAll As New Collection
  Dim iInd As Integer

  For Each hComponent In All
    hComponent.CalcSortKey
    iMax = Max(iMax, hComponent.SortKey)
    'PRINT hComponent.Key;; hComponent.SortKey
  Next

  For iInd = 1 To iMax
    For Each hComponent In All
      If hComponent.SortKey = iInd Then
        cNewAll.Add(hComponent, hComponent.Key)
        'DEBUG hComponent.Key;; hComponent.SortKey
      Endif
    Next
  Next

  All = cNewAll

End


Static Private Sub InitComponentNames()
  
  $cName["gb"] = ("Internal native classes")
  $cName["gb.chart"] = ("Chart drawing")
  $cName["gb.compress"] = ("Compression & decompression")
  $cName["gb.corba"] = ("CORBA Client")
  $cName["gb.crypt"] = ("MD5/DES crypting")
  $cName["gb.db"] = ("Database access")
  $cName["gb.db.form"] = ("Data bound controls")
  $cName["gb.debug"] = ("Application debugger helper")
  $cName["gb.desktop"] = ("Desktop-neutral routines from Portland project")
  $cName["gb.eval"] = ("Expression evaluator")
  $cName["gb.form"] = ("More controls for graphical components")
  $cName["gb.form.dialog"] = ("Enhanced standard dialogs")
  $cName["gb.form.mdi"] = ("Multi Document Interface")
  $cName["gb.gtk"] = ("GTK+ toolkit")
  $cName["gb.gtk.ext"] = ("GTK+ toolkit extension")
  $cName["gb.gtk.svg"] = ("GTK+ SVG renderer")
  $cName["gb.gui"] = ("QT/GTK+ switcher component")
  $cName["gb.image"] = ("Image processing")
  $cName["gb.info"] = ("Information about components")
  $cName["gb.ldap"] = ("OpenLDAP client")
  $cName["gb.net"] = ("Networking")
  $cName["gb.net.curl"] = ("Network high-level protocols management")
  $cName["gb.net.smtp"] = ("STMP client")
  $cName["gb.opengl"] = ("3D programming with OpenGL")
  $cName["gb.option"] = ("GNU command option parser")
  $cName["gb.pcre"] = ("Perl-compatible Regular Expression Matching")
  $cName["gb.pdf"] = ("PDF renderer based on Poppler library")
  $cName["gb.qt"] = ("QT toolkit")
  $cName["gb.qt.ext"] = ("QT toolkit extension")
  $cName["gb.qte"] = ("QT/Embedded toolkit")
  $cName["gb.qte.ext"] = ("QT/Embedded toolkit extension")
  $cName["gb.qt.kde"] = ("KDE integration and scripting")
  $cName["gb.qt.kde.html"] = ("KDE web browser")
  $cName["gb.qt.opengl"] = ("OpenGL with QT toolkit")
  $cName["gb.report"] = ("Report designer")
  $cName["gb.sdl"] = ("SDL library")
  $cName["gb.sdl.sound"] = ("SDL sound & CD-ROM management")
  $cName["gb.settings"] = ("Application settings management")
  $cName["gb.v4l"] = ("Video capture")
  $cName["gb.vb"] = ("Visual Basic compatibility")
  $cName["gb.xml"] = ("XML tools based on libxml")
  $cName["gb.xml.rpc"] = ("XML-RPC protocol")
  $cName["gb.xml.xslt"] = ("XSLT tools based on libxslt")
  $cName["gb.web"] = ("Web applications tools")

  Features["form"] = ("Graphical form management")
  Features["eventloop"] = ("Event loop management")
  Features["imageprovider"] = ("Image provider")
  Features["openglviewer"] = ("OpenGL display")

End

Static Private Sub InitComponent(sFile As String, bUser As Boolean)
  
  Dim hComponent As CComponent
  Dim hFic As File
  Dim sInfo As String
  Dim sLig As String
  Dim sKey As String

  Dim iPos As Integer
  
  Dim sLib As String
  Dim iKey As Integer
  Dim sGroup As String

  If bUser Then
    Open Component.UserPath &/ sFile As #hFic
  Else
    Open Component.Path &/ sFile As #hFic
  Endif

  Line Input #hFic, sLig
  sLig = Trim(sLig)

  If sLig = "[Component]" Then

    hComponent = New CComponent
    hComponent.Key = File.BaseName(sFile)
    hComponent.Name = $cName[hComponent.Key]

    While NOT Eof(hFic)

      Line Input #hFic, sLig
      sLig = Trim(sLig)

      If NOT sLig Then Continue
      If Left(sLig) = ";" OR Left(sLig) = "'" Then Continue

      If sLig = "[Component]" Then Break

      If Left(sLig) = "[" AND If Right(sLig) = "]" Then
        sGroup = Mid$(sLig, 2, -1)
        Continue
      Endif

      iPos = InStr(sLig, "=")
      If iPos = 0 Then Continue

      sKey = Left$(sLig, iPos - 1)
      sLig = Mid$(sLig, iPos + 1)

      With hComponent

        ' IF sKey = "Key" THEN
        '   .Key = sLig
        ' ELSE IF sKey = "Name" THEN 'OR sKey = "Name[" & sLangShort & "]" OR sKey = "Name[" & sLang & "]" THEN
        '   PRINT "cName[\""; .Key; "\"] = (\""; sLig; "\")"
        '   .Name = sLig
        If sKey = "Author" OR sKey = "Authors" Then
          .Authors = Split(sLig)
        Else If sKey = "Type" Then
          .Type = sLig
        Else If sKey = "Group" Then
          sGroup = sLig
        Else If sKey = "Control" OR If sKey = "Controls" Then
          .Controls.Add("@" & sGroup)
          .Controls.Insert(Split(sLig))
        Else If sKey = "Container" Then
          .Containers.Insert(Split(sLig))
        Else If sKey = "MultiContainer" Then
          .MultiContainers.Insert(Split(sLig))
        Else If sKey = "Virtual" Then
          .Virtuals.Insert(Split(sLig))
        Else If sKey = "Require" OR sKey = "Requires" Then
          .Require = Split(LCase(sLig))
        Else If sKey = "Exclude" OR sKey = "Excludes" Then
          .Exclude = Split(LCase(sLig))
        Else If sKey = "Implement" OR sKey = "Implements" Then
          .Implement = Split(LCase(sLig))
        Else If sKey = "Need" OR sKey = "Needs" Then
          .Need = Split(LCase(sLig))
        Else If sKey = "Alpha" Then
          .State = UNSTABLE
        Else If sKey = "State" Then 
          .State = CInt(sLig)
        Endif

      End With

    Wend

    hComponent.User = bUser
  
    If hComponent.Key Then
      All[hComponent.Key] = hComponent
    Endif

  Endif

  Close #hFic
  
Catch 

  Debug "Unable to read component file:";; sFile
  
End

Static Public Sub FullReset()
  
  All.Clear
  Features.Clear
  _init  
  
End


Static Public Sub _init()

  Dim aComp As String[]
  Dim sFile As String

  $cName = New Collection
  InitComponentNames

  ' sLang = System.Language
  ' iPos = InStr(sLang, "_")
  ' IF iPos THEN
  '   sLangShort = Left$(sLang, iPos - 1)
  ' ELSE
  '   sLangShort = sLang
  ' ENDIF

  'OPEN Component.Path &/ "components" FOR READ AS #hFic
  
  aComp = Dir(Component.Path, "*.component").Sort()
  For Each sFile In aComp
    InitComponent(sFile, False)
  Next

  If Exist(Component.UserPath) Then
    aComp = Dir(Component.UserPath, "*.component").Sort()
    For Each sFile In aComp
      If All.Exist(File.BaseName(sFile)) Then 
        Print "Warning: User component "; File.BaseName(sFile); " is ignored"
        Continue
      Endif
      InitComponent(sFile, True)
    Next
  Endif

  SortComponents
  
  $cName = Null

  Reset

End


Public Sub CalcSortKey()

  Dim sComp As String
  Dim sNeed As String
  Dim hComp As CComponent

  'DEBUG ">>>";; Key

  If SortKey = 0 Then 

    If Require.Count OR If Need.Count Then

      For Each sComp In Require
        hComp = All[sComp]
        If hComp <> Me Then hComp.CalcSortKey
      Next
  
      For Each sNeed In Need
        For Each hComp In All
          If hComp.Implement.Find(sNeed) >= 0 Then
            hComp.CalcSortKey
          Endif
        Next
      Next

    Endif
    
    Inc $iKey
    SortKey = $iKey

  Endif
  
  'DEBUG "<<<";; Key;; "=";; SortKey

End

Public Sub Load()

  Dim hFic As File
  Dim sClass As String
  Dim sSymbol As String
  Dim sLig As String
  Dim iPos As Integer
  Dim hClass As CClassInfo
  Dim hSym As CSymbolInfo
  Dim hProp As CPropertyInfo
  Dim sParent As String
  Dim hForm As Form
  Dim sPath As String
  Dim bAgain As Boolean
  Dim bNextClass As Boolean
  Dim cClass As New Collection

  If Loaded Then Return

  'DEBUG "Loading: "; Key
  Project.SetMessage(Subst(("Loading information on component &1..."), Key))

  ClassList = New String[]

  For Each sLig In Require
    All[sLig].Load
  Next
  
  If User Then 
    sPath = File.Dir(File.Dir(Component.UserPath))
  Else  
    sPath = System.Path
  Endif 
  
  sPath &/= "share/" & "gambas" & System.Version & "/info" &/ Key & ".info"
  
  If NOT Exist(sPath) Then
    Print "Warning: cannot find "; sPath
    Return
  Endif

  ' List of exported classes

  For Each sClass In Split(File.Load(File.SetExt(sPath, "list")), "\n")
    If sClass Then cClass[sClass] = True
  Next

  Inc Application.Busy

  Repeat

    bAgain = False

    Open sPath As #hFic

    While NOT Eof(hFic)
      Line Input #hFic, sLig

      If Left$(sLig) = "#" Then

        bNextClass = False

        sClass = Mid$(sLig, 2)
        
        'DEBUG sClass

        If Classes.Exist(Key &/ sClass) Then
          'DEBUG "Class exists"
          bNextClass = True
          Continue
        Endif

        'IF sClass = "Dialog" THEN STOP

        Line Input #hFic, sParent
        If NOT sParent Then
          If Classes.Exist(sClass) Then
            sParent = sClass
          Endif
        Endif

        ' Ce test peut foirer si une classe veut hériter d'une autre classe
        ' du même composant, qui existe déjà dans un composant déjà déclaré.

        If sParent AND If NOT Classes.Exist(sParent) Then
          If NOT cClass.Exist(sParent) Then 
            Error.Raise("'" & sParent & "' class is missing in " & Key & " component exported classes")
          Endif
          bAgain = True
          bNextClass = True
          'DEBUG "Parent does not exist:";; sParent
          Continue
        Endif

        hClass = New CClassInfo(sClass, sParent)

        Classes[Key &/ sClass] = hClass
        If Type Then Classes[Type &/ sClass] = hClass
        Classes[sClass] = hClass
        If sClass <> "." Then ClassList.Add(sClass)

        Line Input #hFic, sLig
        hClass.Creatable = InStr(sLig, "C")
        hClass.AutoCreatable = InStr(sLig, "A")
        hClass.Component = Key

        Continue

      Endif

      If bNextClass Then Continue

      sSymbol = sLig
      hSym = New CSymbolInfo
      Classes[sClass].Symbols[sSymbol] = hSym

      hSym.Name = sSymbol
      hSym.Class = sClass
      hSym.Component = Key
      Line Input #hFic, hSym.Kind
      Line Input #hFic, hSym.Type
      If hSym.Kind = "C" Then
        Line Input #hFic, hSym.Value
      Else
        Line Input #hFic, hSym.Signature
      Endif
      If Left$(hSym.Kind) = "p" Then
        If Left$(hSym.Type, 2) = "i<" Then
          hSym.Signature = Mid$(hSym.Type, 3, -1)
          hSym.Type = "i"
        Endif
      Endif

    Wend

    Close #hFic

  Until NOT bAgain

  'PRINT "Initializing controls..."

  hForm = New Form

  'IF Key = "gb.qt" THEN
  If Type = "Form" Then
    'IF Key = "gb.gtk" THEN
    '  FOR EACH sClass IN ["Control", "Form"]
    '    Classes[sClass].InitControl(hForm)
    '  NEXT
    'ELSE
      For Each sClass In ["Control", "Form", "Menu"]
        If Classes.Exist(sClass) Then
          Classes[sClass].InitControl(hForm)
        Endif
      Next
    'ENDIF
  Endif

  For Each sClass In Controls
    If Left(sClass) = "@" Then Continue
    If Classes.Exist(sClass) Then
      Classes[sClass].InitControl(hForm)
    Else
      Debug "Control "; sClass; " not found"
    Endif
  Next

  hForm.Close

  ClassList.Sort

  'PRINT "OK"

  Loaded = True

Finally

  Dec Application.Busy

Catch

  FGambas.Error(Error.Where & "\n\n" & Error.Text)

End

Static Public Sub Exit()

  All = Null
  Classes = Null

End

Static Private Sub MakeInheritance(hModule As Object, cSymbol As Collection, sParent As String, Optional sComponent As String)
  
  Dim cClassSymbol As Collection  
  Dim hSymbol As CSymbolInfo
    
  hModule.ParentClass = sParent
  If NOT hModule.AutoCreatable Then hModule.AutoCreatable = IsAutoCreatable(hModule.ParentClass)
  cClassSymbol = CComponent.GetClassSymbols(sComponent &/ sParent)
  If cClassSymbol Then
    For Each hSymbol In cClassSymbol
      cSymbol[hSymbol.Name] = hSymbol
    Next
  Endif
  
End


Static Private Sub ScanClass(hModule As Object, cSymbol As Collection, bModule As Boolean, Optional bCanInherit As Boolean = True)

  Dim hEditor As Editor
  Dim iLine As Integer
  Dim aSym As String[]
  Dim bStatic As Boolean
  Dim bPublic As Boolean
  Dim sKind As String
  Dim iInd As Integer
  Dim hSymbol As CSymbolInfo
  Dim iStart As Integer
  Dim iEnd As Integer
  Dim iSign As Integer
  Dim cClassSymbol As Collection
  Dim sParent As String
  Dim hClass As CClassInfo
  Dim sName As String
  Dim sLine As String
  Dim iPos As Integer

  'PRINT "ScanClass "; hModule.Name
  'DEBUG "> "; hModule.Name

  hEditor = hModule.Editor
  hModule.AutoCreatable = False
  hModule.NotCreatable = False
  'DEBUG hModule.Name; " := "; hModule.AutoCreatable

  'IF hModule.Name = "Desktop" THEN STOP

  hClass = Classes[hModule.Name]
  
  If hClass AND If hClass.Component = Project.Name AND If hClass.Parent Then 
    hClass = Classes[hClass.Parent]
  Endif
  
  If hClass Then 
    sParent = hModule.Name
    MakeInheritance(hModule, cSymbol, sParent, hClass.ParentComponent)
    bCanInherit = False
  Endif 
  
  For iLine = 0 To hEditor.Lines.Count - 1

    aSym = Highlight.Analyze(hEditor.Lines[iLine].Text)
    If aSym.Count = 0 Then Continue
    'aSym.Insert(["", "", ""])

    If aSym.Count = 2 Then
      If bCanInherit Then
        If aSym[0] = "INHERITS" Then
          If Highlight.Types[1] = Highlight.Datatype Then
            sParent = aSym[iInd + 1]
            MakeInheritance(hModule, cSymbol, sParent)
          Endif
          bCanInherit = False
        Endif
      Endif
    Endif

    If aSym[0] = "CREATE" Then 
      If aSym.Count = 1 OR If aSym[1] = "STATIC" Then 
        hModule.AutoCreatable = True
        'DEBUG hModule.Name; " := "; hModule.AutoCreatable
      Else If aSym[1] = "PRIVATE" Then 
        hModule.NotCreatable = True
      Endif
    Endif

    bStatic = bModule
    bPublic = False
    sKind = ""

    For iInd = 0 To aSym.Count - 1
      Select Case aSym[iInd]
        Case "INHERITS"
        Case "PUBLIC"
          sKind = "v"
          bPublic = True
        Case "PRIVATE"
          sKind = "v"
          bPublic = False
        Case "STATIC"
          sKind = "v"
          bStatic = True
        Case "PROPERTY"
          sKind = "p"
          bPublic = True
        Case "READ"
          If sKind = "p" Then sKind = "r"
          Inc iInd
          Break
        Case "EVENT"
          sKind = ":"
          bStatic = False
          Inc iInd
          Break
        Case "SUB", "PROCEDURE", "FUNCTION"
          sKind = "m"
          Inc iInd
          Break
        Case "CONST"
          sKind = "C"
          bStatic = True
          Inc iInd
          Break
        Case Else
          Break
      End Select
    Next

    'IF NOT bPublic THEN CONTINUE
    If NOT sKind Then Continue
    If iInd >= aSym.Count Then Continue

    sName = aSym[iInd]
    If Left(sName) = "{" Then
      If iInd + 2 > aSym.Max Then Continue
      Inc iInd
      sName = aSym[iInd]
      If aSym[iInd + 1] = "}" Then Inc iInd
    Endif

    hSymbol = New CSymbolInfo
    With hSymbol
      .Name = sName
      .Class = hModule.Name
      .Kind = sKind
      .NotPublic = NOT bPublic
      .LineNumber = iLine + 1
      
      If sKind = "m" Then

        For iStart = iInd + 1 To aSym.Count - 1
          If aSym[iStart] = "(" Then Break
        Next

        For iInd = aSym.Count - 1 To 0 Step -1
          If aSym[iInd] = ")" Then
            Break
          Else If aSym[iInd] = "AS" Then
            If iInd < (aSym.Count - 1) Then
              .Type = FEditor.ReadSymbolType(aSym, iInd)
            Endif
          Endif
        Next

        'iEnd = iInd
        Try .Signature = "#" & Mid$(hEditor.Lines[iLine].Text, Highlight.Positions[iStart] + 1)
        
        
        'FOR iInd = iStart TO iEnd
        '  .Signature = .Signature & aSym[iInd] & " "
        'NEXT

      Else
        Inc iInd
        .Type = FEditor.ReadSymbolType(aSym, iInd)
      Endif

      If bStatic Then .Kind = UCase(.Kind)

      cSymbol[.Name] = hSymbol
      bCanInherit = False
      
    End With

    If sKind = "m" Then 
      Do
        Inc iLine
        If iLine >= hEditor.Lines.Count Then Break
        sLine = Trim(hEditor.Lines[iLine].Text)
        iPos = InStr(sLine, "'")
        If iPos Then sLine = Trim(Left(sLine, iPos - 1))
        If Len(sLine) = 3 AND If UCase(sLine) = "END" Then Break
        If Len(sLine) = 7 AND If UCase(sLine) = "END SUB" Then Break
        'aSym = Highlight.Analyze(hEditor.Lines[iLine])
        'IF aSym.Count = 1 AND IF aSym[0] = "END" THEN BREAK
      Loop
    Endif

  Next

  'DEBUG "< "; hModule.Name

End


Static Private Sub ScanForm(hForm As FForm, cSymbol As Collection)

  Dim hControl As CControl
  Dim hSymbol As CSymbolInfo

  'PRINT "ScanForm "; hForm.Name

  For Each hControl In hForm.Control
    If hControl.Name = hForm.Name Then Continue
    hSymbol = New CSymbolInfo
    With hSymbol
      .Name = hControl.Name
      .Type = hControl.Kind
      .Class = hForm.Name
      .Kind = "t"
      .NotPublic = NOT Project.ControlPublic
      cSymbol[.Name] = hSymbol
    End With
  Next

End

Static Private Sub GetModule(sClass As String) As Object

  Dim sPath As String
  
  sPath = Project.Dir &/ sClass & ".module"
  If Exist(sPath) Then Return Project.LoadFile(sPath)
  sPath = Project.Dir &/ sClass & ".form"
  If Exist(sPath) Then Return Project.LoadFile(sPath)
  sPath = Project.Dir &/ sClass & ".class"
  If Exist(sPath) Then Return Project.LoadFile(sPath)
  
End

Static Public Sub IsAutoCreatable(sClass As String) As Boolean

  Dim hClass As CClassInfo
  Dim hModule As Object
  
  GetClassSymbols(sClass)

  hClass = CComponent.Classes[sClass]
  If hClass Then Return hClass.AutoCreatable

  hModule = GetModule(sClass)
  If hModule IS FEditor Then 
    'DEBUG sClass; " -> "; hModule.AutoCreatable
    Return hModule.AutoCreatable
  Endif
  
End


Static Public Function GetClassSymbols(sClass As String, Optional bInProject As Boolean) As Collection

  Dim hClass As CClassInfo
  Dim sName As String
  Dim sPath As String
  Dim hPForm As Object
  Dim hPModule As Object
  Dim hPClass As Object
  Dim hModule As Object
  Dim cSymbol As Collection
  Dim hSymbol As CSymbolInfo
  Dim iFind As Integer
  Dim aClass As String[]

  'IF Len(sClass) <= 1 THEN
  '  IF sClass <> "." THEN RETURN
  'ENDIF

  hClass = CComponent.Classes[sClass]
  If hClass Then
    If hClass.Component <> Project.Name Then
      Return hClass.Symbols
    Endif
  Endif

  aClass = Project.GetClasses()
  iFind = aClass.Find(sClass, gb.Text)

  If iFind < 0 Then
    If hClass Then
      Return hClass.Symbols
    Else
      Return
    Endif
  Endif

  sClass = aClass[iFind]

  sPath = Project.Dir &/ sClass & ".module"
  If Exist(sPath) Then hPModule = Project.LoadFile(sPath)
  sPath = Project.Dir &/ sClass & ".form"
  If Exist(sPath) Then hPForm = Project.LoadFile(sPath)
  sPath = Project.Dir &/ sClass & ".class"
  If Exist(sPath) Then hPClass = Project.LoadFile(sPath)

  cSymbol = New Collection

  If hPModule Then
    cSymbol = hPModule.Scan
    If NOT cSymbol Then
      cSymbol = New Collection(gb.Text)
      hPModule.Scan = cSymbol
      ScanClass(hPModule, cSymbol, True)
    Endif
  Else If hPClass Then
    cSymbol = hPClass.Scan
    If NOT cSymbol Then
      cSymbol = New Collection(gb.Text)
      hPClass.Scan = cSymbol
      If hPForm Then
        For Each hSymbol In CComponent.Classes["Form"].Symbols
          cSymbol[hSymbol.Name] = hSymbol
        Next
        ScanForm(hPForm, cSymbol)
      Endif
      ScanClass(hPClass, cSymbol, False, IsNull(hPForm))
    Endif
  Endif

  Return cSymbol

End


Static Public Sub Reset()

  Dim hComponent As CComponent

  For Each hComponent In All
    hComponent.Loaded = False
  Next

  Classes = New Collection(gb.Text)

  All["gb"].Load

End
