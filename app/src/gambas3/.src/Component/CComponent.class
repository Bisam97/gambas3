' Gambas class file

Static Public All As New Collection
Static Public Libraries As New String[]
Static Public Classes As Collection
Static Private $iKey As Integer

Public Const PROJECT_NAME As String = "$"

Public Const STABLE As Integer = 0
Public Const STABLE_NOT_FINISHED As Integer = 1
Public Const UNSTABLE As Integer = 2

Public Key As String
Public Name As String
Public Authors As New String[]
'Public Type As String
Public Hiddens As New String[]
Public Controls As New String[]
'Public Containers As New String[]
'Public MultiContainers As New String[]
'Public Virtuals As New String[]
Public Require As New String[]
Public Exclude As New String[]
Public Implement As New String[]
Public Need As New String[]
Public Loaded As Boolean
Public ClassList As New String[]
Public State As Integer
Public SortKey As Integer
'Public User As Boolean
Public Version As String
Public Family As String
Public ThirdParty As Boolean
Public Hidden As Boolean

Public {Library} As Boolean
Public Path As String

Static Public Features As New Collection

Static Private $cName As Collection
Static Private Similars As New Collection

Static Private $hDumbClass As CClassInfo
Static Private $hClass As CClassInfo

Private $bCalcKey As Boolean

Static Private Sub SortComponents()

  Dim iMax As Integer
  Dim hComponent As CComponent
  Dim cNewAll As New Collection
  Dim iInd As Integer

  For Each hComponent In All
    hComponent.CalcSortKey
    iMax = Max(iMax, hComponent.SortKey)
    'PRINT hComponent.Key;; hComponent.SortKey
  Next

  For iInd = 1 To iMax
    For Each hComponent In All
      If hComponent.SortKey = iInd Then
        cNewAll.Add(hComponent, hComponent.Key)
        'DEBUG hComponent.Key;; hComponent.SortKey
      Endif
    Next
  Next

  All = cNewAll

End


Static Private Sub InitComponentNames()
  
  $cName["gb"] = ("Internal native classes")
  $cName["gb.cairo"] = ("Cairo graphic library")
  $cName["gb.chart"] = ("Chart drawing")
  $cName["gb.compress"] = ("Compression & decompression")
  $cName["gb.crypt"] = ("MD5/DES crypting")
  $cName["gb.db"] = ("Database access")
  $cName["gb.db.firebird"] = ("Firebird database driver")
  $cName["gb.db.form"] = ("Data bound controls")
  $cName["gb.db.mysql"] = ("MySQL database driver")
  $cName["gb.db.odbc"] = ("ODBC database driver")
  $cName["gb.db.postgresql"] = ("PostgreSQL database driver")
  $cName["gb.db.sqlite2"] = ("SQLite 2 database driver")
  $cName["gb.db.sqlite3"] = ("SQLite 3 database driver")
  $cName["gb.debug"] = ("Application debugger helper")
  $cName["gb.desktop"] = ("Desktop-neutral routines from Portland project")
  $cName["gb.dbus"] = ("D-Bus interface")
  $cName["gb.eval"] = ("Expression evaluator")
  $cName["gb.eval.highlight"] = ("Syntax highlighter routines")
  $cName["gb.form"] = ("More controls for graphical components")
  $cName["gb.form.dialog"] = ("Enhanced standard dialogs")
  $cName["gb.form.mdi"] = ("Multi Document Interface")
  $cName["gb.gtk"] = ("GTK+ toolkit")
  $cName["gb.gtk.ext"] = ("GTK+ toolkit extension")
  $cName["gb.gtk.opengl"] = ("OpenGL with GTK+ toolkit")
  $cName["gb.gtk.svg"] = ("GTK+ SVG renderer")
  $cName["gb.gui"] = ("QT/GTK+ switcher component")
  $cName["gb.image"] = ("Image management")
  $cName["gb.image.effect"] = ("Image filtering component")
  $cName["gb.image.imlib"] = ("Image routines from the Imlib2 library")
  $cName["gb.image.io"] = ("Image loading and saving")
  $cName["gb.info"] = ("Information about components")
  $cName["gb.ldap"] = ("OpenLDAP client")
  $cName["gb.mysql"] = ("MySQL specific routines")
  $cName["gb.net"] = ("Network programming")
  $cName["gb.net.curl"] = ("Network high-level protocols management")
  $cName["gb.net.smtp"] = ("SMTP client")
  $cName["gb.opengl"] = ("3D programming with OpenGL")
  $cName["gb.opengl.glsl"] = ("OpenGL shaders management")
  $cName["gb.option"] = ("GNU command option parser")
  $cName["gb.pcre"] = ("Perl-compatible Regular Expression Matching")
  $cName["gb.pdf"] = ("PDF renderer based on Poppler library")
  $cName["gb.qt4"] = ("QT4 toolkit")
  $cName["gb.qt4.ext"] = ("QT4 toolkit extension")
  $cName["gb.qt4.webkit"] = ("QT4 WebKit component")
  $cName["gb.qt4.opengl"] = ("OpenGL with QT4 toolkit")
  $cName["gb.report"] = ("Report designer")
  $cName["gb.sdl"] = ("SDL library")
  $cName["gb.sdl.sound"] = ("SDL sound & CD-ROM management")
  $cName["gb.settings"] = ("Application settings management")
  $cName["gb.signal"] = ("Signals management")
  $cName["gb.v4l"] = ("Video capture")
  $cName["gb.vb"] = ("Visual Basic compatibility")
  $cName["gb.xml"] = ("XML tools based on libxml")
  $cName["gb.xml.rpc"] = ("XML-RPC protocol")
  $cName["gb.xml.xslt"] = ("XSLT tools based on libxslt")
  $cName["gb.web"] = ("Web applications tools")

  ' For Each $cName
  '   Print "gambas3-"; Replace($cName.Key, ".", "-")
  ' Next

  Features["form"] = ("Graphical form management")
  Features["eventloop"] = ("Event loop management")
  Features["imageio"] = ("Image loading and saving")
  Features["openglviewer"] = ("OpenGL display")

End

Static Public Sub AddSimilar(sCtrl As String, sSimilar As String)
  
  Dim aSimilar As String[]
  
  aSimilar = Similars[sSimilar]
  If Not aSimilar Then
    aSimilar = New String[]
    Similars[sSimilar] = aSimilar
  Endif
  aSimilar.Add(sCtrl)
  
End

Static Public Sub GetSimilars(sCtrl As String) As String[]
  
  Dim aSimilar As String[] = Similars[sCtrl]
  
  If Not aSimilar Then aSimilar = New String[]
  
  Return aSimilar
  
End





' Static Public Sub GetChanges(sKind As String) As String[]
'   
'   Dim sGroup As String
'   Dim aChange As New String[]
'   Dim aGroup As String[]
'   Dim sChange As String
'   
'   aGroup = Changes[sKind]
'   If aGroup Then
'     For Each sGroup In aGroup
'       For Each sChange In Changes[sGroup]
'         If Not aChange.Exist(sChange) Then aChange.Add(sChange)
'       Next
'     Next
'   Endif
' 
'   Return aChange
'   
' End


Static Private Sub InitComponent(sFile As String)
  
  Dim hComponent As CComponent
  Dim hFic As File
  Dim sInfo As String
  Dim sLig As String
  Dim sKey As String
  Dim sPath As String
  Dim iPos As Integer
  Dim sLib As String
  Dim iKey As Integer
  Dim sGroup As String
  Dim aChange As String[]
  Dim aStr As String[]
  Dim sChange As String
  
  sPath = Component.Path &/ sFile 
  
  Try hFic = Open sPath
  If Error Then
    Error "Warning: cannot read "; sPath
    Return
  Endif

  Line Input #hFic, sLig
  sLig = Trim(sLig)

  If sLig = "[Component]" Then

    hComponent = New CComponent
    hComponent.Key = File.BaseName(sFile)
    hComponent.ThirdParty = Not $cName.Exist(hComponent.key)
    hComponent.Name = $cName[hComponent.Key]
    If Not hComponent.Name Then hComponent.Name = " " 'Subst(("&1 component"), hComponent.Key)

    While Not Eof(hFic)

      Line Input #hFic, sLig
      sLig = Trim(sLig)

      If Not sLig Then Continue
      If Left(sLig) = ";" Or Left(sLig) = "'" Then Continue

      If sLig = "[Component]" Then Break

      If Left(sLig) = "[" And If Right(sLig) = "]" Then
        sGroup = Mid$(sLig, 2, -1)
        Continue
      Endif

      iPos = InStr(sLig, "=")
      If iPos = 0 Then Continue

      sKey = Left$(sLig, iPos - 1)
      sLig = Mid$(sLig, iPos + 1)

      With hComponent
      
          If sKey = "Author" Or sKey = "Authors" Then
            .Authors = Split(sLig)
          Else If sKey = "Require" Or sKey = "Requires" Then
            .Require = Split(sLig)
          Else If sKey = "Exclude" Or sKey = "Excludes" Then
            .Exclude = Split(sLig)
          Else If sKey = "Implement" Or sKey = "Implements" Then
            .Implement = Split(LCase(sLig))
          Else If sKey = "Need" Or sKey = "Needs" Then
            .Need = Split(LCase(sLig))
          Else If sKey = "Alpha" Then
            .State = UNSTABLE
          Else If sKey = "State" Then 
            .State = CInt(sLig)
          Else If sKey = "Version" Then
            .Version = sLig
          Else If sKey = "Hidden" Then
            .Hidden = sLig = "True"
          Endif
          
        ' Endif

      End With

    Wend

    If hComponent.Key Then
      All[hComponent.Key] = hComponent
    Endif

  Endif

  Close #hFic
  
Catch 

  Debug "Unable to read component file:";; sFile
  
End

Static Public Sub FullReset()
  
  All.Clear
  Features.Clear
  _init  
  
End


Static Public Sub _init()

  Dim aComp As String[]
  Dim sFile As String
  Dim hComp As CComponent

  $cName = New Collection
  InitComponentNames

  ' sLang = System.Language
  ' iPos = InStr(sLang, "_")
  ' IF iPos THEN
  '   sLangShort = Left$(sLang, iPos - 1)
  ' ELSE
  '   sLangShort = sLang
  ' ENDIF

  'OPEN Component.Path &/ "components" FOR READ AS #hFic
  
  aComp = Dir(Component.Path, "*.component").Sort()
  For Each sFile In aComp
    'If Not $cName.Exist(File.BaseName(sFile)) Then Continue
    InitComponent(sFile)
  Next

  ' If Exist(Component.UserPath) Then
  '   aComp = Dir(Component.UserPath, "*.component").Sort()
  '   For Each sFile In aComp
  '     If All.Exist(File.BaseName(sFile)) Then 
  '       Error "Warning: User component "; File.BaseName(sFile); " is ignored"
  '       Continue
  '     Endif
  '     InitComponent(sFile, True)
  '   Next
  ' Endif

  hComp = New CComponent
  hComp.Key = PROJECT_NAME
  hComp.Name = " "
  All[hComp.Key] = hComp

  SortComponents
  
  $cName = Null

  Reset

End


Public Sub CalcSortKey()

  Dim sComp As String
  Dim sNeed As String
  Dim hComp As CComponent

  If SortKey = 0 Then 

    If $bCalcKey Then Return

    $bCalcKey = True

    If Require.Count Or If Need.Count Then

      For Each sComp In Require
        hComp = All[sComp]
        If Not hComp Then Continue
        If hComp <> Me Then hComp.CalcSortKey
      Next
  
      For Each sNeed In Need
        For Each hComp In All
          If hComp.Implement.Find(sNeed) >= 0 Then
            hComp.CalcSortKey
          Endif
        Next
      Next

    Endif
    
    Inc $iKey
    SortKey = $iKey
    'DEBUG Key;; "=";; SortKey

    $bCalcKey = False

  Endif
  
End

Static Private Sub CreateClass(sClass As String, sParent As String, sComp As String) As CClassInfo

  Dim hClass As CClassInfo
  Dim hComp As CComponent
  
  hClass = New CClassInfo(sClass, sParent)

  Classes[sComp &/ sClass] = hClass
  Classes[sClass] = hClass
  hClass.Component = sComp

  hComp = All[sComp]
  If hComp Then  
    'If hComp.Type Then Classes[hComp.Type &/ sClass] = hClass
    If sClass <> "." Then hComp.ClassList.Add(sClass)
  End If
  
  Return hClass
  
End

Public Sub Load()

  Dim hFic As File
  Dim sClass As String
  Dim sSymbol As String
  Dim sLig As String
  Dim iPos As Integer
  Dim hClass As CClassInfo
  Dim hSym As CSymbolInfo
  Dim hProp As CPropertyInfo
  Dim sParent As String
  Dim hForm As Form
  Dim sPath As String
  Dim bAgain As Boolean
  Dim bNextClass As Boolean
  Dim cClass As New Collection
  Dim aList As String[]
  Dim hLibraryInfo As CLibraryInfo
  Dim sTemp As String

  If Loaded Then Return

  'Debug "Loading: "; Key
  Project.SetMessage(Subst(("Loading information on component &1..."), Key))

  ClassList = New String[]
  Controls = New String[]

  For Each sLig In Require
    All[sLig].Load
  Next
  
  If {Library} Then
  
    hLibraryInfo = New CLibraryInfo(Path)
    hLibraryInfo.GetInfo()
    sPath = Temp$()
    File.Save(sPath, hLibraryInfo.Info)
    aList = hLibraryInfo.Classes
  
  Else
  
    If Key = PROJECT_NAME Then
      sPath = Project.Dir &/ ".info"
      If Not Exist(sPath) Then Return
    Else
      sPath = System.Path &/ "share/" & "gambas" & System.Version & "/info" &/ Key & ".info"
      If Not Exist(sPath) Then
        Error "Warning: cannot find "; sPath
        Return
      Endif
    Endif
    
  
    ' List of exported classes
  
    Try aList = Split(File.Load(File.SetExt(sPath, "list")), "\n", "", True)
    If Error Then
      Error "Warning: cannot read "; File.SetExt(sPath, "list")
      Return
    Endif
    
  Endif

  For Each sClass In aList
    If sClass Then cClass[sClass] = True
  Next

  Inc Application.Busy

  Repeat

    bAgain = False

    hFic = Open sPath

    While Not Eof(hFic)
      Line Input #hFic, sLig

      If Left$(sLig) = "#" Then

        bNextClass = False

        sClass = Mid$(sLig, 2)
        
        'DEBUG sClass

        If Classes.Exist(Key &/ sClass) Then
          'DEBUG "Class exists"
          bNextClass = True
          Continue
        Endif

        'IF sClass = "Dialog" THEN STOP

        Line Input #hFic, sParent
        If Not sParent Then
          If Classes.Exist(sClass) Then
            sParent = sClass
          Endif
        Endif

        ' Ce test peut foirer si une classe veut hériter d'une autre classe
        ' du même composant, qui existe déjà dans un composant déjà déclaré.

        If sParent And If Not Classes.Exist(sParent) Then
          If Not cClass.Exist(sParent) Then 
            Error.Raise("'" & sParent & "' class is missing in " & Key & " component exported classes")
          Endif
          bAgain = True
          bNextClass = True
          'DEBUG "Parent does not exist:";; sParent
          Continue
        Endif

        hClass = CreateClass(sClass, sParent, Key)

        Line Input #hFic, sLig
        hClass.Creatable = InStr(sLig, "C")
        hClass.AutoCreatable = InStr(sLig, "A")

        Continue

      Endif

      If bNextClass Then Continue

      sSymbol = sLig
      hSym = New CSymbolInfo
      Classes[sClass].Symbols[sSymbol] = hSym

      hSym.Name = sSymbol
      hSym.Class = sClass
      hSym.Component = Key
      Line Input #hFic, hSym.Kind
      Line Input #hFic, hSym.Type
      If hSym.Kind = "C" Then
        Line Input #hFic, hSym.Value
      Else
        Line Input #hFic, hSym.Signature
      Endif
      If Left$(hSym.Kind) = "p" Then
        If Left$(hSym.Type, 2) = "i<" Then
          hSym.Signature = Mid$(hSym.Type, 3, -1)
          hSym.Type = "i"
        Endif
      Endif

    Wend

    Close #hFic

  Until Not bAgain

  'PRINT "Initializing controls..."

  ' If Type = "Form" Then
  '   For Each sClass In ["Control", "Form", "Menu"]
  '     If Classes.Exist(sClass) Then
  '       Classes[sClass].InitControl()
  '     Endif
  '   Next
  ' Endif
  
  For Each sClass In ClassList
    hClass = Classes[sClass]

    hSym = hClass.Symbols["_IsControl"]
    If hSym And If hSym.Value Then
      Controls.Add(hClass.Name)
    Endif
    
    hSym = hClass.Symbols["_IsForm"]
    If hSym And If hSym.Value Then
      hSym = hClass.Symbols["_HiddenControls"]
      If hSym Then Hiddens = Split(hSym.Value, ",")
    Endif
    
  Next

  For Each sClass In Hiddens
    If Classes.Exist(sClass) Then
      Classes[sClass].InitControl()
      iPos = Controls.Find(sClass)
      If iPos >= 0 Then Controls.Remove(iPos)
    Endif
  Next
  
  For Each sClass In Controls
    Classes[sClass].InitControl()
  Next

  ClassList.Sort

  'PRINT "OK"

  Loaded = True

Finally

  Dec Application.Busy

Catch

  FMain.ShowError(Error.Where & "\n\n" & Error.Text)

End

Static Public Sub Exit()

  All = Null
  Classes = Null
  CModule.Exit

End

Static Private Sub MakeInheritance(hModule As Object, cSymbol As Collection, sParent As String, Optional sComponent As String)
  
  Dim cClassSymbol As Collection  
  Dim hSymbol As CSymbolInfo

  'Debug hModule.Name;; "->";; sParent;; sComponent

  hModule.ParentClass = sParent
  If Not hModule.AutoCreatable Then hModule.AutoCreatable = IsAutoCreatable(hModule.ParentClass)
  cClassSymbol = CComponent.GetClassSymbols(sComponent &/ sParent)
  If cClassSymbol Then
    For Each hSymbol In cClassSymbol
      cSymbol[hSymbol.Name] = hSymbol
    Next
  Endif
  
End


' Static Private Sub ConvertSignature(sCode As String) As String
'   
'   Dim iInd As Integer
'   Dim aSym As String[]
'   Dim sSign As Integer
'   Dim bOptional As Boolean
'   Dim sType As String
'   
'   aSym = Highlight.Analyze("Sub Func(" & sCode & ")")
'   
'   aSym.Remove(0, 3)
'   aSym.Remove(aSym.Max)
'   
'   Do
'   
'     If aSym[iInd] = "OPTIONAL" Then
'       sSign &= "["
'       bOptional = True
'     Endif
'     sSign &= "(" & aSym[iInd] & ")"
'     Inc iInd
'     If aSym[iInd] <> "AS" Then Break
'     Inc iInd
'     sType = FEditor.ReadSymbolType(aSym, iInd)
'     If Len(sType) > 1 Then sType &= ";"
'     sSign &= sType
'     
'     Do
'     Loop
'   
'   Loop
'   
'   If bOptional Then sSign &= "]"
' 
' Finally
' 
'   Return sSign
' 
' End

Static Private Sub ScanStruct(hModule As Object, iLine As Integer) As Integer
  
  Dim hEditor As Editor
  Dim aSym As String[]
  Dim iInd As Integer
  Dim sClass As String
  Dim hSymbol As CSymbolInfo
  Dim cSymbol As New Collection
  Dim hClass As CClassInfo
  
  hEditor = hModule.Editor
  
  aSym = Highlight.Analyze(hEditor.Lines[iLine].Text)
  
  For iInd = 0 To aSym.Max - 1
    If aSym[iInd] = "STRUCT" Then Break
  Next
  If iInd = aSym.Max Then Return iLine
  
  sClass = aSym[iInd + 1]
  
  Do
    Inc iLine
    If iLine >= hEditor.Lines.Count Then Return iLine
    
    aSym = Highlight.Analyze(hEditor.Lines[iLine].Text)
    
    If aSym.Count >= 2 And If aSym[0] = "END" And If aSym[1] = "STRUCT" Then Break
    
    If aSym.Count = 0 Then Continue
    If Highlight.Types[0] <> Highlight.Symbol Then Continue
    
    hSymbol = New CSymbolInfo
    With hSymbol
      .Name = aSym[0]
      .Class = sClass
      .Kind = "v"
      .NotPublic = False
      .LineNumber = iLine + 1
      .Type = FEditor.ReadSymbolType(aSym, 1)
      cSymbol[.Name] = hSymbol
    End With

  Loop
  
  hClass = Classes[sClass]
  If hClass And If Not hClass.Structure Then Return
  
  hClass = New CClassInfo(sClass)
  'hClass.Component = hModuleClass.Component
  hClass.Structure = True
  hClass.Symbols = cSymbol
  hClass.DeclareIn = hModule.Name
  
  Classes[sClass] = hClass
  
  Return iLine
  
End


Static Private Sub ScanClass(hModule As Object, cSymbol As Collection, bModule As Boolean, Optional bCanInherit As Boolean = True)

  Dim hEditor As Editor
  Dim iLine As Integer
  Dim aSym As String[]
  Dim bStatic As Boolean
  Dim bPublic As Boolean
  Dim sKind As String
  Dim iInd As Integer
  Dim hSymbol As CSymbolInfo
  Dim aSymbol As CSymbolInfo[]
  Dim iStart As Integer
  Dim iEnd As Integer
  Dim iSign As Integer
  Dim cClassSymbol As Collection
  Dim hClass As CClassInfo
  Dim sName As String
  Dim sLine As String
  Dim iPos As Integer
  Dim sSign As String
  Dim bExport As Boolean

  'Debug "ScanClass "; hModule.Name
  'DEBUG "> "; hModule.Name

  hEditor = hModule.Editor
  hModule.AutoCreatable = False
  hModule.NotCreatable = False
  'DEBUG hModule.Name; " := "; hModule.AutoCreatable

  If bCanInherit Then
    hClass = Classes[hModule.Name]
    
    ' If hClass And If hClass.Component = Project.Name And If hClass.Parent Then 
    '   hClass = Classes[hClass.Parent]
    ' Endif
    
    If hClass Then
      If hClass.Component <> Project.Name And If hClass.Component <> CComponent.PROJECT_NAME Then
        MakeInheritance(hModule, cSymbol, hClass.Name, hClass.Component)
        bCanInherit = False
      Endif
    Endif 
  Endif
  
  For iLine = 0 To hEditor.Lines.Count - 1

    aSym = Highlight.Analyze(hEditor.Lines[iLine].Text)
    If aSym.Count = 0 Then Continue
    If Highlight.Types[0] = Highlight.Comment Or If Highlight.Types[0] = Highlight.Help Then Continue
    
    Select Case aSym[0]
    
      Case "INHERITS"
      
        If aSym.Count >= 2 And If bCanInherit And If Highlight.Types[1] = Highlight.Datatype Then
          MakeInheritance(hModule, cSymbol, aSym[iInd + 1])
          bCanInherit = False
        Endif
        Continue
      
      Case "CREATE"
        If aSym.Count = 1 Or If aSym[1] = "STATIC" Then 
          hModule.AutoCreatable = True
          'DEBUG hModule.Name; " := "; hModule.AutoCreatable
        Else If aSym[1] = "PRIVATE" Then 
          hModule.NotCreatable = True
        Endif
      
      Case "EXPORT"
        bExport = True
      Default
        Break
    
    End Select
    
  Next 

  If bExport And If bCanInherit And If Classes.Exist(hModule.Name) Then
    'sParent = aSym[iInd + 1]
    MakeInheritance(hModule, cSymbol, hModule.Name, Classes[hModule.Name].Component)
    bCanInherit = False
  Endif

  For iLine = iLine To hEditor.Lines.Count - 1

    aSym = Highlight.Analyze(hEditor.Lines[iLine].Text)
    If aSym.Count = 0 Then Continue
    
    bStatic = bModule
    bPublic = False
    If bModule And Project.ModulePublic Then bPublic = True
    sKind = ""

    For iInd = 0 To aSym.Count - 1
      Select Case aSym[iInd]
        Case "PUBLIC"
          sKind = "v"
          bPublic = True
        Case "PRIVATE"
          sKind = "v"
          bPublic = False
        Case "STATIC"
          sKind = "v"
          bStatic = True
        Case "PROPERTY"
          sKind = "p"
          bPublic = True
        Case "READ"
          If sKind = "p" Then sKind = "r"
          Inc iInd
          Break
        Case "EVENT"
          sKind = ":"
          bStatic = False
          Inc iInd
          Break
        Case "SUB", "PROCEDURE", "FUNCTION"
          sKind = "m"
          Inc iInd
          Break
        Case "EXTERN"
          sKind = "X"
          Inc iInd
          Break
        Case "CONST"
          sKind = "C"
          bStatic = True
          Inc iInd
          Break
        Case "ENUM"
          sKind = "E"
          bStatic = True
          Inc iInd
          Break
        Case "STRUCT"
          sKind = "S"
          Break
        Case Else
          Break
      End Select
    Next

    If sKind = "E" Then
      For iInd = iInd To aSym.Count - 1
        If Highlight.Types[iInd] = Highlight.Symbol Then
          
          hSymbol = New CSymbolInfo
          With hSymbol
            .Name = aSym[iInd]
            .Class = hModule.Name
            .Kind = "C"
            .NotPublic = Not bPublic
            .LineNumber = iLine + 1
            .Type = "i"
            cSymbol[.Name] = hSymbol
            bCanInherit = False
          End With
          
        Endif
      Next
      Continue
    Else If sKind = "S" Then
      iLine = ScanStruct(hModule, iLine)
      Continue
    Endif

    'IF NOT bPublic THEN CONTINUE
    If Not sKind Then Continue
    If iInd >= aSym.Count Then Continue

  'ANOTHER_SYMBOL:

    sName = aSym[iInd]
    If Left(sName) = "{" Then
      If iInd + 2 > aSym.Max Then Continue
      Inc iInd
      sName = aSym[iInd]
      If aSym[iInd + 1] = "}" Then Inc iInd
    Endif

    hSymbol = New CSymbolInfo
    With hSymbol
      .Name = sName
      .Class = hModule.Name
      .Kind = sKind
      .NotPublic = Not bPublic
      .LineNumber = iLine + 1

      If InStr(":mX", sKind) Then

        For iStart = iInd + 1 To aSym.Count - 1
          If aSym[iStart] = "(" Then Break
        Next

        For iInd = aSym.Count - 1 To 0 Step -1
          If aSym[iInd] = ")" Then
            Break
          Else If aSym[iInd] = "AS" Then
            If iInd < (aSym.Count - 1) Then
              .Type = FEditor.ReadSymbolType(aSym, iInd)
            Endif
          Endif
        Next

        'iEnd = iInd
        Try sSign = Trim(Mid$(Trim(hEditor.Lines[iLine].Text), Highlight.Positions[iStart] + 2))
        If Not Error Then
          iPos = RInStr(sSign, ")")
          If iPos Then sSign = Trim(Left$(sSign, iPos - 1))
          .Signature = "#" & sSign
        Endif
        
        'FOR iInd = iStart TO iEnd
        '  .Signature = .Signature & aSym[iInd] & " "
        'NEXT

      Else
        Inc iInd
        
        ' If iInd <= aSym.Max And If aSym[iInd] = "," Then
        '   If Not aSymbol Then aSymbol = New CSymbolInfo[]
        '   aSymbol.Add(hSymbol)
        '   Inc iInd
        '   Goto ANOTHER_SYMBOL
        ' Endif
        
        .Type = FEditor.ReadSymbolType(aSym, iInd)
        
        If aSymbol Then
          For Each hSymbol In aSymbol
            hSymbol.Type = .Type
          Next
        Endif
        
      Endif

      If bStatic Then .Kind = UCase(.Kind)

      cSymbol[.Name] = hSymbol
      bCanInherit = False
      
    End With

    If sKind = "m" Then 
      Do
        Inc iLine
        If iLine >= hEditor.Lines.Count Then Break
        sLine = Trim(hEditor.Lines[iLine].Text)
        iPos = InStr(sLine, "'")
        If iPos Then sLine = Trim(Left(sLine, iPos - 1))
        If Len(sLine) = 3 And If UCase(sLine) = "END" Then Break
        If Len(sLine) = 7 And If UCase(sLine) = "END SUB" Then Break
        If Len(sLine) = 12 And If UCase(sLine) = "END FUNCTION" Then Break
        'aSym = Highlight.Analyze(hEditor.Lines[iLine])
        'IF aSym.Count = 1 AND IF aSym[0] = "END" THEN BREAK
      Loop
    Endif

  Next

  'DEBUG "< "; hModule.Name

End

Static Private Function GetHelpLine(iLine As Integer, hEditor As Editor) As Integer
  Dim aSym As String[]
  Dim HelpLine As Integer
  Do
    Dec iLine
    If iLine < 0 Then Return HelpLine
    aSym = Highlight.Analyze(hEditor.Lines[iLine].Text)
    If aSym.Count = 1 Then
      If Left(aSym[0], 2) = "''" Then HelpLine = iLine
    Else
        Return HelpLine
    Endif

  Loop
End

Static Private Sub ScanForm(hForm As FForm, cSymbol As Collection)

  Dim hControl As CControl
  Dim hSymbol As CSymbolInfo

  'PRINT "ScanForm "; hForm.Name

  For Each hControl In hForm.Control
    If hControl.Name = hForm.Name Then Continue
    hSymbol = New CSymbolInfo
    With hSymbol
      .Name = hControl.Name
      .Type = hControl.Kind
      .Class = hForm.Name
      .Kind = "t"
      .NotPublic = (Not Project.ControlPublic) And Not hControl.Public
      cSymbol[.Name] = hSymbol
    End With
  Next

End

Static Private Sub GetModule(sClass As String) As Object

  Dim sPath As String
  Dim sFamily As String
  
  sPath = Project.FindPath(sClass & ".module")
  If sPath Then Return Project.LoadFile(sPath)
  For Each sFamily In CFamily.List
    sPath = Project.FindPath(sClass & "." & sFamily)
    If sPath Then Return Project.LoadFile(sPath)
  Next
  sPath = Project.FindPath(sClass & ".class")
  If sPath Then Return Project.LoadFile(sPath)
  
End

Static Public Sub IsAutoCreatable(sClass As String) As Boolean

  Dim hClass As CClassInfo
  Dim hModule As Object
  
  GetClassSymbols(sClass)

  hClass = CComponent.Classes[sClass]
  If hClass Then Return hClass.AutoCreatable

  hModule = GetModule(sClass)
  If hModule Is FEditor Then 
    'DEBUG sClass; " -> "; hModule.AutoCreatable
    Return hModule.AutoCreatable
  Endif
  
End

Static Private Sub MustScan(hEditor As FEditor) As Boolean

  Dim hParentEditor As FEditor

  If Not hEditor.Scan Then Return True

  If hEditor.ParentClass Then 
    hParentEditor = GetModule(hEditor.ParentClass)
    If hParentEditor And If hParentEditor <> hEditor Then Return MustScan(hParentEditor)
  Endif
  
End

Static Public Sub GetClassDescription(sClass As String) As CClassInfo
  
  GetClassSymbols(sClass)
  Return $hClass
  
End

Static Public Function GetClassSymbols(sClass As String) As Collection

  Dim hClass As CClassInfo
  Dim bClass As Boolean
  Dim sName As String
  Dim sPath As String
  Dim hPForm As FForm
  Dim hPModule As FEditor
  Dim hPClass As FEditor
  'Dim hModule As Object
  Dim cSymbol As Collection
  Dim hSymbol As CSymbolInfo
  Dim iFind As Integer
  'Dim aClass As String[]
  Dim sFamily As String

  If Len(sClass) <= 1 Then
    If sClass <> "." And If Not IsLetter(sClass) Then Return
  Endif
  
  'Debug sClass
  'If sClass = "MaskBox" Then Stop
  
  bClass = Project.ExistClass(sClass)
  hClass = CComponent.Classes[sClass]

  If Not bClass Then
    If hClass Then
      $hClass = hClass
      Return hClass.Symbols
    Else
      If Right(sClass, 2) = "[]" Then
        'GetClassSymbols(Left(sClass, -2))
        hClass = CreateClass(sClass, "", "*")
        hClass.CopyFrom(CComponent.Classes["*[]"], "*", Left(sClass, -2))
        $hClass = hClass
        Return hClass.Symbols
      Else        
        Debug sClass & " ??"
        Print Error.Backtrace.Join("\n")
      Endif
      Return
    Endif
  Endif

  sPath = Project.FindPath(sClass & ".module")
  If Exist(sPath) Then hPModule = Project.LoadFile(sPath)
  For Each sFamily In CFamily.List
    sPath = Project.FindPath(sClass & "." & sFamily)
    If Exist(sPath) Then 
      hPForm = Project.LoadFile(sPath)
      Break
    Endif
  Next
  sPath = Project.FindPath(sClass & ".class")
  If Exist(sPath) Then hPClass = Project.LoadFile(sPath)

  cSymbol = New Collection

  If Not $hDumbClass Then $hDumbClass = New CClassInfo("")
  $hClass = $hDumbClass
  $hDumbClass.Name = sClass

  If hPModule Then
    cSymbol = hPModule.Scan
    If MustScan(hPModule) Then
      cSymbol = New Collection(gb.IgnoreCase)
      hPModule.Scan = cSymbol
      ScanClass(hPModule, cSymbol, True)
    Endif
    $hDumbClass.Parent = hPModule.ParentClass
    '$hDumbClass.ParentComponent = hPModule.ParentComponent
  Else If hPClass Then
    cSymbol = hPClass.Scan
    If MustScan(hPClass) Then
      cSymbol = New Collection(gb.IgnoreCase)
      hPClass.Scan = cSymbol
      If hPForm Then
        For Each hSymbol In CComponent.Classes[hPForm.Family].Symbols
          cSymbol[hSymbol.Name] = hSymbol
        Next
        ScanForm(hPForm, cSymbol)
        hPClass.ParentClass = hPForm.Family
      Endif
      ScanClass(hPClass, cSymbol, False, IsNull(hPForm))
    Endif
    $hDumbClass.Parent = hPClass.ParentClass
  Endif
  
  $hDumbClass.Symbols = cSymbol

  Return cSymbol

End


Static Public Sub Reset()

  Dim hComponent As CComponent
  Dim sLib As String

  For Each hComponent In All
    hComponent.Loaded = False
  Next
  
  For Each sLib In Libraries
    All[sLib] = Null
  Next
  Libraries.Clear
  
  CModule.Reset

  Classes = New Collection(gb.IgnoreCase)

  All["gb"].Load

End

Static Public Sub AddLibrary(sPath As String)
  
  Dim hComp As CComponent
  
  hComp = New CComponent
  hComp.Key = File.Name(sPath)
  hComp.Name = hComp.Key
  hComp.Library = True
  hComp.Path = sPath
  
  All[hComp.Key] = hComp
  
  hComp.Load
  
End

Static Public Sub LoadProjectComponent()
  
  All[PROJECT_NAME].Load
  
End

Public Sub UsedByProject() As Boolean
  
  If Key = "gb" Then Return True
  If Key = CComponent.PROJECT_NAME Then Return True
  If Project.Components.Exist(Key) Then Return True
  
End
