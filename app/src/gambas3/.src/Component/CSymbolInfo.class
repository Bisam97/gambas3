' Gambas class file

Static Private $cTypeName As New Collection
Static Private $cNameType As New Collection(gb.IgnoreCase)

Public Name As String
Public Type As String
Public Kind As String
Public Signature As String
Public Value As String
Public Class As String
Public Component As String
Public NotPublic As Boolean
Public LineNumber As Integer

Private $sArgBefore As String
Private $sArgAfter As String
Private $iArg As Integer
Private $iShowArg As Integer

Static Public Sub _init()

  Dim sType As String

  $cTypeName["b"] = "Boolean"
  $cTypeName["c"] = "Byte"
  $cTypeName["h"] = "Short"
  $cTypeName["i"] = "Integer"
  $cTypeName["l"] = "Long"
  $cTypeName["d"] = "Date"
  $cTypeName["g"] = "Single"
  $cTypeName["f"] = "Float"
  $cTypeName["v"] = "Variant"
  $cTypeName["s"] = "String"
  $cTypeName["o"] = "Object"
  $cTypeName["p"] = "Pointer"

  For Each sType In $cTypeName
    $cNameType[sType] = $cTypeName.Key
  Next

End

Public Sub Copy(sType As String, sNewType As String) As CSymbolInfo
  
  Dim hSym As New CSymbolInfo
  
  With hSym
    .Name = Name
    .Type = Replace(Type, sType, sNewType)
    .Kind = Kind
    .Signature = Replace(Signature, sType, sNewType)
    .Value = Value
    .Class = Class
    .Component = Component
    .NotPublic = NotPublic
    .LineNumber = 0
    .HelpLineNumber = 0
  End With
  
  Return hSym
  
End


Public Function IsHidden() As Boolean

  If Left(Name) = "_" Then Return True
  Return InStr(Name, "_") > 0 And Kind <> "C"

End


Public Function IsStatic() As Boolean

  Return UCase(Kind) = Kind

End


Public Function GetIcon() As String

  Dim bStatic As Boolean
  Dim sIcon As String

  bStatic = UCase(Kind) = Kind

  Select Case LCase(Kind)

    Case "r"
      sIcon = "img/16" &/ If(bStatic, "s-property-ro.png", "property-ro.png")
    Case "p"
      sIcon = "img/16" &/ If(bStatic, "s-property.png", "property.png")
    Case "v"
      sIcon = "img/16" &/ If(bStatic, "s-variable.png", "variable.png")
    Case "c"
      sIcon = "img/16/constant.png"
    Case ":"
      sIcon = "img/16/event.png"
    Case "t"
      sIcon = "img/16/control.png"
    Case "m"
      sIcon = "img/16" &/ If(bStatic, "s-method.png", "method.png")

  End Select

  Return sIcon

End


Private Sub NextArg()
  
  Inc $iArg  
  
  If $iArg = $iShowArg Then 
    $sArgBefore = "<u>"
    $sArgAfter = "</u>"
  Else 
    $sArgBefore = ""
    $sArgAfter = ""
  Endif

End

Private Sub MakeArgBold(sCode As String, iShowArg As Integer) As String
  
  Dim sCar As String
  Dim iInd As Integer
  Dim aWait As New String[]
  Dim bString As Boolean
  Dim sSign As String
  Dim bOptional As Boolean
  
  If iShowArg < 0 Then Return sCode
  
  $iArg = -1
  $iShowArg = iShowArg
  NextArg
  sSign = $sArgBefore

  Do
    
    Inc iInd
    If iInd > Len(sCode) Then Break
    
    sCar = Mid$(sCode, iInd, 1)

    If bString Then
      sSign &= sCar
      If sCar = "\\" Then
        Inc iInd
        If iInd > Len(sCode) Then Break
        sSign &= Mid$(sCode, iInd, 1)
      Endif
      Continue
    Endif
    
    If sCar = Chr$(34) Then
      sSign &= sCar
      bString = Not bString
      Continue
    Endif
    
    If sCar = "(" Then
      sSign &= sCar
      aWait.Push(")")
    Else If sCar = "[" Then
      sSign &= sCar
      aWait.Push("]")
    Else If aWait.Count Then
      sSign &= sCar
      If sCar = aWait[aWait.Max] Then
        aWait.Pop
      Endif
    Else If Mid$(sCode, iInd, 9) = "OPTIONAL " Then
      iInd += 7
      If Not bOptional Then 
        sSign &= " ["
      Endif
      bOptional = True
    Else If Mid$(sCode, iInd, 2) = ", " Then
      sSign &= $sArgAfter 
      If Mid$(sCode, iInd, 11) = ", OPTIONAL " Then
        If Not bOptional Then 
          sSign &= " ["
          bOptional = True
        Endif 
        iInd += 9
      Endif
      sSign &= ", "
      NextArg
      sSign &= $sArgBefore
    Else If Mid$(sCode, iInd, 3) = "..." Then 
      If $iShowArg > $iArg Then
        sSign &= "<u>...</u>"
      Else 
        sSign &= "..."
      Endif 
      iInd += 2
    Else
      sSign &= sCar
    Endif
    
  Loop
  
  If bOptional Then
    sSign &= $sArgAfter & " ]"
  Else 
    sSign &= $sArgAfter
  Endif
  
  Return sSign  
  
End

Private Sub MakeSignature(sSign As String) As String
  
  Dim iInd As Integer
  Dim aWait As New String[]
  Dim bOptional As Boolean
  Dim sSym As String
  Dim sType As String
  Dim sDefault As String

  Highlight.Analyze(sSign)
  sSign = ""
  
  For iInd = 0 To Highlight.Symbols.Max
  
    sSym = Highlight.Symbols[iInd]
    
    If sSym = "(" Then
      aWait.Push(")")
    Else If sSym = "[" Then
      aWait.Push("]")
    Else If aWait.Count Then
      If sSym = aWait[aWait.Max] Then
        aWait.Pop
      Endif
    Else 
    
      If iInd > 0 And If sSym <> "," Then Continue
    
      If iInd Then
        Inc iInd
        sSym = Highlight.Symbols[iInd]
      Endif
      
      If sSym = "..." Then
        sSign &= "."
        Break
      Endif
      
      If UCase(sSym) = "OPTIONAL" Then
        If Not bOptional Then
          sSign &= "["
          bOptional = True
        Endif
        Inc iInd
        sSym = Highlight.Symbols[iInd]
      Endif
      
      If UCase(sSym) = "BYREF" Then
        Inc iInd
        sSym = "&" & Highlight.Symbols[iInd]
      Endif
    
      iInd += 2
      sType = Highlight.Symbols[iInd]
      If $cNameType.Exist(sType) Then
        sType = $cNameType[sType]
      Else
        sType = UCase(Left(sType)) & Mid$(sType, 2) & ";"
      Endif
      sSign &= "(" & sSym & ")" & sType
      
      If bOptional And If iInd < Highlight.Symbols.Max Then
        If Highlight.Symbols[iInd + 1] = "=" Then
          iInd += 2
          sDefault = Highlight.Symbols[iInd]
          If Highlight.Types[iInd] = Highlight.Keyword Then
            If Not Settings["/Editor/KeywordsUseUpperCase"] Then
              Mid$(sDefault, 2) = LCase(Mid$(sDefault, 2))
            Endif
          Endif
          sSign &= "=" & sDefault & "\t"
        Endif
      Endif

    Endif
  
  Next
  
  If bOptional Then sSign &= "]"
  
  Return sSign
  
Catch

End

Public Function GetNativeSignature() As String
  
  If Left(Signature) = "#" Then Return MakeSignature(Mid$(Signature, 2))
  Return Signature
  
End

Private Sub SplitSignature(sSign As String) As String[]
  
  Dim iPos As Integer
  Dim aSign As String[2]
  
  iPos = InStr(sSign, "[")
  If iPos Then
    aSign[0] = Left(sSign, iPos - 1)
    aSign[1] = Mid$(sSign, iPos + 1, -1)
  Else
    aSign[0] = sSign
  Endif
  Return aSign
  
End

Private Sub MergeSignature(sSign As String, sParentSign As String) As String
  
  Dim aParentSign As String[]
  Dim aSign As String[]

  aSign = SplitSignature(sSign)
  aParentSign = SplitSignature(sParentSign)
  sSign = aParentSign[0] & aSign[0] & "[" & aParentSign[1] & aSign[1] & "]"
  If sSign Ends "[]" Then sSign = Left(sSign, -2)
  Return sSign
  
End


Public Function GetSignature(Optional iShowArg As Integer = -1) As String

  Dim iInd As Integer
  Dim sRes As String
  Dim sCar As String
  Dim iPos As Integer
  Dim bName As Boolean
  Dim bFirst As Boolean
  Dim sSign As String
  Dim sKeywordAs As String
  Dim sKeywordByRef As String
  Dim sSym As String
  Dim hClass As CClassInfo
  Dim sParent As String
  Dim hSym As CSymbolInfo

  sKeywordAs = If(Settings["/Editor/KeywordsUseUpperCase"], "AS", "As")
  sKeywordByref = If(Settings["/Editor/KeywordsUseUpperCase"], "BYREF", "ByRef")
  
  sSign = GetNativeSignature()
  
  If Name = "_new" Then
    hClass = CComponent.GetClassDescription({Component} &/ {Class})
    Do
      If Not hClass.Parent Then Break
      hClass = CComponent.GetClassDescription(hClass.ParentComponent &/ hClass.Parent)
      'hClass = CComponent.Classes[hClass.ParentComponent &/ hClass.Parent]
      hSym = hClass.Symbols["_new"]
      If hSym Then sSign = MergeSignature(sSign, hClass.Symbols["_new"].GetNativeSignature())
    Loop
  Endif
  
  bFirst = True
  
  $iArg = -1
  $iShowArg = iShowArg

  Do

    Inc iInd

    If iInd > Len(sSign) Then Break

    sCar = Mid$(sSign, iInd, 1)

    If sCar = "'" Or sCar = "(" Then

      If sCar = "'" Then
        iPos = InStr(sSign, "'", iInd + 1)
      Else
        iPos = InStr(sSign, ")", iInd + 1)
      Endif

      If iPos = 0 Then Break

      If bFirst Then
        bFirst = False
        NextArg
      Else
        sRes &= $sArgAfter & ", "
        NextArg
      Endif

      sSym = Mid$(sSign, iInd + 1, iPos - iInd - 1)

      sRes &= $sArgBefore 
      
      If Left(sSym) = "&" Then
        sSym = Mid$(sSym, 2)
        sRes &= sKeywordByRef & " "
      Endif
      
      sRes &= sSym & " " & sKeywordAs & " "

      iInd = iPos
      bName = True

      Continue

    Endif

    If sCar = "<" Then

      iPos = InStr(sSign, ">", iInd + 1)
      If iPos = 0 Then Break
      iInd = iPos
      Continue

    Endif

    If sCar = "[" Then

      sRes &= $sArgAfter & "<font color=#808080>"
      $sArgAfter = ""
      Continue

    Endif

    If sCar = "]" Then

      sRes &= $sArgAfter & "</font>"
      $sArgAfter = ""
      Continue

    Endif
    
    If sCar = "=" Then
    
      iPos = InStr(sSign, "\t", iInd + 1)
      If iPos = 0 Then Break
      $sArgAfter &= " = " & Mid$(sSign, iInd + 1, iPos - iInd - 1)
      iInd = iPos
    
    Endif

    If Not bName Then

      If bFirst Then
        bFirst = False
      Else
        sRes &= $sArgAfter & ", "
        NextArg
      Endif

      sRes &= $sArgBefore & "? " & sKeywordAs & " " 
      bName = False

    Endif
    
    If sCar = "." Then
      sRes &= $sArgAfter & ", " 
      NextArg
      If $iShowArg >= 0 And If $iShowArg > $iArg Then sRes &= "<u>"
      sRes &= $sArgBefore & "..."
      If $iShowArg >= 0 And If $iShowArg > $iArg Then sRes &= "</u>"
      Continue
    Endif

    If (sCar >= "A" And sCar <= "Z") Or sCar = "." Then

      iPos = InStr(sSign, ";", iInd)
      If iPos = 0 Then iPos = Len(sSign) + 1

      sRes &= Mid$(sSign, iInd, iPos - iInd)

      iInd = iPos
      Continue

    Endif

    sRes &= GetType(sCar)

  Loop
  
  sRes &= $sArgAfter
    
  If Name = "_get" Or Name = "_put" Then
    sRes = "<b>[</b>" & sRes & "<b>]</b>"
  Else
    sRes = "<b>(</b>" & sRes & "<b>)</b>"
  Endif
  
  If Type Then sRes &= " " & sKeywordAs & " " & GetType(Type)

  Return sRes

End

Public Function GetDescription(Optional bBalise As Boolean) As String

  Dim bStatic As Boolean
  Dim sDesc As String
  Dim sSign As String

  bStatic = UCase(Kind) = Kind

  Select LCase(Kind)
  
    Case "r"
      sDesc = If(bStatic, "STATIC ", "") & "PROPERTY READ"
    Case "p"
      sDesc = If(bStatic, "STATIC ", "") & "PROPERTY"
    'CASE "v"
    '  sIcon = "img/16" &/ If(bStatic, "s-variable.png", "variable.png")
    Case "c"
      sDesc = "CONST"
    Case ":"
      sDesc = "EVENT"
    'CASE "t"
    '  sIcon = "img/16/control.png"
    Case "m"
      sDesc = If(bStatic, "STATIC ", "") & If(Type, "FUNCTION", "SUB")

  End Select  
  
  If Kind = ":" Then
    sDesc &= " " & Mid$(Name, 2) & " "
  Else
    sDesc &= " " & Name & " "
  Endif
  
  If InStr(":m", LCase(Kind)) Then 
    sSign = GetSignature()
    If sSign Then
      sDesc &= sSign
    Else
      sDesc &= "(...)"
    Endif
  Else
    If Type Then sDesc &= " AS " & GetType(Type, bBalise)
  Endif
  
  Return sDesc
  
End


Static Private Function GetType(sType As String, Optional bBalise As Boolean) As String

  If Len(sType) = 1 Then
    sType = $cTypeName[sType]
  Else If Left$(sType) = "." Then
    'IF bBalise THEN
    '  sType = "<I>" & Mid$(sType, 2) & "</I>"
    'ELSE
    sType = "Object"
    'ENDIF
  Endif

  If bBalise Then
    Return "<B>" & sType & "</B>"
  Else
    Return sType
  Endif

End

Static Public Function TransformSignature(sSign As String, bBalise As Boolean) As String

  Dim iInd As Integer
  Dim sRes As String
  Dim sCar As String
  Dim iPos As Integer
  Dim bName As Boolean
  Dim bFirst As Boolean

  Dim sBold As String
  Dim sNoBold As String

  If bBalise Then
    sBold = "<B>"
    sNoBold = "</B>"
  Endif

  bFirst = True

  Do

    iInd = iInd + 1

    If iInd > Len(sSign) Then Break

    sCar = Mid$(sSign, iInd, 1)

    If sCar = "'" Or sCar = "(" Then

      If sCar = "'" Then
        iPos = InStr(sSign, "'", iInd + 1)
      Else
        iPos = InStr(sSign, ")", iInd + 1)
      Endif

      If iPos = 0 Then Break

      If bFirst Then
        bFirst = False
      Else
        sRes = sRes & sBold & "," & sNoBold & " "
      Endif

      sRes = sRes & Mid$(sSign, iInd + 1, iPos - iInd - 1) & " " & sBold & "AS" & sNoBold & " "

      iInd = iPos
      bName = True

      Continue

    Endif

    If sCar = "<" Then

      iPos = InStr(sSign, ">", iInd + 1)
      If iPos = 0 Then Break
      iInd = iPos
      Continue

    Endif

    If sCar = "[" Then

      sRes = sRes & " " & sBold & "[" & sNoBold
      Continue

    Endif

    If sCar = "]" Then

      sRes = sRes & " " & sBold & "] " & sNoBold
      Continue

    Endif

    If Not bName Then

      If bFirst Then
        bFirst = False
      Else
        sRes = sRes & sBold & "," & sNoBold & " "
      Endif

      sRes = sRes & sBold & "? AS " & sNoBold
      bName = False

    Endif

    If sCar >= "A" And sCar <= "Z" Then

      iPos = InStr(sSign, ";", iInd)
      If iPos = 0 Then iPos = Len(sSign) + 1

      sRes = sRes & Mid$(sSign, iInd, iPos - iInd)

      iInd = iPos
      Continue

    Endif

    sRes = sRes & GetType(sCar, bBalise)

  Loop

  Return sRes

End

Public Function GetHelpURL() As String
  
  If Component Then 
    If Component = "gb" And If Class = "." Then
      Return MHelp.GetLangURL(Name)
    Else
      Return MHelp.GetSymbolURL(Component, Class, Name)
    Endif
  Endif
  
End

Public Function GetHelpHTML() As String
  
  Dim hForm As Object
  Dim hEdit As Editor
  Dim sHTML, s As String
  Dim iLine, i As Integer
  Dim sSyntax As String
  
  hForm = Project.LoadFile(Project.FindPath(Me.Class))
  Try hEdit = hForm.Editor
  If Not hEdit Then Return  
  iLine = Me.LineNumber - 1
  
  'Essais de trouver de l'aide sur la même ligne que la declaration

  If InStr(hEdit.Lines[iLine].Text, "''", 0) Then 
    s = Trim(Mid(hEdit.Lines[iLine].Text, InStr(hEdit.Lines[iLine].Text, "''", 0) + 2))
  Endif
  
  'trouve l'aide au dessus
  For i = iLine - 1 To 0 Step -1
    If Left(Trim(hEdit.Lines[i].Text), 2) = "''" Then 
      s = Trim(Mid(hEdit.Lines[i].Text, 3)) & "<BR>" & s
    Else
      If Trim(hEdit.Lines[i].Text) = "" Then Continue
      Break
    Endif
  Next
  If Not s Then s = ("No help found.")
  
  sHTML = "<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">" & 
            "<link rel=\"stylesheet\" href=\"" & File.Dir(MHelp.GetURL()) & "/style.css\"></head><body class=\"none\">"
  sHTML &= "<div class\"frame\">"
  sHTML &= "<div class=\"title\">" & Me.Name & "</div>"
  sHTML &= "<pre class=\"syntax\">"
 
  If Me.IsStatic() Then sHTML &= "<font color=\"blue\">STATIC </font>"

  sSyntax &= Me.GetDescription(False)
  sSyntax = Replace(Replace(sSyntax, "</b>", ""), "<b>", "")
  
  Highlight.Analyze(sSyntax)
  
  For i = 0 To Highlight.Symbols.Max
    Select Case Highlight.Types[i]
      Case Highlight.Symbol
        shtml &= "<b>" & Highlight.Symbols[i] & " </b>"
      Case Highlight.Operator
        shtml &= "<font color=\"blue\">" & Highlight.Symbols[i] & " </font>"
      Case Highlight.DataType
        shtml &= "<font color=\"#0080FF\">" & Highlight.Symbols[i] & " </font>"
      Case Highlight.Keyword
        shtml &= "<font color=\"blue\">" & Highlight.Symbols[i] & " </font>"
      Case Else
        shtml &= Highlight.Symbols[i]
    End Select
  Next
  
  sHTML &= "</pre><p>"
  sHTML &= s 
  sHTML &= "</div></body></html>"
  
  Return sHTML
  

End

