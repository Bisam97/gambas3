' Gambas class file

Public Path As String

Property Read ReadOnly As Boolean

Private $bReadOnly As Boolean
Private $hImage As Image
Private $bModify As Boolean
Private $iMouse As Integer

Private $bFirstTime As Boolean

Private $aUndo As New Variant[]
Private $aRedo As New Variant[]
Private Enum BEGIN_UNDO, END_UNDO

Private $sTool As String
Private $hFirstPoint As PointF
Private $hLastPoint As PointF
Private $hCurrentPoint As PointF
Private $bPress As Boolean
Private $bShift As Boolean
Private $bCtrl As Boolean
Private $bAlt As Boolean

Private $bFrame As Boolean
Private $fDashOffset As Float

Private $SX As Integer
Private $SY As Integer

Private $aStroke As New Integer[]
Private $hSaveImage As Image

Private $hSelect As CImageSelection

Private $hLastMagnet As PointF
Private $hMagnet As PointF
Private $sMagnet As String

' Private $hMagic As Image
' Private $R As Integer
' Private $G As Integer
' Private $B As Integer
' Private $A As Integer
' Private $N As Integer
' Private $iTol As Integer

Private $iClipboard As Integer

Private $hPaste As Image
Private $hPasteCurrent As CImageSelection
Private $hPasteSelect As CImageSelection

Private $iAngle As Integer

Private $hChangeRect As RectF
Private $iChangeAction As Integer
Private $vChangeIndex As Variant
Private Enum CHANGE_NOTHING, CHANGE_MOVE, CHANGE_RESIZE, CHANGE_ROTATE, CHANGE_POINT, CHANGE_INSERT, CHANGE_SELECT

Private $bShowGrid As Boolean

Public Sub _new(sPath As String)
  
  Me.Name = File.Name(sPath)
  Path = sPath
  
  dwgBackground.Lower
  
  Reload
  
  SetTool("move")
  
End


Private Function ReadOnly_Read() As Boolean

  Return $bReadOnly

End

Private Sub ClearSelection()

  If Not $hSelect Then Return
  
  AddUndo($hSelect.Copy())
  $hSelect = Null
  $hChangeRect = Null
  $hMagnet = Null
  $hLastMagnet = Null
  $sMagnet = ""
  RefreshSelection

End

Private Sub CreateSelection()
  
  If $hSelect Then Return
  $hSelect = New CImageSelection
  RefreshSelection
  
End


Public Sub Reload()
  
  $hImage = Image.Load(Path)
  imvImage.Image = $hImage  
  $bModify = False
  ClearSelection
  $aUndo.Clear
  $aRedo.Clear
  DrawTitle
  btnZoomFit_Click
  
End

Public Sub LoadFile() As Boolean
  
  Reload
  
End

Public Sub btnZoomIn_Click()

  Try Inc cmbZoom.Index

End

Public Sub btnZoomOut_Click()

  If cmbZoom.Index = 0 Then Return
  Dec cmbZoom.Index

End

Public Sub cmbZoom_Click()

  imvImage.Zoom = CFloat(Trim(String.Left(cmbZoom.Text, -1)))
  imvImage.Grid = imvImage.Zoom > 8

End

Public Sub IsModified() As Boolean
  
  Return $bModify
  
End

Public Sub dwgBackground_Draw()

  Dim hTopLeft As Point
  Dim hBottomRight As Point

  Project.DrawBackground()
  
  hTopLeft = imvImage.ImageToView(Point(0, 0))
  If Not hTopLeft Then Return
  hBottomRight = imvImage.ImageToView(Point(imvImage.Image.W, imvImage.Image.H))

  Paint.Background = Color.SetAlpha(Color.Black, 192)
  Paint.Rectangle(hTopLeft.X - 2, hTopLeft.Y - 2, hBottomRight.X - hTopLeft.X + 4, 2)
  Paint.Rectangle(hTopLeft.X - 2, hBottomRight.Y, hBottomRight.X - hTopLeft.X + 4, 2)
  Paint.Rectangle(hTopLeft.X - 2, hTopLeft.Y, 2, hBottomRight.Y - hTopLeft.Y)
  Paint.Rectangle(hBottomRight.X, hTopLeft.Y, 2, hBottomRight.Y - hTopLeft.Y)
  Paint.Fill

End

Public Sub Form_Open()

  SetReadOnly

End

Private Sub SetReadOnly()

  'Dim hCtrl As Control  

  $bReadOnly = False
  
  If Project.ReadOnly Or If Project.Running Or If Project.IsReadOnly(Path) Then
    $bReadOnly = True
  Endif

  UpdateMenu

End

Private Sub DrawTitle()

  Project.DrawTitle(Me)

End

Public Sub btnZoomNormal_Click()

  cmbZoom.Index = 3

End

Public Sub Modify(Optional bReset As Boolean)

  If Project.ReadOnly Or $bReadOnly Then Return
  If $bModify <> bReset Then Return

  $bModify = Not bReset
  DrawTitle
  If $bModify Then Inc Project.TimeStamp

End

Private Sub ActionImage(hImage As Image)
  
  AddUndo($hImage)
  $hImage = hImage
  
  imvImage.Update($hImage)
  Modify
  imvImage.SetFocus
  
End

Private Sub AddUndo(hObject As Object)
  
  If Not hObject Then Return
  If $aUndo.Count = 64 Then $aUndo.Remove(0)
  $aUndo.Add(hObject)
  $aRedo.Clear
  
End

Public Sub btnRotateL_Click()

  If $hChangeRect Then
    
    AddUndo($hSelect.Copy())
    $hSelect.Rotate(Rad(90))
    RefreshSelection

  Else
    
    BeginUndo
    ClearSelection
    ActionImage($hImage.Copy().RotateLeft())
    EndUndo

  Endif

End

Public Sub btnRotateR_Click()

  If $hChangeRect Then
    
    AddUndo($hSelect.Copy())
    $hSelect.Rotate(Rad(-90))
    RefreshSelection

  Else
    
    BeginUndo
    ClearSelection
    ActionImage($hImage.Copy().RotateRight())
    EndUndo
    
  Endif
  
End

Public Sub btnFlipH_Click()

  If $hChangeRect Then

    AddUndo($hSelect.Copy())
    $hSelect.HFlip()
    RefreshSelection

  Else
    
    BeginUndo
    ClearSelection
    ActionImage($hImage.Copy().Mirror(True, False))
    EndUndo
    
  Endif
  
End

Public Sub btnFlipV_Click()

  If $hChangeRect Then

    AddUndo($hSelect.Copy())
    $hSelect.VFlip()
    RefreshSelection

  Else
    
    BeginUndo
    ClearSelection
    ActionImage($hImage.Copy().Mirror(False, True))
    EndUndo
    
  Endif
  
End


Public Function Save() As Boolean

  If Project.ReadOnly Then Return
  If $bReadOnly Then Return
  If Not $bModify Then Return

  'PRINT "Picture not saved"

  'HideSelection

  Save.Begin(Path)

  $hImage.Save(Path)

  'Project.RefreshKey(Path)

  $bModify = False
  DrawTitle
  Save.End()

Catch

  Return Save.Error()

End

Public Sub btnSave_Click()

  Me.Save

End

Public Sub btnReload_Click()

  If IsModified() Then
    If Message.Warning(("The file has been modified.\n\nAll your changes will be lost."), ("Reload"), ("Cancel")) <> 1 Then Return
  Endif

  Reload

End

Public Sub btnResize_Click()

  Dim X, Y, W, H As Integer
  Dim hImage As Image

  FImageResize.ImageWidth = $hImage.Width
  FImageResize.ImageHeight = $hImage.Height
  
  If FImageResize.Run() Then Return
  
  W = FImageResize.ImageWidth
  H = FImageResize.ImageHeight
  
  If W = $hImage.W And If H = $hImage.H Then Return
  
  If FImageResize.Stretch Then
    ActionImage($hImage.Stretch(W, H))
  Else
    hImage = New Image(W, H, Color.Transparent)
    If FImageResize.CenterH Then X = (W - $hImage.W) \ 2
    If FImageResize.CenterV Then Y = (H - $hImage.H) \ 2
    hImage.DrawImage($hImage, X, Y)
    ActionImage(hImage)
  Endif

End

Public Sub Rename(sNewName As String, sNewPath As String)

  Me.Name = sNewName
  Path = sNewPath 
  DrawTitle

End

Private Sub SetTool(sAction As String)

  Dim hCtrl As ToolButton
  Dim hImage As Image
  
  'If $sTool = sAction Then Return

  For Each hCtrl In [btnMove, btnDraw, btnErase, btnRectangle, btnEllipse, btnLine, btnMagic, btnPaste, btnEditSelection]
    Object.Lock(hCtrl)
    hCtrl.Value = hCtrl.Tag = sAction
    Object.Unlock(hCtrl)
  Next
  
  If $sTool = "paste" Then
    If $hPaste Then
      $hPaste = Null
      $hPasteSelect = Null
      $hPasteCurrent = Null
      imvImage.Refresh
    Endif
  Endif
  
  If $hSelect Then $hSelect.SelectAll()
  $hChangeRect = Null
  $iChangeAction = CHANGE_NOTHING

  $iMouse = Mouse.Arrow

  Select Case sAction
    
    Case "move"
      $iMouse = Mouse.SizeAll
    
    Case "draw", "erase"
      $iMouse = Mouse.Cross
    
    Case "rectangle", "ellipse", "line", "magic"
      AddUndo($hSelect)
      If $sTool = sAction Or If Not $hSelect Then 
        ClearSelection
      Endif
      imvImage.Refresh
      
    Case "paste"
      hImage = FImageProperty.GetClipboard()
      If hImage Then 
  
        $hPaste = hImage
        
        $hPasteCurrent = New CImageSelection
        $hPasteCurrent.Rectangle(($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2, $hPaste.W, $hPaste.H)
        $hPasteSelect = $hPasteCurrent.Copy()

        $hChangeRect = $hPasteCurrent.GetExtents()

        imvImage.Refresh
        
      Endif
      
    Case "change"
      If $hSelect And If Not $hSelect.IsVoid() Then
        $hChangeRect = $hSelect.GetExtents()
      Endif

  End Select
  
  $sTool = sAction

End

Public Sub btnTool_Click()

  SetTool(Last.Tag)

End

Public Sub imvImage_Scroll()
  
  If Not $bPress Then imvImage_MouseMove
  
End


Public Sub btnUndo_Click()

  Dim vUndo As Variant
  Dim iLevel As Integer

  If $aUndo.Count = 0 Then Return
  
  Repeat
  
    vUndo = $aUndo.Pop()
    
    If TypeOf(vUndo) = gb.Integer Then
      $aRedo.Add(vUndo)
      If vUndo = END_UNDO Then
        Inc iLevel
      Else If vUndo = BEGIN_UNDO Then
        Dec iLevel
      Endif
    Else If vUndo Is Image Then
      $aRedo.Add($hImage)
      $hImage = vUndo
      imvImage.Update($hImage)
      Modify
    Else If vUndo Is CImageSelection Then
      $aRedo.Add($hSelect)
      $hSelect = vUndo
      imvImage.Refresh
    Endif
    
  Until iLevel = 0

  RefreshSelection
  
End

Public Sub btnRedo_Click()

  Dim vUndo As Variant
  Dim iLevel As Integer

  If $aRedo.Count = 0 Then Return
  
  Repeat
    
    vUndo = $aRedo.Pop()
  
    If TypeOf(vUndo) = gb.Integer Then
      $aUndo.Add(vUndo)
      If vUndo = BEGIN_UNDO Then
        Inc iLevel
      Else If vUndo = END_UNDO Then
        Dec iLevel
      Endif
    Else If vUndo Is Image Then
      $aUndo.Add($hImage)
      $hImage = vUndo
      imvImage.Update($hImage)
      Modify
    Else If vUndo Is CImageSelection Then
      $aUndo.Add($hSelect)
      $hSelect = vUndo
      imvImage.Refresh
    Endif
    
  Until iLevel = 0

  RefreshSelection
  
End

Private Sub GetPos() As Point
  
  Return Point(Mouse.ScreenX - imvImage.ScreenX, Mouse.ScreenY - imvImage.ScreenY)
  
End

Private Sub GetImagePos() As PointF
  
  Dim hPos As Point = GetPos()
  Dim hPoint As Point = imvImage.ViewToImage(hPos)
  Dim hOrg As Point = imvImage.ImageToView(Point(0, 0))
  Dim X As Float
  Dim Y As Float
  Dim iSnap As Integer
  
  X = hPoint.X + Frac((hPos.X - hOrg.X) / imvImage.Zoom)
  Y = hPoint.Y + Frac((hPos.Y - hOrg.Y) / imvImage.Zoom)
  
  If $hMagnet Then
    
    If Max(Abs($hMagnet.X - X), Abs($hMagnet.Y - Y)) < 4 Then Return $hMagnet
    
  Else If $bShowGrid Then
  
    iSnap = FImageProperty.GetGridResolution() \ FImageProperty.GetGridSubdivision()
  
    X = (CInt(X + iSnap \ 2) \ iSnap) * iSnap
    Y = (CInt(Y + iSnap \ 2) \ iSnap) * iSnap
    
  Endif
  
  Return PointF(X, Y)
  
End


Public Sub imvImage_MouseDown()

  Me.SetFocus
  $bPress = Mouse.Left
  If Not $bPress Then Return
  
  Select Case $sTool
    
    Case "move"
      $SX = imvImage.ScrollX
      $SY = imvImage.ScrollY
    
    Case "draw", "erase"
      AddUndo($hImage)
      $hSaveImage = $hImage.Copy()
      If Not Mouse.Shift Then 
        $hLastPoint = GetImagePos()
        If $hMagnet Then $hLastPoint = $hMagnet
      Endif
      $aStroke.Clear
      $aStroke.Add($hLastPoint.X)
      $aStroke.Add($hLastPoint.Y)
      DrawTool
      
    Case "line"
      
      CreateSelection
      AddUndo($hSelect.Copy())
      
      $hCurrentPoint = GetImagePos()
      If $hMagnet Then $hCurrentPoint = $hMagnet
      
      If Not Mouse.Shift Or If Not $hLastPoint Then 
        $hSelect.MoveTo($hCurrentPoint.X, $hCurrentPoint.Y)
      Else
        $hSelect.LineTo($hCurrentPoint.X, $hCurrentPoint.Y)
        $hSelect.AddMagnet(PointF(($hCurrentPoint.X + $hLastPoint.X) / 2, ($hCurrentPoint.Y + $hLastPoint.Y) / 2))
      Endif
      
      $hFirstPoint = $hCurrentPoint
      $hLastPoint = $hCurrentPoint
      imvImage.Refresh
      
    Case "rectangle", "ellipse"

      CreateSelection
      AddUndo($hSelect.Copy())
      
      $hLastPoint = GetImagePos()
      If $hMagnet Then $hLastPoint = $hMagnet
      
    Case "magic"
      
      CreateSelection
      AddUndo($hSelect.Copy())
      $hLastPoint = GetImagePos()
      'MagicWand
    
    Case "paste"
      If $hPaste Then
        $hLastPoint = GetImagePos()
        If $hMagnet Then $hLastPoint = $hMagnet
        If $iChangeAction = CHANGE_NOTHING Then
          DoPaste
        Else
          $hLastPoint = GetImagePos()
        Endif
      Endif
      
    Case "change"
      
      If $iChangeAction = CHANGE_NOTHING Then
        
        $SX = imvImage.ScrollX
        $SY = imvImage.ScrollY
        
      Else
      
        AddUndo($hSelect.Copy())
        $hLastPoint = GetImagePos()
        If $hMagnet Then $hLastPoint = $hMagnet
        
        If $iChangeAction = CHANGE_INSERT Then
          $vChangeIndex = $hSelect.InsertPoint($hLastPoint, $vChangeIndex)
          $hLastPoint.X = -1000000 ' Avoid automatic undo at MouseUp
          $iChangeAction = CHANGE_POINT
          RefreshSelection
        Else If $iChangeAction = CHANGE_SELECT Then
          $hSelect.Select($vChangeIndex[0])
          RefreshSelection
        Endif
        
      Endif
    
  End Select
  
  imvImage_MouseMove()

End

Private Sub UpdateInfo()
  
  Dim sInfo As String

  If $hCurrentPoint.InRect(RectF(0, 0, $hImage.W, $hImage.H)) Or If $bPress Then
    sInfo = CStr(CInt($hCurrentPoint.X)) & " , " & CStr(CInt($hCurrentPoint.Y))
    If $bPress Then
      If $sTool = "rectangle" Or If $sTool = "ellipse" Then
        If $bShift Then
          sInfo &= "   ( " & (Abs(CInt($hCurrentPoint.X) - CInt($hLastPoint.X)) * 2) & " x " & (Abs(CInt($hCurrentPoint.Y) - CInt($hLastPoint.Y)) * 2) & " )"
        Else
          sInfo &= "   ( " & Abs(CInt($hCurrentPoint.X) - CInt($hLastPoint.X)) & " x " & Abs(CInt($hCurrentPoint.Y) - CInt($hLastPoint.Y)) & " )"
        Endif
      Endif
    Endif
  Endif
  
  FImageProperty.UpdateInfo(sInfo)
  
End

Private Sub GetRectLimits(hRect As RectF) As PointF[]
  
  With hRect
    Return [PointF(.X, .Y), PointF(.X + .W, .Y), PointF(.X, .Y + .H), PointF(.X + .W, .Y + .H)] ',PointF(.X + .W / 2, .Y + .H / 2)
  End With
  
End


Private Sub FindBestMagnetFor(hPoint As PointF, Optional bIgnore As Boolean) As PointF

  Dim hMagnet As PointF

  If Not $bPress Then Return

  If $hSelect Then 
    If $sTool = "change" Then
      If $iChangeAction = CHANGE_MOVE And If $hSelect._Current < 0 Then Goto NO_SELECT
      If $iChangeAction = CHANGE_RESIZE Or If $iChangeAction = CHANGE_ROTATE Then Goto NO_SELECT
    Endif
    hMagnet = $hSelect.FindMagnet(hPoint, 8 / imvImage.Zoom, bIgnore)
    If hMagnet Then Return hMagnet
  Endif

NO_SELECT:

  If $sTool <> "move" Then
    hMagnet = CImageSelection.FindMagnetFrom(GetRectLimits(RectF(0, 0, $hImage.W, $hImage.H)), hPoint, 8 / imvImage.Zoom)
    If hMagnet Then Return hMagnet
  Endif

  If $hChangeRect Then
    If $bPress And If $iChangeAction = CHANGE_POINT Then
      hMagnet = $hSelect.FindPoint(hPoint, 8 / imvImage.Zoom,, $vChangeIndex)
      If hMagnet Then Return hMagnet
    Endif
    hMagnet = CImageSelection.FindMagnetFrom(GetRectLimits($hChangeRect), hPoint, 8 / imvImage.Zoom, True)
    If hMagnet Then Return hMagnet
  Endif
    
End

Private Sub SetMagnet(hMagnet As PointF)

  If hMagnet <> $hMagnet Then
    $hLastMagnet = $hMagnet
    $hMagnet = hMagnet
    '$sMagnet = sName
    imvImage.Refresh
  Endif

End

Private Sub FindBestMagnet(hCurrent As PointF) As PointF

  Dim hMagnet As PointF
  Dim bCurrent As Boolean
  Dim hPoint As PointF
  
  If $sTool = "move" Then Return hCurrent
  If $sTool = "change" And If Not $bPress Then Return hCurrent
  
  If $hMagnet And If hCurrent = $hMagnet Then Return hCurrent
  
  hMagnet = FindBestMagnetFor(hCurrent)
  If hMagnet Then
    bCurrent = True
    Goto FIND_MAGNET
  Endif
  
  If $bPress Then
    
    If $hChangeRect And If $hSelect And If $iChangeAction <> CHANGE_NOTHING And If $iChangeAction <> CHANGE_POINT Then

      If $iChangeAction <> CHANGE_RESIZE And If $iChangeAction <> CHANGE_ROTATE Then

        'Print "~ "; hCurrent - $hCurrentPoint

        If $hSelect._Current >= 0 Then
          For Each hPoint In $hSelect.Shapes[$hSelect._Current].Magnets
            hPoint += hCurrent - $hCurrentPoint
            hMagnet = FindBestMagnetFor(hPoint, True)
            If hMagnet Then Goto FIND_MAGNET
          Next
        Endif
        For Each hPoint In GetRectLimits($hSelect.GetExtents())
          hPoint += hCurrent - $hCurrentPoint
          hMagnet = FindBestMagnetFor(hPoint, True)
          If hMagnet Then Goto FIND_MAGNET
        Next
        
      Endif
    Endif
  
  Endif

FIND_MAGNET:

  SetMagnet(hMagnet)

  If hMagnet Then
   
    'Print "Magnet";; hMagnet; " <- "; hPoint
   
    If bCurrent Then
      hCurrent = hMagnet
      $hLastMagnet = Null
      'Print "Current";; hCurrent
    Else
      'Print "Other";; hCurrent;; hMagnet - hPoint
      hCurrent = hCurrent + hMagnet - hPoint
    Endif
    
  Else If $hLastMagnet Then
      
    If hCurrent.X > ($hLastMagnet.X - 8 / imvImage.Zoom) And If hCurrent.X < ($hLastMagnet.X + 8 / imvImage.Zoom) Then
      hCurrent.X = $hLastMagnet.X
    Endif
    If hCurrent.Y > ($hLastMagnet.Y - 8 / imvImage.Zoom) And If hCurrent.Y < ($hLastMagnet.Y + 8 / imvImage.Zoom) Then
      hCurrent.Y = $hLastMagnet.Y
    Endif
      
  Endif
    
  Return hCurrent

End

Public Sub imvImage_MouseMove()

  Dim hPos As Point = GetPos()
  Dim WW, HH As Float
  Dim iMouse As Integer
  Dim XC, YC As Float
  Dim A As Float
  Dim hSelect As CImageSelection
  Dim I As Integer
  
  $hCurrentPoint = FindBestMagnet(GetImagePos())
  UpdateInfo
  
  If $bPress Then
    
    If $sTool <> "move" Then imvImage.EnsureVisible(imvImage.ScrollX + hPos.X - 32, imvImage.ScrollY + hPos.Y - 32, 64, 64)
    
    Select Case $sTool
      
      Case "move"
        imvImage.Scroll($SX - (Mouse.X - Mouse.StartX), $SY - (Mouse.Y - Mouse.StartY))
      
      Case "draw", "erase"
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $aStroke.Add($hCurrentPoint.X)
          $aStroke.Add($hCurrentPoint.Y)
          DrawTool
          $hLastPoint = $hCurrentPoint
        Endif
      
      Case "line"
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect.LineTo($hCurrentPoint.X, $hCurrentPoint.Y)
          imvImage.Refresh
          $hLastPoint = $hCurrentPoint
        Endif
        
        If $hFirstPoint And If Hyp($hCurrentPoint.X - $hFirstPoint.X, $hCurrentPoint.Y - $hFirstPoint.Y) > 8 Then 
          $hSelect.AddMagnet($hFirstPoint)
          $hFirstPoint = Null
        Endif
        
      Case "rectangle"
        If $bCtrl Then $hCurrentPoint.Y = $hLastPoint.Y + Abs($hCurrentPoint.X - $hLastPoint.X) * Sgn($hCurrentPoint.Y - $hLastPoint.Y)
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect = $aUndo[$aUndo.Max].Copy()
          If $bShift Then
            WW = $hCurrentPoint.X - $hLastPoint.X
            HH = $hCurrentPoint.Y - $hLastPoint.Y
            $hSelect.Rectangle($hLastPoint.X - WW, $hLastPoint.Y - HH, WW * 2, HH * 2, True)
          Else
            $hSelect.Rectangle($hLastPoint.X, $hLastPoint.Y, $hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y, True)
          Endif
          imvImage.Refresh
        Endif
      
      Case "ellipse"
        If $bCtrl Then $hCurrentPoint.Y = $hLastPoint.Y + Abs($hCurrentPoint.X - $hLastPoint.X) * Sgn($hCurrentPoint.Y - $hLastPoint.Y)
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect = $aUndo[$aUndo.Max].Copy()
          If $bShift Then
            WW = Abs($hCurrentPoint.X - $hLastPoint.X)
            HH = Abs($hCurrentPoint.Y - $hLastPoint.Y)
            $hSelect.Ellipse($hLastPoint.X - WW, $hLastPoint.Y - HH, WW * 2, HH * 2, True)
          Else
            $hSelect.Ellipse(Min($hLastPoint.X, $hCurrentPoint.X), Min($hLastPoint.Y, $hCurrentPoint.Y), Abs($hCurrentPoint.X - $hLastPoint.X), Abs($hCurrentPoint.Y - $hLastPoint.Y), True)
          Endif
          imvImage.Refresh
        Endif
        
      Case "change", "paste"
        
        If $iChangeAction = CHANGE_NOTHING And If $sTool = "change" Then
            
          ' No mouse event data possible
          Try imvImage.Scroll($SX - (Mouse.X - Mouse.StartX), $SY - (Mouse.Y - Mouse.StartY))
          
        Else If $iChangeAction = CHANGE_POINT Then
          
          $hSelect.SetPoint($vChangeIndex, $hCurrentPoint)
          
        Else If $iChangeAction = CHANGE_SELECT Then
          
          If Hyp(Mouse.X - Mouse.StartX, Mouse.Y - Mouse.StartY) > 4 Then 
            $iChangeAction = CHANGE_MOVE
            AddUndo($hSelect.Copy())
            $hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
            '$hSelect = $aUndo[$aUndo.Max].Copy()
            '$hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
          Endif
          
        Else
        
          XC = $hChangeRect.X + $hChangeRect.W / 2
          YC = $hChangeRect.Y + $hChangeRect.H / 2
          
          If $sTool = "change" Then
            $hSelect = $aUndo[$aUndo.Max].Copy()
            hSelect = $hSelect
          Else
            $hPasteSelect = $hPasteCurrent.Copy()
            hSelect = $hPasteSelect
          Endif
          
          Select Case $iChangeAction
            
            Case CHANGE_RESIZE
              If $bCtrl Then
                hSelect.Scale(($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), ($hCurrentPoint.X - XC) / ($hLastPoint.X - XC))
              Else
                hSelect.Scale(($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), ($hCurrentPoint.Y - YC) / ($hLastPoint.Y - YC))
              Endif
              
            Case CHANGE_ROTATE
              A = ($hLastPoint.X - XC) * ($hCurrentPoint.X - XC) + ($hLastPoint.Y - YC) * ($hCurrentPoint.Y - YC)
              Try A /= Hyp($hLastPoint.X - XC, $hLastPoint.Y - YC) * Hyp($hCurrentPoint.X - XC, $hCurrentPoint.Y - YC)
              If Not Error Then
                
                A = Max(-1, Min(1, A))
                A = ACos(A)
                If ($hCurrentPoint.X - XC) / ($hLastPoint.X - XC) > ($hCurrentPoint.Y - YC) / ($hLastPoint.Y - YC) Then A = - A
              
                If $bCtrl Then A = Rad(Int(Deg(A) / 15) * 15)
              
                hSelect.Rotate(- A)
                
              Endif
              
            Case CHANGE_MOVE
              hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
              
          End Select
          
        Endif
        
        imvImage.Refresh
      
    End Select
    
  Else If $bFrame Then
    
    imvImage.Refresh
  
  Endif
  
  If $hChangeRect And If Not $bPress Then
    
    iMouse = If($hPaste, Mouse.Pointing, Mouse.Arrow)
    $iChangeAction = CHANGE_NOTHING
    $vChangeIndex = Null
    
    If $hSelect Then
    
      I = $hSelect.FindShape($hCurrentPoint, 8 / imvImage.Zoom)
      If I >= 0 Then
        iMouse = Mouse.SizeAll
        If $vChangeIndex And If $vChangeIndex[0] = $hSelect._Current Then
          $iChangeAction = CHANGE_MOVE
        Else
          $iChangeAction = CHANGE_SELECT
        Endif
        $vChangeIndex = [I, -1]
      Else If $hChangeRect.Contains($hCurrentPoint.X, $hCurrentPoint.Y) Then 
        If $hSelect.FindPoint($hCurrentPoint, 8 / imvImage.Zoom) Then
          iMouse = Mouse.Arrow
          $iChangeAction = CHANGE_POINT
          $vChangeIndex = CImageSelection.FindIndex
        Else
          If $hSelect.FindPoint($hCurrentPoint, 8 / imvImage.Zoom, True) Then
            iMouse = Mouse.Cross
            $iChangeAction = CHANGE_INSERT
            $vChangeIndex = CImageSelection.FindIndex
          Endif
        Endif
      Endif
      
    Endif
    
    If $iChangeAction = CHANGE_NOTHING Then
      If Hyp(Abs($hChangeRect.X - $hCurrentPoint.X), Abs($hChangeRect.Y - $hCurrentPoint.Y)) < 16 Then
        iMouse = Mouse.Cross
        $iChangeAction = CHANGE_ROTATE
        SetMagnet(Null)
      Else If Hyp(Abs($hChangeRect.X + $hChangeRect.W - $hCurrentPoint.X), Abs($hChangeRect.Y + $hChangeRect.H - $hCurrentPoint.Y)) < 16 Then
        iMouse = Mouse.Cross
        $iChangeAction = CHANGE_RESIZE
        SetMagnet(Null)
      Else If $hChangeRect.Contains($hCurrentPoint.X, $hCurrentPoint.Y) Then
        iMouse = Mouse.SizeAll
        $iChangeAction = CHANGE_MOVE
        SetMagnet(Null)
      Endif
    Endif
    
    imvImage.Mouse = iMouse
    
  Else
    
    If $hCurrentPoint.InRect(RectF(0, 0, $hImage.W, $hImage.H)) Or If $bPress Then
      imvImage.Mouse = $iMouse
    Else
      imvImage.Mouse = Mouse.Default
    Endif
  
  Endif
  
End

Private Sub UpdateTool()

  Select Case $sTool
    
    Case "draw", "erase", "line"
      If $bShift <> $bFrame Then
        $bFrame = $bShift
        imvImage.Refresh
      Endif
    
  End Select

End

Public Sub Form_KeyPress()
  
  $bShift = Key.Shift
  $bCtrl = Key.Control
  $bAlt = Key.Alt
  UpdateTool
  imvImage_MouseMove
  
  If $hSelect And If $hChangeRect Then
    If Key.Code = Key.Delete Or If Key.Code = Key.Backspace Then
      If $vChangeIndex Then
        If $vChangeIndex[1] = -1 Then
          $hSelect.RemoveShape($vChangeIndex[0])
        Else
          $hSelect.RemovePoint($vChangeIndex)
        Endif
        If $hSelect.IsVoid() Then ClearSelection
      Endif
      RefreshSelection
    Endif
  Endif
  
End

Public Sub Form_KeyRelease()
  
  $bShift = Key.Shift
  $bCtrl = Key.Control
  $bAlt = Key.Alt
  UpdateTool
  imvImage_MouseMove
  
End

Public Sub imvImage_MouseUp()

  If Not $bPress Then Return

  imvImage_MouseMove()

  Select Case $sTool
    
    Case "draw", "erase"
      $hSaveImage = Null
      $aStroke.Clear
      
    Case "line"
      $hSelect.LineTo($hLastPoint.X, $hLastPoint.Y)
      If $hFirstPoint Then $hSelect.AddMagnet($hFirstPoint)
      $hSelect.AddMagnet($hLastPoint)
      '$hSelect.AddCenterMagnet()

    Case "rectangle"
      If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
        $hSelect.AddMagnetFromRect($hLastPoint.X, $hLastPoint.Y, $hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
        imvImage.Refresh
      Else
        ClearSelection
      Endif
    
    Case "ellipse"
      If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
        $hSelect.AddMagnetFromRect($hLastPoint.X, $hLastPoint.Y, $hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
        imvImage.Refresh
      Else
        ClearSelection
      Endif
      
    Case "change"
      If $iChangeAction = CHANGE_NOTHING Then $hSelect.SelectAll
      If $hLastPoint <> $hCurrentPoint Then
        RefreshSelection
      Else If $iChangeAction <> CHANGE_SELECT Then
        btnUndo_Click
      Endif
      SetMagnet(Null)
      
    Case "paste"
      $hPasteCurrent = $hPasteSelect.Copy()
      $hChangeRect = $hPasteCurrent.GetExtents()
      
  End Select
  
  $bPress = False
  
  imvImage_MouseMove()
  
  UpdateInfo

End

Private Sub DrawTool()
  
  Dim I As Integer
  
  Select Case $sTool
  
    Case "draw", "erase"

      $hImage = $hSaveImage.Copy()
      Paint.Begin($hImage)

      FImageProperty.PaintForStroke
      'Paint.Brush.Scale(Paint.LineWidth, Paint.LineWidth)
      
      If $sTool = "erase" Then 
        Paint.Operator = Paint.OperatorDestOut
      Endif
      
      If $aStroke.Count = 2 Then
        If Not Paint.AntiAlias Then
          Paint.Rectangle($aStroke[0], $aStroke[1], 1, 1)
          Paint.Fill
        Else
          Paint.Arc($aStroke[0], $aStroke[1], Paint.LineWidth / 2)
          Paint.Fill
        Endif
      Else
        Paint.MoveTo($aStroke[0], $aStroke[1])
        For I = 2 To $aStroke.Max Step 2
          Paint.LineTo($aStroke[I], $aStroke[I + 1])
        Next
        Paint.Stroke
      Endif
      
      Paint.End
      Modify
      
    Case "line", "rectangle"
      
  End Select
  
  imvImage.Update($hImage)
  
End

Public Sub imvImage_Draw(hZoom As Image)
  
  Dim hStart As Point
  Dim hEnd As Point
  Dim hOffset As Point
  Dim bAnts As Boolean
  Dim bBalance As Boolean 
  Dim hImage As Image
  Dim hRect As Rect
  Dim X As Integer
  Dim Y As Integer
  Dim iGrid As Integer
    
  If Project.ActiveForm = Me And If FImageProperty.HasBalance() Then bBalance = True
  
  hOffset = imvImage.ImageToView(Point(0, 0))
  
  If bBalance And If Not $hSelect Then
    
    hImage = hZoom.Copy()
    FImageProperty.ApplyBalance(hImage)
    imvImage._Paint(hImage, hOffset.X, hOffset.Y)
    
  Endif
  
  ' If $hMagic Then 
  ' 
  '   Paint.Save
  '   
  '   Paint.Translate(hOffset.X, hOffset.Y)
  '   Paint.Scale(imvImage.Zoom, imvImage.Zoom)
  '   
  '   Paint.DrawImage($hMagic, 0, 0)
  '   
  '   Paint.Restore
  '   
  ' Endif
  
  If $hSelect And If Not $hSelect.IsVoid() Then
    
    Paint.Save
  
    Paint.Translate(hOffset.X, hOffset.Y)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
    
    If bBalance Then
      
      If $hSelect.IsInverted() Then
        hImage = hZoom.Copy()
      Else
        hRect = $hSelect.GetExtentsInt(True)
        If hRect.X < 0 Then
          hRect.W += hRect.X
          hRect.X = 0
        Endif
        If hRect.Y < 0 Then
          hRect.H += hRect.Y
          hRect.Y = 0
        Endif
        hImage = hZoom.Copy(hRect.X, hRect.Y, hRect.Width, hRect.Height)
      Endif
      
      FImageProperty.ApplyBalance(hImage)
      
      If $hSelect.IsInverted() Then
        Paint.Save
        Paint.Reset
        imvImage._Paint(hImage, hOffset.X, hOffset.Y)
        Paint.Restore
      Endif
      
      Paint.Save
      $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
      Paint.Reset
      If $hSelect.IsInverted() Then
        imvImage._Paint(hZoom, hOffset.X, hOffset.Y)
      Else
        imvImage._Paint(hImage, hOffset.X + hRect.X * imvImage.Zoom, hOffset.Y + hRect.Y * imvImage.Zoom)
      Endif
      Paint.Restore
      
    Endif
    
    Paint.LineWidth = 2 / imvImage.Zoom
    Paint.AntiAlias = True
    Paint.LineJoin = Paint.LineJoinRound
    
    Paint.Background = Color.SetAlpha(Color.White, 128)
    Paint.Dash = Null
    $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE)
    
    Paint.Background = Color.SetAlpha(Color.Black, 128)
    Paint.Dash = [2.0, 2.0]
    Paint.DashOffset = - $fDashOffset
    $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE)
    
    Paint.Restore
    
    bAnts = True
    
  Endif
  
  If $bShowGrid Then
    
    Paint.Save
    Paint.AntiAlias = False
  
    Paint.LineWidth = 1 / imvImage.Zoom

    Paint.Translate(hOffset.X, hOffset.Y)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
      
    iGrid = FImageProperty.GetGridResolution()
      
    For X = iGrid To $hImage.W Step iGrid
      Paint.MoveTo(X, 0)
      Paint.LineTo(X, $hImage.H)
    Next
    
    For Y = iGrid To $hImage.H Step iGrid
      Paint.MoveTo(0, Y)
      Paint.LineTo($hImage.W, Y)
    Next
    
    Paint.Background = &H808080&
    Paint.Stroke
    
    Paint.Restore
    
  Endif
    
  If $hMagnet Then
    
    Paint.Save
    
    Paint.AntiAlias = False
    Paint.LineWidth = 1
    
    Paint.Translate($hMagnet.X * imvImage.Zoom + hOffset.X, $hMagnet.Y * imvImage.Zoom + hOffset.Y)
    
    Paint.Background = Color.White

    Paint.Rectangle(- 4, - 3, 9, 9)

    Paint.MoveTo(0, - imvImage.H)
    Paint.LineTo(0, imvImage.H)
    Paint.MoveTo(- imvImage.W, 0)
    Paint.LineTo(imvImage.W, 0)

    Paint.Stroke

    Paint.Background = Color.Black

    Paint.Rectangle(- 3, - 2, 7, 7)

    Paint.MoveTo(0, - imvImage.H)
    Paint.LineTo(0, imvImage.H)
    Paint.MoveTo(- imvImage.W, 0)
    Paint.LineTo(imvImage.W, 0)

    Paint.Dash = [2.0, 2.0]
    Paint.Stroke
    
    Paint.Restore
  
  Endif
    
  If $bFrame And If Not $bPress Then 
  
    Select Case $sTool
      
      Case "draw", "erase", "line"
        
        If Not $hLastPoint Then Return
        If Not $hCurrentPoint Then Return
        
        hStart = imvImage.ImageToView($hLastPoint)
        hEnd = imvImage.ImageToView($hCurrentPoint)
        
        If $sTool = "line" Then
          Paint.LineWidth = 1
          'Paint.AntiAlias = False
          Paint.LineJoin = Paint.LineJoinRound
        Else
          FImageProperty.PaintForStroke
          Paint.LineWidth *= imvImage.Zoom
        Endif
        
        Paint.Background = Color.SetAlpha(Color.White, 128)
        Paint.Dash = Null
        If Not Paint.Antialias Then Paint.Translate(imvImage.Zoom / 2, imvImage.Zoom / 2)
        Paint.MoveTo(hStart.X, hStart.Y)
        Paint.LineTo(hEnd.X, hEnd.Y)
        Paint.Stroke
        Paint.Reset
        
        Paint.Background = Color.SetAlpha(Color.Black, 128)
        Paint.Dash = [2.0, 2.0]
        Paint.DashOffset = - $fDashOffset
        If Not Paint.Antialias Then Paint.Translate(imvImage.Zoom / 2, imvImage.Zoom / 2)
        Paint.MoveTo(hStart.X, hStart.Y)
        Paint.LineTo(hEnd.X, hEnd.Y)
        Paint.Stroke
        Paint.Reset
        
        bAnts = True
      
    End Select
    
  Endif
  
  If $hPaste Then
    
    Paint.Save
    
    'Paint.AntiAlias = False
    
    If $hSelect Then 
      Paint.Translate(hOffset.X, hOffset.Y)
      Paint.Scale(imvImage.Zoom, imvImage.Zoom)
      $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
      Paint.Reset
      'imvImage._Paint($hPaste, hOffset.X + $iPasteX * imvImage.Zoom, hOffset.Y + $iPasteY * imvImage.Zoom)
    Endif
    
    With $hPasteSelect.GetExtents()

      hImage = New Image($hImage.W, $hImage.H, Color.Transparent)
      
      Paint.Begin(hImage)
      Paint.Matrix = $hPasteSelect._Matrix
      Paint.Rectangle(($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2, $hPaste.W, $hPaste.H)
      Paint.Brush = Paint.Image($hPaste, ($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2)
      Paint.Fill
      Paint.End
      
      'imvImage._Paint(hImage, hOffset.X + .X * imvImage.Zoom, hOffset.Y + .Y * imvImage.Zoom)
      imvImage._Paint(hImage, hOffset.X, hOffset.Y)
      
    End With
    
    Paint.Restore
    
  Endif
  
  If $hChangeRect Then
    
    Paint.Save
    
    Paint.Translate(hOffset.X, hOffset.Y)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
    
    Paint.LineWidth = 2 / imvImage.Zoom
    Paint.AntiAlias = True
    Paint.LineJoin = Paint.LineJoinRound
      
    If $sTool = "change" Then
      Paint.Background = Color.SetAlpha(Color.Red, 128)
      $hSelect.Paint($hImage, CImageSelection.ACTION_HANDLE)
      Paint.Background = Color.SetAlpha(Color.Blue, 128)
      $hSelect.Paint($hImage, CImageSelection.ACTION_MAGNET)
    Endif
    
    Paint.Background = Color.SetAlpha(Color.Red, 128)
    Paint.Dash = Null
    
    With $hChangeRect
      
      Paint.Rectangle(.X, .Y, .W, .H)
      Paint.Stroke
      
      'Paint.LineWidth = 1 / imvImage.Zoom
      ' Paint.MoveTo(.X + .W / 2, .Y + .H / 2)
      ' Paint.RelMoveTo(0, -4 / imvImage.Zoom)
      ' Paint.RelLineTo(0, 8 / imvImage.Zoom)
      ' Paint.RelMoveTo(-4 / imvImage.Zoom, -4 / imvImage.Zoom)
      ' Paint.RelLineTo(8 / imvImage.Zoom, 0)
      ' Paint.Stroke
      
    End With
    
    Paint.Background = Color.SetAlpha(Color.White, 128)
    Paint.Dash = [2.0, 2.0]
    Paint.DashOffset = 0
    Paint.Rectangle($hChangeRect.X, $hChangeRect.Y, $hChangeRect.W, $hChangeRect.H)
    Paint.Stroke
    
    Paint.Background = Color.SetAlpha(Color.Red, 128)
    Paint.Arc($hChangeRect.X + 0.5 / imvImage.Zoom, $hChangeRect.Y + 0.5 / imvImage.Zoom, 7 / imvImage.Zoom)
    Paint.Rectangle($hChangeRect.X + $hChangeRect.W + (0.5 - 6) / imvImage.Zoom, $hChangeRect.Y + $hChangeRect.H + (0.5 - 6) / imvImage.Zoom, 12 / imvImage.Zoom, 12 / imvImage.Zoom)
    Paint.Fill
    
    Paint.Restore
      
  Endif
  
  If $iAngle Then
    
    hImage = hZoom.Rotate(Rad($iAngle))
    imvImage._Paint(hImage, hOffset.X + (hZoom.W - hImage.W) / 2 * imvImage.Zoom, hOffset.Y + (hZoom.H - hImage.H) / 2 * imvImage.Zoom)
    'imvImage._Paint(hImage, hOffset.X, hOffset.Y)
    
  Endif
  
  timSelect.Enabled = bAnts
  
End

Public Sub timSelect_Timer()

  $fDashOffset += 0.5
  If $fDashOffset >= 4 Then $fDashOffset = 0
  imvImage.Refresh

End

Public Sub btnStroke_Click()

  Dim hImage As Image

  If $hSelect Then
    
    hImage = $hImage.Copy()
    Paint.Begin(hImage)
    FImageProperty.PaintForStroke($hSelect.GetExtents())
    $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE)
    Paint.End
    ActionImage(hImage)
    
  Endif

End

Public Sub btnFill_Click()

  Dim hImage As Image

  hImage = $hImage.Copy()
  Paint.Begin(hImage)
  If $hSelect Then
    FImageProperty.PaintForFill($hSelect.GetExtents())
    $hSelect.Paint($hImage, CImageSelection.ACTION_FILL)
  Else
    Paint.Rectangle(0, 0, hImage.W, hImage.H)
    Paint.Fill
  Endif
  Paint.End
  ActionImage(hImage)

End

Public Sub btnInvert_Click()

  CreateSelection
  AddUndo($hSelect.Copy())
  $hSelect.Invert()
  If $hSelect.IsVoid() Then ClearSelection
  RefreshSelection

End

Public Sub timCheckZoom_Timer()

  btnZoomFit_Click

End

Public Sub imvImage_Menu()

  Me.SetFocus
  mnuEditor.Popup

End

Public Sub mnuSelectAll_Click()
  
  $hSelect = New CImageSelection
  btnInvert_Click

End

Public Sub btnClear_Click()

  Dim hImage As Image

  If $hSelect Then
    
    hImage = $hImage.Copy()
    Paint.Begin(hImage)
    FImageProperty.PaintForFill
    $hSelect.Paint($hImage, CImageSelection.ACTION_CLEAR)
    Paint.End
    ActionImage(hImage)
    
  Else
    
    hImage = New Image($hImage.W, $hImage.H, Color.Transparent) '$hImage.Copy()
    'hImage.Transparent(FImageProperty.GetColor(True))
    ActionImage(hImage)
    
  Endif

End

Public Sub btnCrop_Click()

  Dim hImage As Image
  Dim hRect As Rect
  
  If $hSelect Then
    
    $hSelect.Invert
    
    hImage = $hImage.Copy()
    
    Paint.Begin(hImage)
    Paint.Brush = Paint.Color(Color.Black)
    $hSelect.Paint(hImage, CImageSelection.ACTION_CLEAR)
    Paint.End

    $hSelect.Invert

    If Not $hSelect.IsInverted() Then
      hRect = $hSelect.GetExtentsInt(True)
      If hRect Then hImage = hImage.Copy(hRect.X, hRect.Y, hRect.Width, hRect.Height)
    Endif
    
    
    BeginUndo
    AddUndo($hSelect.Copy())
    ClearSelection
    ActionImage(hImage)
    EndUndo
    
  Endif

End

Private Sub BeginUndo()

  $aUndo.Add(BEGIN_UNDO)
  $aRedo.Clear

End

Private Sub EndUndo()
  
  Dim vUndo As Variant = $aUndo[$aUndo.Max]
  
  If TypeOf(vUndo) = gb.Integer And If vUndo = BEGIN_UNDO Then
    $aUndo.Pop()
  Else
    $aUndo.Add(END_UNDO)
  Endif
  
  $aRedo.Clear
  
End

' Fast Private Sub CheckPoint(iCol As Integer, X2 As Integer, Y2 As Integer, A0 As Integer) As Boolean
' 
'   Dim R, G, B, A As Float
'   Dim R2, G2, B2, A2 As Float
'   Dim N As Integer
'   Dim F As Float
'   Dim D As Integer
'   
'   'R = $R / $N
'   'G = $G / $N
'   'B = $B / $N
'   'A = $A / $N
'   
'   With Color[iCol]
'     R = .Red
'     G = .Green
'     B = .Blue
'     A = .Alpha
'   End With
'   
'   With Color[$hImage[X2, Y2]]
'     F = (255 - .Alpha) / 255
'     R2 = .Red * F
'     G2 = .Green * F
'     B2 = .Blue * F
'     A2 = .Alpha
'     N = 1
'   End With
'   
'   ' If X2 > 0 Then
'   '   With Color[$hImage[X2 - 1, Y2]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If X2 < ($hImage.W - 1) Then
'   '   With Color[$hImage[X2 + 1, Y2]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If Y2 > 0 Then
'   '   With Color[$hImage[X2, Y2 - 1]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If Y2 < ($hImage.W - 1) Then
'   '   With Color[$hImage[X2, Y2 + 1]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' R2 /= N
'   ' G2 /= N
'   ' B2 /= N
'   ' A2 /= N
'   
'   A0 = A0 * 1.1
'   D = Max(Max(Abs(R2 - R), Abs(G2 - G)), Max(Abs(B2 - B), Abs(A2 - A))) + A0
'   'Print X2;; Y2;; D
'   If D >= 255 Then Return
'   
'   '$R += R2
'   '$G += G2
'   '$B += B2
'   '$A += A2
'   Inc $N
' 
'   $hMagic[X2, Y2] = Color.SetAlpha(Color.Black, D)
'   '$hImage[X2, Y2] = Color.Blend($hImage[X2, Y2], $hMagic[X2, Y2])
'   If ($N And 1023) = 0 Then 
'     imvImage.Refresh
'     Wait
'   Endif
' 
'   Return True
' 
' End
' 
' Fast Private Sub MagicWand()
' 
'   Dim aPoint As New Integer[]
'   Dim X, Y, X2, Y2, A As Integer
'   Dim hImage As Image
'   
'   $iTol = 1 'FImageProperty.GetTolerance()
'   
'   $hMagic = New Image($hImage.W, $hImage.H, Color.White)
'   
'   aPoint.Add($hLastPoint.X)
'   aPoint.Add($hLastPoint.Y)
'   
'   With Color[$hImage[$hLastPoint.X, $hLastPoint.Y]]
'     $R = .Red * (255 - .Alpha) / 255
'     $G = .Green * (255 - .Alpha) / 255
'     $B = .Blue * (255 - .Alpha) / 255
'     $A = .Alpha
'     $N = 1
'   End With
'   
'   $hMagic[$hLastPoint.X, $hLastPoint.Y] = Color.Black
'   
'   While aPoint.Count
'     
'     X = aPoint[0]
'     Y = aPoint[1]
'     aPoint.Remove(0, 2)
'     
'     A = Color.GetAlpha($hMagic[X, Y])
'     
'     X2 = X + 1
'     Y2 = Y
'     GoSub LOOK_POINT
'     X2 = X + 1
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     X2 = X
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     X2 = X + 1
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     
'   Wend
'   
'   hImage = $hImage.Copy()
'   $hMagic.Replace(Color.White, Color.Transparent)
'   '$hMagic = $hMagic.Fuzzy(1)
'   hImage.PaintImage($hMagic, 0, 0)
'   ActionImage(hImage)
'   $hMagic = Null
'   Return
'   
' LOOK_POINT:
' 
'   If X2 < 0 Or If Y2 < 0 Or If X2 >= $hImage.W Or If Y2 >= $hImage.H Then Return
'   If $hMagic[X2, Y2] <> Color.White Then Return
'   
'   If CheckPoint($hImage[X, Y], X2, Y2, A) Then
'     aPoint.Add(X2)
'     aPoint.Add(Y2)
'   Endif
'   
'   Return
'   
' End

Public Sub btnZoomFit_Click()

  Dim iIndex As Integer
  Dim fZoom As Float
  
  For iIndex = 0 To cmbZoom.Count - 1
    
    fZoom = CFloat(String.Left(cmbZoom[iIndex].Text, -1))
    If ($hImage.W * fZoom) > imvImage.W Or If ($hImage.H * fZoom) > imvImage.H Then Break
    
  Next
  
  cmbZoom.Index = Max(0, iIndex - 1)

End

Public Sub btnCopy_Click()

  Dim hImage As Image
  Dim hExt As Rect
  
  If $hSelect Then
    
    $hSelect.Invert
    
    hImage = $hImage.Copy()
    
    Paint.Begin(hImage)
    Paint.Brush = Paint.Color(Color.Black)
    $hSelect.Paint(hImage, CImageSelection.ACTION_CLEAR)
    Paint.End

    $hSelect.Invert

    If Not $hSelect.IsInverted() Then
      hExt = $hSelect.GetExtentsInt(True)
      If hExt Then hImage = hImage.Copy(hExt.X, hExt.Y, hExt.Width, hExt.Height)
    Endif
    
    Inc $iClipboard
    FImageProperty.AddClipboard(hImage, Me.Name & " [" & CStr($iClipboard) & "]")
    
  Else
    
    FImageProperty.AddClipboard($hImage.Copy(), Me.Name)
    
  Endif

End

Public Sub btnCut_Click()

  Dim hImage As Image

  BeginUndo

  btnCopy_Click

  If $hSelect Then
    
    hImage = $hImage.Copy()
    Paint.Begin(hImage)
    $hSelect.Paint($hImage, CImageSelection.ACTION_CLEAR)
    Paint.End
    ActionImage(hImage)
    
  Else
    
    hImage = New Image($hImage.W, $hImage.H, Color.Transparent)
    ActionImage(hImage)
    
  Endif

  EndUndo

End

Private Sub DoPaste()

  Dim hImage As Image
  
  If Not $hPaste Then Return
  
  hImage = $hImage.Copy()
  Paint.Begin(hImage)

  ' If $hSelect Then 
  '   $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
  '   Paint.Brush = Paint.Image($hPaste, $hChangeRect.X, $hChangeRect.Y)
  '   Paint.Rectangle($hChangeRect.X, $hChangeRect.Y, $hChangeRect.W, $hChangeRect.H)
  '   Paint.Fill
  '   Paint.ResetClip
  ' Else
  '   Paint.DrawImage($hPaste, $hChangeRect.X, $hChangeRect.Y)
  ' Endif
  
    If $hSelect Then $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
    
    With $hPasteSelect.GetExtents()

      Paint.Matrix = $hPasteSelect._Matrix
      Paint.Rectangle(($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2, $hPaste.W, $hPaste.H)
      Paint.Brush = Paint.Image($hPaste, ($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2)
      Paint.Fill
      
    End With

  Paint.End
  
  ActionImage(hImage)
  
End

Public Sub Form_Activate()

  If Not $bFirstTime Then 
    btnZoomFit_Click
    $bFirstTime = True
  Endif

End

Public Sub RefreshSelection()
  
  imvImage.Refresh
  If $sTool = "change" Then 
    If $hSelect Then
      $hChangeRect = $hSelect.GetExtents()
    Else
      $hChangeRect = Null
    Endif
  Endif
  
End

Public Sub imvImage_Leave()

  $iChangeAction = CHANGE_NOTHING
  FImageProperty.UpdateInfo("")

End

Public Sub ApplyBalance()
  
  Dim hImage As Image
  Dim hBalance As Image
  
  If $hSelect Then

    If $hSelect.IsInverted() Then
      
      hImage = $hImage.Copy()
      FImageProperty.ApplyBalance(hImage)
      
      Paint.Begin(hImage)
      $hSelect.Paint(hImage, CImageSelection.ACTION_CLIP)
      Paint.DrawImage($hImage, 0, 0)
      Paint.End
      
    Else
    
      hImage = $hImage.Copy()
      
      hBalance = $hImage.Copy()
      FImageProperty.ApplyBalance(hBalance)
    
      Paint.Begin(hImage)
      $hSelect.Paint(hImage, CImageSelection.ACTION_CLIP)
      Paint.DrawImage(hBalance, 0, 0)
      Paint.End

    Endif

    ActionImage(hImage)
    
  Else
    
    hImage = $hImage.Copy()
    FImageProperty.ApplyBalance(hImage)
    ActionImage(hImage)
    
  Endif
  
End

Public Sub OnProjectDebug()

  SetReadOnly

End

Private Sub UpdateMenu()

  Dim bVisible As Boolean

  bVisible = Not $bReadOnly

  If $bReadOnly Then SetTool("move")

  mnuAction.Visible = bVisible
  mnuZoom.Visible = bVisible
  
  Action[".save,.reload,.undo,.redo,.tool-*,.invert,.stroke,.fill,.clear,.cut,.copy,.crop,.flip-h,.flip-v,.rotate-*,.resize,.select-all,.hide-selection", Me].Visible = bVisible
  
End

Public Sub mnuHideSelection_Click()
  
  If $hSelect Then
    ClearSelection
  Else
    FMain.HidePanels
  Endif

End

Public Sub mnuPaste_Click()
  
  SetTool("paste")
  
End


Public Sub panToolBar_Configure()

  UpdateMenu

End

Public Sub btnResizeSelection_Click()

  If Not $hSelect Then Return
  If FImageResizeSelection.Run() Then Return
  
  AddUndo($hSelect.Copy())
  $hSelect.Enlarge(FImageResizeSelection.Size, FImageResizeSelection.Duplicate)
  RefreshSelection

End

Public Sub btnRotate_Click()

  If FImageRotate.Run(Me) Then 
    imvImage.Update($hImage)
    Return
  Endif
  ActionImage($hImage.Rotate(Rad(FImageRotate.Angle)))

End

Public Sub UpdateRotation(iAngle As Integer)
  
  '$iAngle = iAngle
  imvImage.Update($hImage.Rotate(Rad(iAngle)))
  
End

Public Sub Form_GotFocus()

  imvImage.SetFocus

End

Public Sub imvImage_GotFocus()

  Project.SetCurrentPopup(mnuEditor)

End

Public Sub mnuClose_Click()
  
  Me.Close
  
End

Public Sub PasteShape(hShape As CImageSelection)
  
  Dim S As Float
  
  If btnEditSelection.Value Then
    SetTool("change")
  Else
    btnEditSelection.Value = True
  Endif
  
  BeginUndo
  
  CreateSelection
  
  hShape = hShape.Copy()
  With hShape.GetExtents()
    S = Min(imvImage.ScrollW / imvImage.Zoom * 0.25 / .W, imvImage.ScrollH / imvImage.Zoom * 0.25 / .H)
    hShape.Translate($hImage.W / 2, $hImage.H / 2)
    hShape.Scale(S, S)
  End With
  
  $hSelect.Select($hSelect.AddSelection(hShape))
  
  RefreshSelection
  
  EndUndo
  
End

Public Sub UpdateBalance()
  
  imvImage.Refresh
  
End

Public Sub btnGrid_Click()

  $bShowGrid = Not $bShowGrid
  imvImage.Refresh

End

Public Sub UpdateGrid()
  
  imvImage.Refresh
  
End

