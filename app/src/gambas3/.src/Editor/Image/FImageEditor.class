' Gambas class file

Public Path As String

Property Read ReadOnly As Boolean

Private $bReadOnly As Boolean
Private $hImage As Image
Private $bModify As Boolean
Private $iMouse As Integer

Private $bFirstTime As Boolean

Private $aUndo As New Variant[]
Private $aRedo As New Variant[]
Private Enum BEGIN_UNDO, END_UNDO

Private $sTool As String
Private $hFirstPoint As PointF
Private $hLastPoint As PointF
Private $hCurrentPoint As PointF
Private $bPress As Boolean
Private $bShift As Boolean
Private $bCtrl As Boolean
Private $bAlt As Boolean

Private $bFrame As Boolean
Private $fDashOffset As Float

Private $SX As Integer
Private $SY As Integer

Private $aStroke As New Integer[]
Private $hSaveImage As Image

Private $hSelect As CImageSelection

Private $hLastMagnet As PointF
Private $hMagnet As PointF

' Private $hMagic As Image
' Private $R As Integer
' Private $G As Integer
' Private $B As Integer
' Private $A As Integer
' Private $N As Integer
' Private $iTol As Integer

Private $iClipboard As Integer

Private $hPaste As Image
Private $hPasteCurrent As CImageSelection
Private $hPasteSelect As CImageSelection

Private $iAngle As Integer

Private $hChangeRect As Rect
Private $iChangeAction As Integer
Private Enum CHANGE_NOTHING, CHANGE_MOVE, CHANGE_RESIZE, CHANGE_ROTATE

Public Sub _new(sPath As String)
  
  Me.Name = File.Name(sPath)
  Path = sPath
  
  dwgBackground.Lower
  
  Reload
  
  SetTool("move")
  
End


Private Function ReadOnly_Read() As Boolean

  Return $bReadOnly

End

Private Sub ClearSelection()

  If Not $hSelect Then Return
  
  AddUndo($hSelect.Copy())
  $hSelect = Null
  $hChangeRect = Null
  $hMagnet = Null
  $hLastMagnet = Null
  RefreshSelection

End

Private Sub CreateSelection()
  
  If $hSelect Then Return
  $hSelect = New CImageSelection
  RefreshSelection
  
End


Public Sub Reload()
  
  $hImage = Image.Load(Path)
  imvImage.Image = $hImage  
  $bModify = False
  ClearSelection
  $aUndo.Clear
  $aRedo.Clear
  DrawTitle
  btnZoomFit_Click
  
End

Public Sub LoadFile() As Boolean
  
  Reload
  
End

Public Sub btnZoomIn_Click()

  Try Inc cmbZoom.Index

End

Public Sub btnZoomOut_Click()

  If cmbZoom.Index = 0 Then Return
  Dec cmbZoom.Index

End

Public Sub cmbZoom_Click()

  imvImage.Zoom = CFloat(Trim(String.Left(cmbZoom.Text, -1)))
  imvImage.Grid = imvImage.Zoom > 8

End

Public Sub IsModified() As Boolean
  
  Return $bModify
  
End

Public Sub dwgBackground_Draw()

  Dim hTopLeft As Point
  Dim hBottomRight As Point

  Project.DrawBackground()
  
  hTopLeft = imvImage.ImageToView(Point(0, 0))
  If Not hTopLeft Then Return
  hBottomRight = imvImage.ImageToView(Point(imvImage.Image.W, imvImage.Image.H))

  Paint.Background = Color.SetAlpha(Color.Black, 192)
  Paint.Rectangle(hTopLeft.X - 2, hTopLeft.Y - 2, hBottomRight.X - hTopLeft.X + 4, 2)
  Paint.Rectangle(hTopLeft.X - 2, hBottomRight.Y, hBottomRight.X - hTopLeft.X + 4, 2)
  Paint.Rectangle(hTopLeft.X - 2, hTopLeft.Y, 2, hBottomRight.Y - hTopLeft.Y)
  Paint.Rectangle(hBottomRight.X, hTopLeft.Y, 2, hBottomRight.Y - hTopLeft.Y)
  Paint.Fill

End

Public Sub Form_Open()

  SetReadOnly

End

Private Sub SetReadOnly()

  'Dim hCtrl As Control  

  $bReadOnly = False
  
  If Project.ReadOnly Or If Project.Running Or If Project.IsReadOnly(Path) Then
    $bReadOnly = True
  Endif

  UpdateMenu

End

Private Sub DrawTitle()

  Project.DrawTitle(Me)

End

Public Sub btnZoomNormal_Click()

  cmbZoom.Index = 3

End

Public Sub Modify(Optional bReset As Boolean)

  If Project.ReadOnly Or $bReadOnly Then Return
  If $bModify <> bReset Then Return

  $bModify = Not bReset
  DrawTitle
  If $bModify Then Inc Project.TimeStamp

End

Private Sub ActionImage(hImage As Image)
  
  AddUndo($hImage)
  $hImage = hImage
  
  imvImage.Update($hImage)
  Modify
  imvImage.SetFocus
  
End

Private Sub AddUndo(hObject As Object)
  
  If Not hObject Then Return
  If $aUndo.Count = 64 Then $aUndo.Remove(0)
  $aUndo.Add(hObject)
  $aRedo.Clear
  
End

Public Sub btnRotateL_Click()

  If $hChangeRect Then
    
    AddUndo($hSelect.Copy())
    $hSelect.Rotate(Rad(90))
    RefreshSelection

  Else
    
    BeginUndo
    ClearSelection
    ActionImage($hImage.Copy().RotateLeft())
    EndUndo

  Endif

End

Public Sub btnRotateR_Click()

  If $hChangeRect Then
    
    AddUndo($hSelect.Copy())
    $hSelect.Rotate(Rad(-90))
    RefreshSelection

  Else
    
    BeginUndo
    ClearSelection
    ActionImage($hImage.Copy().RotateRight())
    EndUndo
    
  Endif
  
End

Public Sub btnFlipH_Click()

  If $hChangeRect Then

    AddUndo($hSelect.Copy())
    $hSelect.HFlip()
    RefreshSelection

  Else
    
    BeginUndo
    ClearSelection
    ActionImage($hImage.Copy().Mirror(True, False))
    EndUndo
    
  Endif
  
End

Public Sub btnFlipV_Click()

  If $hChangeRect Then

    AddUndo($hSelect.Copy())
    $hSelect.VFlip()
    RefreshSelection

  Else
    
    BeginUndo
    ClearSelection
    ActionImage($hImage.Copy().Mirror(False, True))
    EndUndo
    
  Endif
  
End


Public Function Save() As Boolean

  If Project.ReadOnly Then Return
  If $bReadOnly Then Return
  If Not $bModify Then Return

  'PRINT "Picture not saved"

  'HideSelection

  Save.Begin(Path)

  $hImage.Save(Path)

  'Project.RefreshKey(Path)

  $bModify = False
  DrawTitle
  Save.End()

Catch

  Return Save.Error()

End

Public Sub btnSave_Click()

  Me.Save

End

Public Sub btnReload_Click()

  If IsModified() Then
    If Message.Warning(("The file has been modified.\n\nAll your changes will be lost."), ("Reload"), ("Cancel")) <> 1 Then Return
  Endif

  Reload

End

Public Sub btnResize_Click()

  Dim X, Y, W, H As Integer
  Dim hImage As Image

  FImageResize.ImageWidth = $hImage.Width
  FImageResize.ImageHeight = $hImage.Height
  
  If FImageResize.Run() Then Return
  
  W = FImageResize.ImageWidth
  H = FImageResize.ImageHeight
  
  If W = $hImage.W And If H = $hImage.H Then Return
  
  If FImageResize.Stretch Then
    ActionImage($hImage.Stretch(W, H))
  Else
    hImage = New Image(W, H, Color.Transparent)
    If FImageResize.CenterH Then X = (W - $hImage.W) \ 2
    If FImageResize.CenterV Then Y = (H - $hImage.H) \ 2
    hImage.DrawImage($hImage, X, Y)
    ActionImage(hImage)
  Endif

End

Public Sub Rename(sNewName As String, sNewPath As String)

  Me.Name = sNewName
  Path = sNewPath 
  DrawTitle

End

Private Sub SetTool(sAction As String)

  Dim hCtrl As ToolButton
  Dim hImage As Image
  
  'If $sTool = sAction Then Return

  For Each hCtrl In [btnMove, btnDraw, btnErase, btnRectangle, btnEllipse, btnLine, btnMagic, btnPaste, btnEditSelection]
    Object.Lock(hCtrl)
    hCtrl.Value = hCtrl.Tag = sAction
    Object.Unlock(hCtrl)
  Next
  
  If $sTool = "paste" Then
    If $hPaste Then
      $hPaste = Null
      $hPasteSelect = Null
      $hPasteCurrent = Null
      imvImage.Refresh
    Endif
  Endif
  
  $hChangeRect = Null

  $iMouse = Mouse.Arrow

  Select Case sAction
    
    Case "move"
      $iMouse = Mouse.SizeAll
    
    Case "draw", "erase"
      $iMouse = Mouse.Cross
    
    Case "rectangle", "ellipse", "line", "magic"
      AddUndo($hSelect)
      If $sTool = sAction Or If Not $hSelect Then 
        ClearSelection
      Endif
      imvImage.Refresh
      
    Case "paste"
      hImage = FImageProperty.GetClipboard()
      If hImage Then 
  
        $hPaste = hImage
        
        $hPasteCurrent = New CImageSelection
        $hPasteCurrent.Rectangle(($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2, $hPaste.W, $hPaste.H)
        $hPasteSelect = $hPasteCurrent.Copy()

        $hChangeRect = $hPasteCurrent.GetExtents()

        imvImage.Refresh
        
      Endif
      
    Case "change"
      If $hSelect And If Not $hSelect.IsVoid() Then
        $hChangeRect = $hSelect.GetExtents()
      Endif

  End Select
  
  $sTool = sAction

End

Public Sub btnTool_Click()

  SetTool(Last.Tag)

End

Public Sub imvImage_Scroll()
  
  If Not $bPress Then imvImage_MouseMove
  
End


Public Sub btnUndo_Click()

  Dim vUndo As Variant
  Dim iLevel As Integer

  If $aUndo.Count = 0 Then Return
  
  Repeat
  
    vUndo = $aUndo.Pop()
    
    If TypeOf(vUndo) = gb.Integer Then
      $aRedo.Add(vUndo)
      If vUndo = END_UNDO Then
        Inc iLevel
      Else If vUndo = BEGIN_UNDO Then
        Dec iLevel
      Endif
    Else If vUndo Is Image Then
      $aRedo.Add($hImage)
      $hImage = vUndo
      imvImage.Update($hImage)
      Modify
    Else If vUndo Is CImageSelection Then
      $aRedo.Add($hSelect)
      $hSelect = vUndo
      imvImage.Refresh
    Endif
    
  Until iLevel = 0

  RefreshSelection
  
End

Public Sub btnRedo_Click()

  Dim vUndo As Variant
  Dim iLevel As Integer

  If $aRedo.Count = 0 Then Return
  
  Repeat
    
    vUndo = $aRedo.Pop()
  
    If TypeOf(vUndo) = gb.Integer Then
      $aUndo.Add(vUndo)
      If vUndo = BEGIN_UNDO Then
        Inc iLevel
      Else If vUndo = END_UNDO Then
        Dec iLevel
      Endif
    Else If vUndo Is Image Then
      $aUndo.Add($hImage)
      $hImage = vUndo
      imvImage.Update($hImage)
      Modify
    Else If vUndo Is CImageSelection Then
      $aUndo.Add($hSelect)
      $hSelect = vUndo
      imvImage.Refresh
    Endif
    
  Until iLevel = 0

  RefreshSelection
  
End

Private Sub GetPos() As Point
  
  Return Point(Mouse.ScreenX - imvImage.ScreenX, Mouse.ScreenY - imvImage.ScreenY)
  
End

Private Sub GetImagePos() As PointF
  
  Dim hPoint As Point = imvImage.ViewToImage(GetPos())
  
  Return PointF(hPoint.X, hPoint.Y)
  
End


Public Sub imvImage_MouseDown()

  Me.SetFocus
  $bPress = Mouse.Left
  If Not $bPress Then Return
  
  Select Case $sTool
    
    Case "move"
      $SX = imvImage.ScrollX
      $SY = imvImage.ScrollY
    
    Case "draw", "erase"
      AddUndo($hImage)
      $hSaveImage = $hImage.Copy()
      If Not Mouse.Shift Then 
        $hLastPoint = GetImagePos()
        If $hMagnet Then $hLastPoint = $hMagnet
      Endif
      $aStroke.Clear
      $aStroke.Add($hLastPoint.X)
      $aStroke.Add($hLastPoint.Y)
      DrawTool
      
    Case "line"
      
      CreateSelection
      AddUndo($hSelect.Copy())
      
      $hCurrentPoint = GetImagePos()
      If $hMagnet Then $hCurrentPoint = $hMagnet
      If Not Mouse.Shift Or If Not $hLastPoint Then 
        $hSelect.MoveTo($hCurrentPoint.X, $hCurrentPoint.Y)
      Else
        $hSelect.LineTo($hCurrentPoint.X, $hCurrentPoint.Y)
        $hSelect.AddMagnet(PointF(($hCurrentPoint.X + $hLastPoint.X) / 2, ($hCurrentPoint.Y + $hLastPoint.Y) / 2))
      Endif
      $hFirstPoint = $hCurrentPoint
      $hLastPoint = $hCurrentPoint
      imvImage.Refresh
      
    Case "rectangle", "ellipse"

      CreateSelection
      AddUndo($hSelect.Copy())
      
      $hLastPoint = GetImagePos()
      If $hMagnet Then $hLastPoint = $hMagnet
      
    Case "magic"
      
      CreateSelection
      AddUndo($hSelect.Copy())
      $hLastPoint = GetImagePos()
      'MagicWand
    
    Case "paste"
      If $hPaste Then
        $hLastPoint = GetImagePos()
        If $iChangeAction = CHANGE_NOTHING Then
          DoPaste
        Else
          $hLastPoint = GetImagePos()
        Endif
      Endif
      
    Case "change"
      AddUndo($hSelect.Copy())
      $hLastPoint = GetImagePos()
      
  End Select
  
  imvImage_MouseMove()

End

Private Sub SetMagnet(hPoint As PointF)

  If IsNull(hPoint) And IsNull($hMagnet) Then Return
  If hPoint And If $hMagnet And If hPoint.X = $hMagnet.X And If hPoint.Y = $hMagnet.Y Then Return
  $hLastMagnet = $hMagnet
  $hMagnet = hPoint
  imvImage.Refresh

End

Private Sub UpdateInfo()
  
  Dim sInfo As String

  If $hCurrentPoint.InRect(RectF(0, 0, $hImage.W, $hImage.H)) Or If $bPress Then
    sInfo = CStr($hCurrentPoint.X) & " , " & CStr($hCurrentPoint.Y)
    If $bPress Then
      If $sTool = "rectangle" Or If $sTool = "ellipse" Then
        If $bShift Then
          sInfo &= "   ( " & (Abs($hCurrentPoint.X - $hLastPoint.X) * 2) & " x " & (Abs($hCurrentPoint.Y - $hLastPoint.Y) * 2) & " )"
        Else
          sInfo &= "   ( " & Abs($hCurrentPoint.X - $hLastPoint.X) & " x " & Abs($hCurrentPoint.Y - $hLastPoint.Y) & " )"
        Endif
      Endif
    Endif
  Endif
  
  FImageProperty.UpdateInfo(sInfo)
  
End


Public Sub imvImage_MouseMove()

  Dim hPos As Point = GetPos()
  Dim WW, HH As Float
  Dim hPoint As PointF
  Dim iMouse As Integer
  Dim XC, YC As Float
  Dim A As Float
  Dim hMagnet As PointF
  Dim hSelect As CImageSelection
  
  $hCurrentPoint = GetImagePos()
  
  UpdateInfo
  
  If $hSelect Then hMagnet = $hSelect.FindMagnet($hCurrentPoint.X, $hCurrentPoint.Y, 8 / imvImage.Zoom)
  If Not hMagnet And If $sTool <> "move" Then
    hMagnet = CImageSelection.FindMagnetFrom([PointF(0, 0), PointF($hImage.W, $hImage.H), PointF(0, $hImage.H), PointF($hImage.W, 0)], $hCurrentPoint.X, $hCurrentPoint.Y, 8 / imvImage.Zoom)
  Endif
  SetMagnet(hMagnet)
  
  'If Not $bShift Then
  
    If $hMagnet Then 
      $hCurrentPoint = $hMagnet
    Else If $hLastMagnet Then
      
      If $hCurrentPoint.X > ($hLastMagnet.X - 4 / imvImage.Zoom) And If $hCurrentPoint.X < ($hLastMagnet.X + 4 / imvImage.Zoom) Then
        $hCurrentPoint.X = $hLastMagnet.X
      Endif
      If $hCurrentPoint.Y > ($hLastMagnet.Y - 4 / imvImage.Zoom) And If $hCurrentPoint.Y < ($hLastMagnet.Y + 4 / imvImage.Zoom) Then
        $hCurrentPoint.Y = $hLastMagnet.Y
      Endif
    Endif
    
  'Endif
  
  If $bPress Then
    
    If $sTool <> "move" Then imvImage.EnsureVisible(imvImage.ScrollX + hPos.X - 32, imvImage.ScrollY + hPos.Y - 32, 64, 64)
    
    Select Case $sTool
      
      Case "move"
        imvImage.Scroll($SX - (Mouse.X - Mouse.StartX), $SY - (Mouse.Y - Mouse.StartY))
      
      Case "draw", "erase"
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $aStroke.Add($hCurrentPoint.X)
          $aStroke.Add($hCurrentPoint.Y)
          DrawTool
          $hLastPoint = $hCurrentPoint
        Endif
      
      Case "line"
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect.LineTo($hCurrentPoint.X, $hCurrentPoint.Y)
          imvImage.Refresh
          $hLastPoint = $hCurrentPoint
        Endif
        
        If $hFirstPoint And If Hyp($hCurrentPoint.X - $hFirstPoint.X, $hCurrentPoint.Y - $hFirstPoint.Y) > 8 Then 
          $hSelect.AddMagnet($hFirstPoint)
          $hFirstPoint = Null
        Endif
        
      Case "rectangle"
        If $bCtrl Then $hCurrentPoint.Y = $hLastPoint.Y + Abs($hCurrentPoint.X - $hLastPoint.X) * Sgn($hCurrentPoint.Y - $hLastPoint.Y)
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect = $aUndo[$aUndo.Max].Copy()
          If $bShift Then
            WW = $hCurrentPoint.X - $hLastPoint.X
            HH = $hCurrentPoint.Y - $hLastPoint.Y
            $hSelect.Rectangle($hLastPoint.X - WW, $hLastPoint.Y - HH, WW * 2, HH * 2, True)
          Else
            $hSelect.Rectangle($hLastPoint.X, $hLastPoint.Y, $hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y, True)
          Endif
          imvImage.Refresh
        Endif
      
      Case "ellipse"
        If $bCtrl Then $hCurrentPoint.Y = $hLastPoint.Y + Abs($hCurrentPoint.X - $hLastPoint.X) * Sgn($hCurrentPoint.Y - $hLastPoint.Y)
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          $hSelect = $aUndo[$aUndo.Max].Copy()
          If $bShift Then
            WW = Abs($hCurrentPoint.X - $hLastPoint.X)
            HH = Abs($hCurrentPoint.Y - $hLastPoint.Y)
            $hSelect.Ellipse($hLastPoint.X - WW, $hLastPoint.Y - HH, WW * 2, HH * 2, True)
          Else
            $hSelect.Ellipse(Min($hLastPoint.X, $hCurrentPoint.X), Min($hLastPoint.Y, $hCurrentPoint.Y), Abs($hCurrentPoint.X - $hLastPoint.X), Abs($hCurrentPoint.Y - $hLastPoint.Y), True)
          Endif
          imvImage.Refresh
        Endif
        
      Case "change", "paste"
        
        If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
          
          XC = $hChangeRect.X + $hChangeRect.W / 2
          YC = $hChangeRect.Y + $hChangeRect.H / 2
          
          If $sTool = "change" Then
            $hSelect = $aUndo[$aUndo.Max].Copy()
            hSelect = $hSelect
          Else
            $hPasteSelect = $hPasteCurrent.Copy()
            hSelect = $hPasteSelect
          Endif
          
          Select Case $iChangeAction
            
            Case CHANGE_RESIZE
              If $bCtrl Then
                hSelect.Scale(($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), ($hCurrentPoint.X - XC) / ($hLastPoint.X - XC))
              Else
                hSelect.Scale(($hCurrentPoint.X - XC) / ($hLastPoint.X - XC), ($hCurrentPoint.Y - YC) / ($hLastPoint.Y - YC))
              Endif
              
            Case CHANGE_ROTATE
              A = ($hLastPoint.X - XC) * ($hCurrentPoint.X - XC) + ($hLastPoint.Y - YC) * ($hCurrentPoint.Y - YC)
              A /= Hyp($hLastPoint.X - XC, $hLastPoint.Y - YC) * Hyp($hCurrentPoint.X - XC, $hCurrentPoint.Y - YC)
              A = Max(-1, Min(1, A))
              A = ACos(A)
              If ($hCurrentPoint.X - XC) < ($hCurrentPoint.Y - YC) Then A = - A
              
              hSelect.Rotate(- A)
              
            Case CHANGE_MOVE
              hSelect.Translate($hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
              
          End Select
          
          imvImage.Refresh
          
        Endif
      
    End Select
    
  Else If $bFrame Then
    
    imvImage.Refresh
  
  Endif
  
  If $hChangeRect And If Not $bPress Then
    
    iMouse = Mouse.Pointing
    $iChangeAction = CHANGE_NOTHING
    
    hPoint = $hCurrentPoint
    
    If Hyp(Abs($hChangeRect.X - $hCurrentPoint.X), Abs($hChangeRect.Y - $hCurrentPoint.Y)) < 16 Then
      iMouse = Mouse.Cross
      $iChangeAction = CHANGE_ROTATE
    Else
      If Hyp(Abs($hChangeRect.X + $hChangeRect.W - $hCurrentPoint.X), Abs($hChangeRect.Y + $hChangeRect.H - $hCurrentPoint.Y)) < 16 Then
        iMouse = Mouse.Cross
        $iChangeAction = CHANGE_RESIZE
      Else
        If $hChangeRect.Contains(hPoint.X, hPoint.Y) Then
          iMouse = Mouse.SizeAll
          $iChangeAction = CHANGE_MOVE
        Endif
      Endif
    Endif
    
    imvImage.Mouse = iMouse
    
  Else
    
    If $hCurrentPoint.InRect(RectF(0, 0, $hImage.W, $hImage.H)) Or If $bPress Then
      imvImage.Mouse = $iMouse
    Else
      imvImage.Mouse = Mouse.Default
    Endif
  
  Endif
  
End

Private Sub UpdateTool()

  Select Case $sTool
    
    Case "draw", "erase", "line"
      If $bShift <> $bFrame Then
        $bFrame = $bShift
        imvImage.Refresh
      Endif
    
  End Select

End

Public Sub Form_KeyPress()
  
  $bShift = Key.Shift
  $bCtrl = Key.Control
  $bAlt = Key.Alt
  UpdateTool
  imvImage_MouseMove
  
End

Public Sub Form_KeyRelease()
  
  $bShift = Key.Shift
  $bCtrl = Key.Control
  $bAlt = Key.Alt
  UpdateTool
  imvImage_MouseMove
  
End

Public Sub imvImage_MouseUp()

  If Not $bPress Then Return

  imvImage_MouseMove()

  Select Case $sTool
    
    Case "draw", "erase"
      $hSaveImage = Null
      $aStroke.Clear
      
    Case "line"
      If $hFirstPoint Then $hSelect.AddMagnet($hFirstPoint)
      $hSelect.AddMagnet($hLastPoint)

    Case "rectangle"
      If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
        $hSelect.AddMagnetFromRect($hLastPoint.X, $hLastPoint.Y, $hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
        imvImage.Refresh
      Else
        ClearSelection
      Endif
    
    Case "ellipse"
      If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
        $hSelect.AddMagnetFromRect($hLastPoint.X, $hLastPoint.Y, $hCurrentPoint.X - $hLastPoint.X, $hCurrentPoint.Y - $hLastPoint.Y)
        imvImage.Refresh
      Else
        ClearSelection
      Endif
      
    Case "change"
      If $hLastPoint.X <> $hCurrentPoint.X Or If $hLastPoint.Y <> $hCurrentPoint.Y Then
        RefreshSelection
      Else
        btnUndo_Click
      Endif
      
    Case "paste"
      $hPasteCurrent = $hPasteSelect.Copy()
      $hChangeRect = $hPasteCurrent.GetExtents()
      
  End Select
  
  $bPress = False
  UpdateInfo

End

Private Sub DrawTool()
  
  Dim I As Integer
  
  Select Case $sTool
  
    Case "draw", "erase"

      $hImage = $hSaveImage.Copy()
      Paint.Begin($hImage)

      FImageProperty.PaintForStroke
      'Paint.Brush.Scale(Paint.LineWidth, Paint.LineWidth)
      
      If $sTool = "erase" Then 
        Paint.Operator = Paint.OperatorDestOut
      Endif
      
      If $aStroke.Count = 2 Then
        If Not Paint.AntiAlias Then
          Paint.Rectangle($aStroke[0], $aStroke[1], 1, 1)
          Paint.Fill
        Else
          Paint.Arc($aStroke[0], $aStroke[1], Paint.LineWidth / 2)
          Paint.Fill
        Endif
      Else
        Paint.MoveTo($aStroke[0], $aStroke[1])
        For I = 2 To $aStroke.Max Step 2
          Paint.LineTo($aStroke[I], $aStroke[I + 1])
        Next
        Paint.Stroke
      Endif
      
      Paint.End
      Modify
      
    Case "line", "rectangle"
      
  End Select
  
  imvImage.Update($hImage)
  
End

Public Sub imvImage_Draw(hZoom As Image)
  
  Dim hStart As Point
  Dim hEnd As Point
  Dim hOffset As Point
  Dim bAnts As Boolean
  Dim bBalance As Boolean 
  Dim hImage As Image
  Dim hRect As Rect
    
  If Project.ActiveForm = Me And If FImageProperty.HasBalance() Then bBalance = True
  
  hOffset = imvImage.ImageToView(Point(0, 0))
    
  If bBalance And If Not $hSelect Then
    
    hImage = hZoom.Copy()
    FImageProperty.ApplyBalance(hImage)
    imvImage._Paint(hImage, hOffset.X, hOffset.Y)
    
  Endif
  
  ' If $hMagic Then 
  ' 
  '   Paint.Save
  '   
  '   Paint.Translate(hOffset.X, hOffset.Y)
  '   Paint.Scale(imvImage.Zoom, imvImage.Zoom)
  '   
  '   Paint.DrawImage($hMagic, 0, 0)
  '   
  '   Paint.Restore
  '   
  ' Endif
  
  If $hMagnet Or If $hSelect Then
  
    If $hSelect And If Not $hSelect.IsVoid() Then
      
      Paint.Save
    
      Paint.Translate(hOffset.X, hOffset.Y)
      Paint.Scale(imvImage.Zoom, imvImage.Zoom)
      
      If bBalance Then
        
        If $hSelect.IsInverted() Then
          hImage = hZoom.Copy()
        Else
          hRect = $hSelect.GetExtents()
          If hRect.X < 0 Then
            hRect.W += hRect.X
            hRect.X = 0
          Endif
          If hRect.Y < 0 Then
            hRect.H += hRect.Y
            hRect.Y = 0
          Endif
          hImage = hZoom.Copy(hRect.X, hRect.Y, hRect.Width, hRect.Height)
        Endif
        
        FImageProperty.ApplyBalance(hImage)
        
        If $hSelect.IsInverted() Then
          Paint.Save
          Paint.Reset
          imvImage._Paint(hImage, hOffset.X, hOffset.Y)
          Paint.Restore
        Endif
        
        Paint.Save
        $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
        Paint.Reset
        If $hSelect.IsInverted() Then
          imvImage._Paint(hZoom, hOffset.X, hOffset.Y)
        Else
          imvImage._Paint(hImage, hOffset.X + hRect.X * imvImage.Zoom, hOffset.Y + hRect.Y * imvImage.Zoom)
        Endif
        Paint.Restore
        
      Endif
      
      Paint.LineWidth = 2 / imvImage.Zoom
      Paint.AntiAlias = True
      Paint.LineJoin = Paint.LineJoinRound
      
      Paint.Background = Color.SetAlpha(Color.White, 128)
      Paint.Dash = Null
      $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE)
      
      Paint.Background = Color.SetAlpha(Color.Black, 128)
      Paint.Dash = [2.0, 2.0]
      Paint.DashOffset = - $fDashOffset
      $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE)
      
      Paint.Restore
      
      bAnts = True
      
    Endif
  
    If $hMagnet Then
      
      Paint.Save
      
      Paint.AntiAlias = False
      Paint.LineWidth = 1
      
      Paint.Translate($hMagnet.X * imvImage.Zoom + hOffset.X, $hMagnet.Y * imvImage.Zoom + hOffset.Y)
      
      Paint.Background = Color.White

      Paint.Rectangle(- 4, - 3, 9, 9)

      Paint.MoveTo(0, - imvImage.H)
      Paint.LineTo(0, imvImage.H)
      Paint.MoveTo(- imvImage.W, 0)
      Paint.LineTo(imvImage.W, 0)

      Paint.Stroke
  
      Paint.Background = Color.Black

      Paint.Rectangle(- 3, - 2, 7, 7)

      Paint.MoveTo(0, - imvImage.H)
      Paint.LineTo(0, imvImage.H)
      Paint.MoveTo(- imvImage.W, 0)
      Paint.LineTo(imvImage.W, 0)

      Paint.Dash = [2.0, 2.0]
      Paint.Stroke
      
      Paint.Restore
    
    Endif
    
  Endif
  
  If $bFrame And If Not $bPress Then 
  
    Select Case $sTool
      
      Case "draw", "erase", "line"
        
        If Not $hLastPoint Then Return
        If Not $hCurrentPoint Then Return
        
        hStart = imvImage.ImageToView($hLastPoint)
        hEnd = imvImage.ImageToView($hCurrentPoint)
        
        If $sTool = "line" Then
          Paint.LineWidth = 1
          'Paint.AntiAlias = False
          Paint.LineJoin = Paint.LineJoinRound
        Else
          FImageProperty.PaintForStroke
          Paint.LineWidth *= imvImage.Zoom
        Endif
        
        Paint.Background = Color.SetAlpha(Color.White, 128)
        Paint.Dash = Null
        If Not Paint.Antialias Then Paint.Translate(imvImage.Zoom / 2, imvImage.Zoom / 2)
        Paint.MoveTo(hStart.X, hStart.Y)
        Paint.LineTo(hEnd.X, hEnd.Y)
        Paint.Stroke
        Paint.Reset
        
        Paint.Background = Color.SetAlpha(Color.Black, 128)
        Paint.Dash = [2.0, 2.0]
        Paint.DashOffset = - $fDashOffset
        If Not Paint.Antialias Then Paint.Translate(imvImage.Zoom / 2, imvImage.Zoom / 2)
        Paint.MoveTo(hStart.X, hStart.Y)
        Paint.LineTo(hEnd.X, hEnd.Y)
        Paint.Stroke
        Paint.Reset
        
        bAnts = True
      
    End Select
    
  Endif
  
  If $hPaste Then
    
    Paint.Save
    
    'Paint.AntiAlias = False
    
    If $hSelect Then 
      Paint.Translate(hOffset.X, hOffset.Y)
      Paint.Scale(imvImage.Zoom, imvImage.Zoom)
      $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
      Paint.Reset
      'imvImage._Paint($hPaste, hOffset.X + $iPasteX * imvImage.Zoom, hOffset.Y + $iPasteY * imvImage.Zoom)
    Endif
    
    With $hPasteSelect.GetExtents()

      hImage = New Image($hImage.W, $hImage.H, Color.Transparent)
      
      Paint.Begin(hImage)
      Paint.Matrix = $hPasteSelect._Matrix
      Paint.Rectangle(($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2, $hPaste.W, $hPaste.H)
      Paint.Brush = Paint.Image($hPaste, ($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2)
      Paint.Fill
      Paint.End
      
      'imvImage._Paint(hImage, hOffset.X + .X * imvImage.Zoom, hOffset.Y + .Y * imvImage.Zoom)
      imvImage._Paint(hImage, hOffset.X, hOffset.Y)
      
    End With
    
    Paint.Restore
    
  Endif
  
  If $hChangeRect Then
    
    Paint.Save
    
    Paint.Translate(hOffset.X, hOffset.Y)
    Paint.Scale(imvImage.Zoom, imvImage.Zoom)
    
    Paint.LineWidth = 2 / imvImage.Zoom
    Paint.AntiAlias = True
    Paint.LineJoin = Paint.LineJoinRound
      
    Paint.Background = Color.SetAlpha(Color.Red, 128)
    If $sTool = "change" Then
      $hSelect.Paint($hImage, CImageSelection.ACTION_HANDLE)
    Endif
    
    Paint.Background = Color.SetAlpha(Color.Red, 128)
    Paint.Dash = Null
    
    With $hChangeRect
      
      Paint.Rectangle(.X, .Y, .W, .H)
      Paint.Stroke
      
      Paint.LineWidth = 1 / imvImage.Zoom
      Paint.MoveTo(.X + .W / 2, .Y + .H / 2)
      Paint.RelMoveTo(0, -4 / imvImage.Zoom)
      Paint.RelLineTo(0, 8 / imvImage.Zoom)
      Paint.RelMoveTo(-4 / imvImage.Zoom, -4 / imvImage.Zoom)
      Paint.RelLineTo(8 / imvImage.Zoom, 0)
      Paint.Stroke
      
    End With
    
    Paint.Background = Color.SetAlpha(Color.White, 128)
    Paint.Dash = [4.0, 4.0]
    Paint.DashOffset = 0
    Paint.Rectangle($hChangeRect.X, $hChangeRect.Y, $hChangeRect.W, $hChangeRect.H)
    Paint.Stroke
    
    Paint.Background = Color.SetAlpha(Color.Red, 128)
    Paint.Arc($hChangeRect.X + 0.5 / imvImage.Zoom, $hChangeRect.Y + 0.5 / imvImage.Zoom, 7 / imvImage.Zoom)
    Paint.Rectangle($hChangeRect.X + $hChangeRect.W + (0.5 - 6) / imvImage.Zoom, $hChangeRect.Y + $hChangeRect.H + (0.5 - 6) / imvImage.Zoom, 12 / imvImage.Zoom, 12 / imvImage.Zoom)
    Paint.Fill
    
    Paint.Restore
      
  Endif
  
  If $iAngle Then
    
    hImage = hZoom.Rotate(Rad($iAngle))
    imvImage._Paint(hImage, hOffset.X + (hZoom.W - hImage.W) / 2 * imvImage.Zoom, hOffset.Y + (hZoom.H - hImage.H) / 2 * imvImage.Zoom)
    'imvImage._Paint(hImage, hOffset.X, hOffset.Y)
    
  Endif
  
  timSelect.Enabled = bAnts
  
End

Public Sub timSelect_Timer()

  $fDashOffset += 0.5
  If $fDashOffset >= 4 Then $fDashOffset = 0
  imvImage.Refresh

End

Public Sub btnStroke_Click()

  Dim hImage As Image

  If $hSelect Then
    
    hImage = $hImage.Copy()
    Paint.Begin(hImage)
    FImageProperty.PaintForStroke($hSelect.GetExtents())
    $hSelect.Paint($hImage, CImageSelection.ACTION_STROKE)
    Paint.End
    ActionImage(hImage)
    
  Endif

End

Public Sub btnFill_Click()

  Dim hImage As Image

  hImage = $hImage.Copy()
  Paint.Begin(hImage)
  If $hSelect Then
    FImageProperty.PaintForFill($hSelect.GetExtents())
    $hSelect.Paint($hImage, CImageSelection.ACTION_FILL)
  Else
    Paint.Rectangle(0, 0, hImage.W, hImage.H)
    Paint.Fill
  Endif
  Paint.End
  ActionImage(hImage)

End

Public Sub btnInvert_Click()

  CreateSelection
  AddUndo($hSelect.Copy())
  $hSelect.Invert()
  If $hSelect.IsVoid() Then ClearSelection
  RefreshSelection

End

Public Sub timCheckZoom_Timer()

  btnZoomFit_Click

End

Public Sub imvImage_Menu()

  Me.SetFocus
  mnuEditor.Popup

End

Public Sub mnuSelectAll_Click()
  
  $hSelect = New CImageSelection
  btnInvert_Click

End

Public Sub btnClear_Click()

  Dim hImage As Image

  If $hSelect Then
    
    hImage = $hImage.Copy()
    Paint.Begin(hImage)
    FImageProperty.PaintForFill
    $hSelect.Paint($hImage, CImageSelection.ACTION_CLEAR)
    Paint.End
    ActionImage(hImage)
    
  Else
    
    hImage = New Image($hImage.W, $hImage.H, Color.Transparent) '$hImage.Copy()
    'hImage.Transparent(FImageProperty.GetColor(True))
    ActionImage(hImage)
    
  Endif

End

Public Sub btnCrop_Click()

  Dim hImage As Image
  Dim hRect As Rect
  
  If $hSelect Then
    
    $hSelect.Invert
    
    hImage = $hImage.Copy()
    
    Paint.Begin(hImage)
    Paint.Brush = Paint.Color(Color.Black)
    $hSelect.Paint(hImage, CImageSelection.ACTION_CLEAR)
    Paint.End

    $hSelect.Invert

    If Not $hSelect.IsInverted() Then
      hRect = $hSelect.GetExtents()  
      If hRect Then hImage = hImage.Copy(hRect.X, hRect.Y, hRect.Width, hRect.Height)
    Endif
    
    
    BeginUndo
    AddUndo($hSelect.Copy())
    ClearSelection
    ActionImage(hImage)
    EndUndo
    
  Endif

End

Private Sub BeginUndo()

  $aUndo.Add(BEGIN_UNDO)
  $aRedo.Clear

End

Private Sub EndUndo()
  
  Dim vUndo As Variant = $aUndo[$aUndo.Max]
  
  If TypeOf(vUndo) = gb.Integer And If vUndo = BEGIN_UNDO Then
    $aUndo.Pop()
  Else
    $aUndo.Add(END_UNDO)
  Endif
  
  $aRedo.Clear
  
End

' Fast Private Sub CheckPoint(iCol As Integer, X2 As Integer, Y2 As Integer, A0 As Integer) As Boolean
' 
'   Dim R, G, B, A As Float
'   Dim R2, G2, B2, A2 As Float
'   Dim N As Integer
'   Dim F As Float
'   Dim D As Integer
'   
'   'R = $R / $N
'   'G = $G / $N
'   'B = $B / $N
'   'A = $A / $N
'   
'   With Color[iCol]
'     R = .Red
'     G = .Green
'     B = .Blue
'     A = .Alpha
'   End With
'   
'   With Color[$hImage[X2, Y2]]
'     F = (255 - .Alpha) / 255
'     R2 = .Red * F
'     G2 = .Green * F
'     B2 = .Blue * F
'     A2 = .Alpha
'     N = 1
'   End With
'   
'   ' If X2 > 0 Then
'   '   With Color[$hImage[X2 - 1, Y2]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If X2 < ($hImage.W - 1) Then
'   '   With Color[$hImage[X2 + 1, Y2]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If Y2 > 0 Then
'   '   With Color[$hImage[X2, Y2 - 1]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' If Y2 < ($hImage.W - 1) Then
'   '   With Color[$hImage[X2, Y2 + 1]]
'   '     F = (255 - .Alpha) / 255
'   '     R2 += .Red * F
'   '     G2 += .Green * F
'   '     B2 += .Blue * F
'   '     A2 += .Alpha
'   '     Inc N
'   '   End With
'   ' Endif
'   ' 
'   ' R2 /= N
'   ' G2 /= N
'   ' B2 /= N
'   ' A2 /= N
'   
'   A0 = A0 * 1.1
'   D = Max(Max(Abs(R2 - R), Abs(G2 - G)), Max(Abs(B2 - B), Abs(A2 - A))) + A0
'   'Print X2;; Y2;; D
'   If D >= 255 Then Return
'   
'   '$R += R2
'   '$G += G2
'   '$B += B2
'   '$A += A2
'   Inc $N
' 
'   $hMagic[X2, Y2] = Color.SetAlpha(Color.Black, D)
'   '$hImage[X2, Y2] = Color.Blend($hImage[X2, Y2], $hMagic[X2, Y2])
'   If ($N And 1023) = 0 Then 
'     imvImage.Refresh
'     Wait
'   Endif
' 
'   Return True
' 
' End
' 
' Fast Private Sub MagicWand()
' 
'   Dim aPoint As New Integer[]
'   Dim X, Y, X2, Y2, A As Integer
'   Dim hImage As Image
'   
'   $iTol = 1 'FImageProperty.GetTolerance()
'   
'   $hMagic = New Image($hImage.W, $hImage.H, Color.White)
'   
'   aPoint.Add($hLastPoint.X)
'   aPoint.Add($hLastPoint.Y)
'   
'   With Color[$hImage[$hLastPoint.X, $hLastPoint.Y]]
'     $R = .Red * (255 - .Alpha) / 255
'     $G = .Green * (255 - .Alpha) / 255
'     $B = .Blue * (255 - .Alpha) / 255
'     $A = .Alpha
'     $N = 1
'   End With
'   
'   $hMagic[$hLastPoint.X, $hLastPoint.Y] = Color.Black
'   
'   While aPoint.Count
'     
'     X = aPoint[0]
'     Y = aPoint[1]
'     aPoint.Remove(0, 2)
'     
'     A = Color.GetAlpha($hMagic[X, Y])
'     
'     X2 = X + 1
'     Y2 = Y
'     GoSub LOOK_POINT
'     X2 = X + 1
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y + 1
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y
'     GoSub LOOK_POINT
'     X2 = X - 1
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     X2 = X
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     X2 = X + 1
'     Y2 = Y - 1
'     GoSub LOOK_POINT
'     
'   Wend
'   
'   hImage = $hImage.Copy()
'   $hMagic.Replace(Color.White, Color.Transparent)
'   '$hMagic = $hMagic.Fuzzy(1)
'   hImage.PaintImage($hMagic, 0, 0)
'   ActionImage(hImage)
'   $hMagic = Null
'   Return
'   
' LOOK_POINT:
' 
'   If X2 < 0 Or If Y2 < 0 Or If X2 >= $hImage.W Or If Y2 >= $hImage.H Then Return
'   If $hMagic[X2, Y2] <> Color.White Then Return
'   
'   If CheckPoint($hImage[X, Y], X2, Y2, A) Then
'     aPoint.Add(X2)
'     aPoint.Add(Y2)
'   Endif
'   
'   Return
'   
' End

Public Sub btnZoomFit_Click()

  Dim iIndex As Integer
  Dim fZoom As Float
  
  For iIndex = 0 To cmbZoom.Count - 1
    
    fZoom = CFloat(String.Left(cmbZoom[iIndex].Text, -1))
    If ($hImage.W * fZoom) > imvImage.W Or If ($hImage.H * fZoom) > imvImage.H Then Break
    
  Next
  
  cmbZoom.Index = Max(0, iIndex - 1)

End

Public Sub btnCopy_Click()

  Dim hImage As Image
  Dim hExt As Rect
  
  If $hSelect Then
    
    $hSelect.Invert
    
    hImage = $hImage.Copy()
    
    Paint.Begin(hImage)
    Paint.Brush = Paint.Color(Color.Black)
    $hSelect.Paint(hImage, CImageSelection.ACTION_CLEAR)
    Paint.End

    $hSelect.Invert

    If Not $hSelect.IsInverted() Then
      hExt = $hSelect.GetExtents()
      If hExt Then hImage = hImage.Copy(hExt.X, hExt.Y, hExt.Width, hExt.Height)
    Endif
    
    Inc $iClipboard
    FImageProperty.AddClipboard(hImage, Me.Name & " [" & CStr($iClipboard) & "]")
    
  Else
    
    FImageProperty.AddClipboard($hImage.Copy(), Me.Name)
    
  Endif

End

Public Sub btnCut_Click()

  Dim hImage As Image

  BeginUndo

  btnCopy_Click

  If $hSelect Then
    
    hImage = $hImage.Copy()
    Paint.Begin(hImage)
    $hSelect.Paint($hImage, CImageSelection.ACTION_CLEAR)
    Paint.End
    ActionImage(hImage)
    
  Else
    
    hImage = New Image($hImage.W, $hImage.H, Color.Transparent)
    ActionImage(hImage)
    
  Endif

  EndUndo

End

Private Sub DoPaste()

  Dim hImage As Image
  
  If Not $hPaste Then Return
  
  hImage = $hImage.Copy()
  Paint.Begin(hImage)

  ' If $hSelect Then 
  '   $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
  '   Paint.Brush = Paint.Image($hPaste, $hChangeRect.X, $hChangeRect.Y)
  '   Paint.Rectangle($hChangeRect.X, $hChangeRect.Y, $hChangeRect.W, $hChangeRect.H)
  '   Paint.Fill
  '   Paint.ResetClip
  ' Else
  '   Paint.DrawImage($hPaste, $hChangeRect.X, $hChangeRect.Y)
  ' Endif
  
    If $hSelect Then $hSelect.Paint($hImage, CImageSelection.ACTION_CLIP)
    
    With $hPasteSelect.GetExtents()

      Paint.Matrix = $hPasteSelect._Matrix
      Paint.Rectangle(($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2, $hPaste.W, $hPaste.H)
      Paint.Brush = Paint.Image($hPaste, ($hImage.W - $hPaste.W) \ 2, ($hImage.H - $hPaste.H) \ 2)
      Paint.Fill
      
    End With

  Paint.End
  
  ActionImage(hImage)
  
End

Public Sub Form_Activate()

  If Not $bFirstTime Then 
    btnZoomFit_Click
    $bFirstTime = True
  Endif

End

Public Sub RefreshSelection()
  
  imvImage.Refresh
  If $sTool = "change" Then SetTool($sTool)
  
End

Public Sub imvImage_Leave()

  FImageProperty.UpdateInfo("")

End

Public Sub ApplyBalance()
  
  Dim hImage As Image
  Dim hBalance As Image
  
  If $hSelect Then

    If $hSelect.IsInverted() Then
      
      hImage = $hImage.Copy()
      FImageProperty.ApplyBalance(hImage)
      
      Paint.Begin(hImage)
      $hSelect.Paint(hImage, CImageSelection.ACTION_CLIP)
      Paint.DrawImage($hImage, 0, 0)
      Paint.End
      
    Else
    
      hImage = $hImage.Copy()
      
      hBalance = $hImage.Copy()
      FImageProperty.ApplyBalance(hBalance)
    
      Paint.Begin(hImage)
      $hSelect.Paint(hImage, CImageSelection.ACTION_CLIP)
      Paint.DrawImage(hBalance, 0, 0)
      Paint.End

    Endif

    ActionImage(hImage)
    
  Else
    
    hImage = $hImage.Copy()
    FImageProperty.ApplyBalance(hImage)
    ActionImage(hImage)
    
  Endif
  
End

Public Sub OnProjectDebug()

  SetReadOnly

End

Private Sub UpdateMenu()

  Dim bVisible As Boolean

  bVisible = Not $bReadOnly

  If $bReadOnly Then SetTool("move")

  mnuAction.Visible = bVisible
  mnuZoom.Visible = bVisible
  
  Action[".save,.reload,.undo,.redo,.tool-*,.invert,.stroke,.fill,.clear,.cut,.copy,.crop,.flip-h,.flip-v,.rotate-*,.resize,.select-all,.hide-selection", Me].Visible = bVisible
  
End

Public Sub mnuHideSelection_Click()
  
  If $hSelect Then
    ClearSelection
  Else
    FMain.HidePanels
  Endif

End

Public Sub mnuPaste_Click()
  
  SetTool("paste")
  
End


Public Sub panToolBar_Configure()

  UpdateMenu

End

Public Sub btnResizeSelection_Click()

  If Not $hSelect Then Return
  If FImageResizeSelection.Run() Then Return
  
  AddUndo($hSelect.Copy())
  $hSelect.Enlarge(FImageResizeSelection.Size, FImageResizeSelection.Duplicate)
  RefreshSelection

End

Public Sub btnRotate_Click()

  If FImageRotate.Run(Me) Then 
    imvImage.Update($hImage)
    Return
  Endif
  ActionImage($hImage.Rotate(Rad(FImageRotate.Angle)))

End

Public Sub UpdateRotation(iAngle As Integer)
  
  '$iAngle = iAngle
  imvImage.Update($hImage.Rotate(Rad(iAngle)))
  
End

Public Sub Form_GotFocus()

  imvImage.SetFocus

End

Public Sub imvImage_GotFocus()

  Project.SetCurrentPopup(mnuEditor)

End

Public Sub mnuClose_Click()
  
  Me.Close
  
End
