' Gambas class file

  ' 0 = MHelp.TYPE_NATIVE
Static Private $aNativeDatatypes As String[] = ["Boolean 0", "Byte 0", "Short 0", "Integer 0", "Long 0", "Single 0", "Float 0", "Date 0", "String 0", "Object 0", "Variant 0", "Pointer 0"]

Private $iCol As Integer
Private $sText As String
Private $bLoaded As Boolean
Private $sMode As String
Private $iLen As Integer
Private $bUserChoice As Boolean
Private $iMaxLen As Integer
Private $sClass As String
Private $bShowHelp As Boolean
Private $sLastUrl As String

Private $DX As Integer
Private $DY As Integer
Private $iMinW As Integer
Private $iMinH As Integer
Private $iMaxY As Integer

Private $hEditor As Editor

Public Sub RefreshLibrary()

  $bLoaded = False

End

Private Function GetClass() As String
  
  Dim hForm As FEditor

  hForm = $hEditor.Window
  Return hForm.Name
  
End

Public Sub Open(hForm As FEditor, sMode As String, Optional sClass As String, Optional bStatic As Boolean, Optional bPrivate As Boolean)

  Dim iX As Integer
  Dim iY As Integer
  Dim iPos As Integer
  Dim hCont As Container
  Dim sText As String
  Dim W, H As Integer

  If hForm.Editor <> $hEditor Then HideFrom($hEditor)

  $hEditor = hForm.Editor
  Me.Font = $hEditor.font

  Inc Application.Busy

  $bUserChoice = False
  $sMode = sMode
  $iLen = 0
  $iMaxLen = 16
  $iCol = $hEditor.Column + 1
  $sClass = ""
  
  Select $sMode
    Case "."
      $sText = ""
      If Len(sClass) = 1 Then 
        Dec Application.Busy
        Return
      Endif 
      $sClass = sClass
      FillWithSymbol(sClass, bStatic, bPrivate)
    Case " "
      $sText = ""
      FillWithClasses
    Case "A"
      $sText = sClass
      $iLen = Len(sClass)
      $iCol -= Len(sClass)
      FillWithIdent(sClass)
    Case "_"
      $sText = "_"
      $iLen = 1
      Dec $iCol
      FillWithSpecial()
    Case "<"
      $sText = sClass
      iPos = InStr(sClass, "_")
      If iPos Then 
        $iLen = iPos
      Else
        $iLen = 3
      Endif
      $iCol -= Len(sClass) + 2
      FillWithIdent(Left$(sClass, $iLen))
  End Select

  If lvwComp.Count = 0 Then
    Dec Application.Busy
    Return
  Endif
  
  $bShowHelp = Settings["/ShowHelpInPopup", 1] 
  
  'PRINT "Open: $hEditor = "; $hEditor

  lvwComp.MoveFirst
  H = lvwComp.Item.H
  
  If sMode = "<" Or sMode = "A" Then 
    If FindItem(True) Then 
      Dec Application.Busy
      Return
    Endif 
  Else 
    lvwComp.MoveFirst
    lvwComp.Item.Selected = True
    lvwComp.Item.EnsureVisible
  Endif 

  W = $iMaxLen * Me.Font.Width("A") + 16 + 16 + 12
  
  If $bShowHelp Then
    sepHelp.Show
    webHelp.Show
    panRight.Show
    $iMinW = W + 4 + 128
    $iMinH = Desktop.Scale * 24
    lvwComp.Expand = False
    lvwComp.W = W
    Me.Resize(Max($iMinW, Me.W), Max(Me.H, Max($iMinH, H * Min(8, lvwComp.Count) + 2)))
  Else
    sepHelp.Hide
    webHelp.Hide
    panRight.Hide
    lvwComp.Expand = True
    Me.Resize(W + 4, H * Min(8, lvwComp.Count) + 2)
  Endif

  sText = String.Left($hEditor.Lines[$hEditor.Line].Text, $iCol)
  
  If InStr(" .", sMode) And If Key.Code <> Key.Backspace Then 
    sText &= Key.Text
  Endif

  iX = $hEditor.X + $hEditor.ToPosX(0) + $hEditor.Font.Width(sText)

  iX = Max(0, Min(iX, $hEditor.Window.ClientW - Me.Width))

  iY = $hEditor.Y + $hEditor.CursorY + $hEditor.LineHeight

  If (iY + Me.Height) > ($hEditor.Y + $hEditor.H) Then
    iY = $hEditor.Y + $hEditor.CursorY - Me.Height
    If iY < 0 Then
      Me.Height += iY
      iY = 0
    Endif
    panResizeBottom.Hide
    panResizeTop.Show
  Else
    panResizeBottom.Show
    panResizeTop.Hide
  Endif

  hCont = $hEditor.Parent
  Do
    If hCont Is Form Then Break
    iX += hCont.X
    iY += hCont.Y
    hCont = hCont.Parent
  Loop
  
  Dec Application.Busy

  If Me.Parent = hForm And If iX = Me.X And iY = Me.Y And Me.Visible Then Return
  
  Me.Reparent(hForm, iX, iY)
  Me.Show
  Me.Raise
  $hEditor.SetFocus

End


Public Sub SetText(sText As String)
  
  $sText = sText
  FindItem(True)
  
End


Private Sub AddClassesAndFill(aClass As String[], Optional sBegin As String)
  
  Dim sClass As String
  Dim sLib As String
  Dim iType As Integer
  Dim hPic As New Picture[7]
  Dim aLib As String[]

  CComponent.All["gb"].Load

  For Each sClass In Project.GetClasses()
    If sClass Like sBegin & "*" Then aClass.Add(sClass & " " & MHelp.TYPE_CLASS)
    'TRY lvwComp.Add(sClass, sClass)
  Next

  aLib = Project.Components.Copy()
  aLib.Add("gb", 0)

  For Each sLib In aLib
    If Not CComponent.All.Exist(sLib) Then Continue
    CComponent.All[sLib].Load
    For Each sClass In CComponent.All[sLib].ClassList
      If IsLetter(Left$(sClass)) Then
        If sClass Like sBegin & "*" Then 
          If CComponent.Classes[sClass].Properties Then
            aClass.Add(sClass & " " & MHelp.TYPE_CONTROL)
          Else
            aClass.Add(sClass & " " & MHelp.TYPE_CLASS)
          Endif
        Endif 
      Endif
    Next
  Next

  aClass.Sort(gb.IgnoreCase + gb.Natural)

  hPic[0] = Picture["img/16/gambas.png"]
  hPic[1] = Picture["img/16/class.png"]
  hPic[2] = Picture["img/16/control.png"]
  hPic[3] = Picture["img/16/point.png"]
  hPic[4] = Picture["img/16/event.png"]
  hPic[5] = hPic[0]
  hPic[6] = Picture["img/16/key.png"]
  
  lvwComp.Clear

  For Each sClass In aClass
    iType = Val(Right$(sClass))
    sClass = Left$(sClass, -2)
    Try lvwComp.Add(CStr(iType) & sClass, sClass, hPic[iType])
    $iMaxLen = Max($iMaxLen, Len(sClass))
  Next
  
End

Private Sub FillWithClasses()

  AddClassesAndFill($aNativeDatatypes.Copy())

End

Private Sub FillWithSymbol(sClass As String, bStatic As Boolean, bPrivate As Boolean)

  Dim cSymbol As Collection
  Dim hSymbol As CSymbolInfo
  Dim aSymbol As New String[]
  Dim sSymbol As String
  Dim sName As String
  Dim hClass As CClassInfo

  lvwComp.Clear

  cSymbol = CComponent.GetClassSymbols(sClass)
  If Not cSymbol Then Return

  If CComponent.IsAutoCreatable(sClass) Then bStatic = False

  For Each hSymbol In cSymbol
    If hSymbol.NotPublic <> bPrivate Then Continue
    If Left(hSymbol.Name) = "_" Then Continue
    If hSymbol.Kind = "m" And If InStr(hSymbol.Name, "_") Then Continue
    If hSymbol.Kind = ":" Then Continue
    If bStatic Then
      If UCase(hSymbol.Kind) <> hSymbol.Kind Then
        Continue
      Endif
    Endif
    aSymbol.Add(hSymbol.Name)
  Next

  aSymbol.Sort(gb.IgnoreCase + gb.Natural)

  For Each sSymbol In aSymbol
    hSymbol = cSymbol[sSymbol]
    Try lvwComp.Add(CStr(MHelp.TYPE_SYMBOL) & sSymbol, sSymbol, Picture[hSymbol.GetIcon()])
    $iMaxLen = Max($iMaxLen, Len(sSymbol))
  Next

End


Private Sub GetEvents(sCtrl As String) As String[]
  
  Dim sName As String
  Dim hForm As FForm
  Dim aEvent As String[]
  
  hForm = Project.FindForm(GetClass())
  If Not hForm Then Return  

  If LCase(sCtrl) = LCase(hForm.Family) Then 
    Try aEvent = CComponent.Classes[hForm.Family].Events
  Else
    Try aEvent = CComponent.Classes[hForm.Control[sCtrl].Kind].Events
  Endif
  
  Return aEvent
  
End


Private Sub AddEvents(aResult As String[], sCtrl As String)

  Dim sName As String
  Dim aEvent As String[]

  aEvent = GetEvents(sCtrl)
  If Not aEvent Then Return
  
  For Each sName In aEvent
    If aResult.Exist(sCtrl & "_" & sName & " " & CStr(MHelp.TYPE_SYMBOL), gb.IgnoreCase) Then Continue
    aResult.Add(sCtrl & "_" & sName & " " & CStr(MHelp.TYPE_EVENT))
  Next
  
End

Private Sub FillWithIdent(sWord As String)

  Dim iInd As Integer
  Dim sLine As String
  Dim iPos As Integer
  Dim iUPos As Integer
  Dim iPos2 As Integer
  Dim iPos3 As Integer
  Dim sCar As String
  Dim aResult As New String[]
  Dim cKey As New Collection
  Dim hSymbol As CSymbolInfo
  Dim cSymbol As Collection
  Dim sOrg As String
  Dim sText As String
  Dim iLine As Integer
  Dim sUCaseLine As String

  lvwComp.Clear

  sOrg = sWord
  sWord = UCase(sWord)
  
  For Each sCar In ["True", "False", "Null", "Last", "Me", "Super"]
    If sCar Like sWord & "*" Then 
      cKey[sCar] = True
      aResult.Add(sCar & " " & MHelp.TYPE_KEYWORD)
    Endif
  Next
  
  For Each sCar In $aNativeDatatypes
    If sCar Like sWord & "*" Then 
      cKey[Left(sCar, -2)] = True
      aResult.Add(sCar)
    Endif
  Next

  For Each sCar In System.Keywords
    If sCar Like sWord & "*" Then 
      If cKey.Exist(sCar) Then Continue
      cKey[sCar] = True
      If sCar = UCase(sCar) Then sCar &= " "
      aResult.Add(sCar & " " & MHelp.TYPE_KEYWORD)
    Endif
  Next

  If Left(sWord) = "_" Then 
    For Each sCar In ["_call", "_compare", "_get", "_init", "_new", "_next", "_put", "_unknown"]
      If sCar Like sWord & "*" Then 
        cKey[sCar] = True
        aResult.Add(sCar & " " & MHelp.TYPE_SPECIAL)
      Endif
      'Try lvwComp.Add(CStr(MHelp.TYPE_SPECIAL) & sName, sName, hPict)
    Next
  Endif
  'sText = hEditor.Text
  'IF InStr(sText, sWord, 1, gb.Text) THEN
  
  iLine = -1
  Do
  
    iLine = $hEditor.FindNextWord(sWord, iLine + 1)
    If iLine < 0 Then Break 
    If iLine = $hEditor.Line Then Continue

    sLine = Highlight.Purge($hEditor.Lines[iLine].Text)
    sUCaseLine = UCase(sLine) ' Only ASCII characters are interesting there...
  
    iPos = 0
    Do
      Inc iPos
      iPos = String.InStr(sUCaseLine, sWord, iPos)
      If iPos = 0 Then Break
      If iPos > 1 Then
        sCar = String.Mid$(sLine, iPos - 1, 1)
        If InStr(FEditor.IDENT_CAR, sCar) Then Break
      Endif
      For iPos2 = iPos + String.Len(sWord) To String.Len(sLine)
        sCar = String.Mid$(sLine, iPos2, 1)
        If String.InStr(FEditor.IDENT_CAR, sCar) = 0 Then Break
      Next
      sCar = String.Mid$(sLine, iPos, iPos2 - iPos)
      If IsDigit(Left$(sCar)) Then Continue 
      If cKey.Exist(sCar) Then Continue
      aResult.Add(sCar & " " & MHelp.TYPE_SYMBOL)
      cKey[sCar] = True
    Loop
  
  Loop 

  cSymbol = CComponent.GetClassSymbols(GetClass())
  If cSymbol Then
    For Each hSymbol In cSymbol
      If Not hSymbol.NotPublic Then Continue
      sCar = hSymbol.Name
      If Not (sCar Like sWord & "*") Then Continue
      If cKey.Exist(sCar) Then Continue
      aResult.Add(sCar & " " & MHelp.TYPE_SYMBOL)
      cKey[sCar] = True
    Next
  Endif
  
  If Right(sWord) = "_" Then
    AddEvents(aResult, Left(sOrg, -1))
  Endif

  AddClassesAndFill(aResult, sWord)

End

Private Sub FillWithSpecial()

  Dim sName As String
  Dim hPict As Picture = Picture["img/16/point.png"]
  
  lvwComp.Clear
  
  For Each sName In ["_call", "_compare", "_get", "_init", "_new", "_next", "_put", "_unknown"]
    Try lvwComp.Add(CStr(MHelp.TYPE_SPECIAL) & sName, sName, hPict)
  Next
  
End


' PUBLIC SUB Form_Resize()
'
'   'PRINT "Form_Resize: ME.H = "; ME.H; " Me.ClientH =";ME.ClientH
'   panComp.Move(0, 0, ME.ClientW, ME.ClientH)
'   lvwComp.Move(1, 1, panComp.W - 2, panComp.H - 2)
'
' END

Public Function ManageKey() As Boolean

  Dim iInd As Integer

  Select Case Key.Code

    Case Key.Up, Key.PageUp

      lvwComp.MoveCurrent
      If lvwComp.Item.Selected Then

        For iInd = 1 To If(Key.Code = Key.Up, 1, 8)
          If lvwComp.MoveAbove() Then Break
        Next

      Endif

      If Not lvwComp.Available Then lvwComp.MoveFirst
      If lvwComp.Available Then
        lvwComp.Item.Selected = True
        lvwComp.Item.EnsureVisible
        $bUserChoice = True
      Endif

    Case Key.Down, Key.PageDown

      lvwComp.MoveCurrent
      If lvwComp.Item.Selected Then

        For iInd = 1 To If(Key.Code = Key.Down, 1, 8)
          If lvwComp.MoveBelow() Then Break
        Next

      Endif

      If Not lvwComp.Available Then lvwComp.MoveLast
      If lvwComp.Available Then
        lvwComp.Item.Selected = True
        lvwComp.Item.EnsureVisible
        $bUserChoice = True
      Endif

    Case Key.Home

      lvwComp.MoveCurrent
      If lvwComp.MovePrevious() Then
        Me.Hide
        Return
      Endif

      lvwComp.MoveFirst
      If lvwComp.Available Then
        lvwComp.Item.Selected = True
        lvwComp.Item.EnsureVisible
        $bUserChoice = True
      Endif

    Case Key.End

      lvwComp.MoveCurrent
      If lvwComp.MoveNext() Then
        Me.Hide
        Return
      Endif

      lvwComp.MoveLast
      If lvwComp.Available Then
        lvwComp.Item.Selected = True
        lvwComp.Item.EnsureVisible
        $bUserChoice = True
      Endif

    Case Key.Esc
      Me.Hide

    Case Key.Left, Key.Right
      Me.Hide
      Return

    Case Key.Enter, Key.Return
      InsertItem
      'IF Key.Code <> Key.Tab THEN RETURN

    Case Key.Space
      If Key.Control Then
        If UCase($sText) = "NEW" Then Return
        InsertItem(True)
      Else
        Me.Hide
      Endif
      Return False 

    Case Key.Backspace
      If Len($sText) > $iLen Then
        $sText = Left$($sText, -1)
        FindItem
      Else
        Me.Hide
      Endif
      Return False
      
    Case Key.Tab

      If $bUserChoice Then 
        InsertItem
      Else
        Return CompleteItem()
      Endif 

    Case Else
      If Key.Text Then
        If InStr(FEditor.IDENT_CAR, Key.Text) Then
          If Key.Text = "_" Then 
            If GetEvents($sText) Then 
              Me.Hide
              Return 
            Endif
          Endif
          $sText = $sText & Key.Text
          Return FindItem()
        Else If InStr("([.!", Key.Text) > 0 And InStr(". A<", $sMode) > 0 Then
          InsertItem
        Else
          Me.Hide
        Endif
        Return False
      Endif

  End Select

  Return True

End

Private Function FindItem(Optional bNoInsert As Boolean) As Boolean

  Dim sComp As String
  Dim iLevel As Integer
  Dim sKey As String
  Dim nComp As Integer
  Dim sText As String

  'sComp = Replace($sText, "[", "[[]") & "*"
  sComp = UCase($sText)

  lvwComp.MoveFirst
  While lvwComp.Available
    If UCase(lvwComp.Item.Text) Begins sComp Then Break
    lvwComp.MoveNext
  Wend
  
  If Not lvwComp.Available Then
    Me.Hide
    Return 
  Endif 
  
  sKey = lvwComp.Item.Key

  While lvwComp.Available
    With lvwComp.Item
      sText = Trim(.Text)
      If Not (UCase(sText) Begins sComp) Then Break
      If iLevel <= 2 And If .Text = $sText Then
        sKey = .Key
        iLevel = 3
      Else If iLevel <= 1 And If UCase(sText) = UCase($sText) Then
        sKey = .Key
        iLevel = 2
      Else If iLevel <= 0 And If Left(sText, Len($sText)) = $sText Then 
        sKey = .Key
        iLevel = 1
      Endif
    End With
    Inc nComp
    lvwComp.MoveNext
  Wend

  lvwComp.MoveTo(sKey)
  lvwComp.Item.Selected = True
  lvwComp.Item.EnsureVisible
  
  If nComp = 1 And iLevel = 3 Then
    If Not bNoInsert Then InsertItem(True)
    Return True
  Endif
  
End

Private Function InsertItem(Optional bNoSpace As Boolean) As Boolean

  Dim sText As String

  Try sText = lvwComp.Current.Text
  If Not lvwComp.Current.Selected Then Return
  If Not sText Then Return True

  If bNoSpace Then
    If Right(sText) = " " Then sText = Left$(sText, -1)
  Endif

  With $hEditor
    .Select(.Line, $iCol, .Line, .Column)
    .Insert(sText)
  End With

  Me.Hide

End

Public Sub lvwComp_Click()

  InsertItem

End

Public Sub lvwComp_KeyPress()

  Dim hForm As FEditor

  'IF Key.Code = Key.Escape THEN ME.Hide

  $hEditor.SetFocus
  hForm = $hEditor.Window
  hForm.Editors_KeyPress

End

Private Sub CompleteItem() As Boolean
  
  Dim sCurrent As String
  Dim sNext As String
  Dim sText As String
  Dim iPos As Integer
  
  sCurrent = lvwComp.Current.Text
  lvwComp.MoveCurrent
  lvwComp.MoveNext
  Try sNext = lvwComp.Item.Text
  
  For iPos = Len($sText) + 1 To Min(Len(sCurrent), Len(sNext))
    If Comp(Mid$(sCurrent, iPos, 1), Mid$(sNext, iPos, 1), gb.IgnoreCase) Then Break
  Next

  sText = Left$(sCurrent, iPos - 1)    
  If Comp(sText, $sText, gb.IgnoreCase) = 0 Or Not sText Then 
    InsertItem
  Else  
    $sText = sText

    With $hEditor
      .Select(.Line, $iCol, .Line, .Column)
      .Insert($sText)
    End With

    FindItem
  Endif
  
  Return True
  
End

Public Sub timHelp_Timer()
  
  Dim sSymbol As String
  Dim iType As Integer
  Dim sClass As String
  
  If Not $hEditor Then Return
  
  Try sSymbol = lvwComp.Current.Text
  If sSymbol Then   
    iType = CInt(Left(lvwComp.Key))
    sClass = $sClass
    If Not sClass Then 
      sClass = GetClass()
    Endif
    MHelp.InitWebViewWith(webHelp, iType, sSymbol, sClass, "noimage", $hEditor.Window)
  Endif

  timHelp.Stop
  
End

Public Sub lvwComp_Select()

  If Not $bShowHelp Then Return
  timHelp.Stop
  timHelp.Start
  
End

Public Sub webHelp_GotFocus()

  lvwComp.SetFocus

End

Public Sub panResizeBottom_MouseDown()

  $DX = Me.W - Mouse.ScreenX
  $DY = Me.H - Mouse.ScreenY

End

Public Sub panResizeBottom_MouseMove()

  Dim W, H As Integer
  
  W = Max($iMinW, $DX + Mouse.ScreenX)
  H = Max($iMinH, $DY + Mouse.ScreenY)
  
  Me.Resize(W, H)

End

Public Sub panResizeTop_MouseDown()

  $DX = Me.W - Mouse.ScreenX
  $DY = Me.Y - Mouse.ScreenY
  $iMaxY = Me.Y + Me.H - $iMinH

End

Public Sub panResizeTop_MouseMove()

  Dim W, Y As Integer
  
  W = Max($iMinW, $DX + Mouse.ScreenX)
  Y = Min($iMaxY, $DY + Mouse.ScreenY)
  
  Me.Move(Me.X, Y, W, Me.H + Me.Y - Y)

End

Public Sub Form_Close()

  $hEditor = Null

End

Public Sub HideFrom(hEditor As Editor)
  
  If $hEditor <> hEditor Then Return
  $hEditor = Null
  Me.Hide
  
End

Public Sub VisibleFrom(hEditor As Editor) As Boolean
  
  Return Me.Visible And $hEditor = hEditor
  
End


Public Sub webHelp_Link(Url As String)

  $sLastUrl = Url

End

Public Sub webHelp_Error()

  If $sLastUrl Begins "gambas://" Then 
    webHelp.Stop
    MHelp.ManageSpecialLink(webHelp, $sLastUrl)
  Endif

End
