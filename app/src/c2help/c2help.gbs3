#!/usr/bin/gbs3

' (C) 2014 Tobias Boege <tobias@gambas-buch.de>, GPLv2+

Use "gb.pcre"

Public Sub Main()
  Dim sArg, sRec As String
  Dim aRec As String[]

  If Args.Count < 1 Then Usage()
  For Each sArg In Args.All.Extract(1, -1)
    sArg = Application.Dir &/ sArg
    If IsDir(sArg) Then
      aRec = RDir(sArg, "*.{c,cpp}")
      For Each sRec In aRec
        OneFile(sArg &/ sRec)
      Next
    Else
      OneFile(sArg)
    Endif
  Next
End

Private Sub OneFile(sPath As String)
  Dim hFile As File

  Error "Processing";; sPath; "..."
  hFile = Open sPath For Input
  MakeHelp(Translate(Extract(hFile), sPath), File.Out)
  Close #hFile
End

Private Sub Usage()
  Print
  Print "Usage:";; Args[0];; "SOURCES..."
  Print
  Print "Extract Gambas help comments from all SOURCES and output a .help file."
  Print "If SOURCES contains directories, they are searched recursively for .c"
  Print "and .cpp files."
  Print
  Quit
End

Private Function Extract(hFile As File) As String[]
  Dim hNameFn As New RegExp, hNameInline As New RegExp
  Dim sLine As String, sInline As String
  Dim aRes As New String[]
  Dim bRecord As Boolean

  hNameFn.Compile("^BEGIN_.*\\(([^,)]+).*")
  hNameInline.Compile("/\\*\\*G (.+)$")

  For Each sLine In hFile.Lines
    If sLine Match "^[\\t ]*\\*?\\*/$" Then
      If sInline Then
        aRes.Add("G " & sInline)
        sInline = ""
        bRecord = False
      Endif
      Continue
    Endif
    hNameFn.Exec(sLine)
    If hNameFn.Offset <> -1 And If bRecord And If Not sInline Then
      aRes.Add(hNameFn[1].Text)
      bRecord = False
    Endif

    ' XXX: I'd like to
    '
    '  RegExp.Replace(sLine, "^[\\t ]*\\*", "'")
    '
    ' but gb.pcre returns for " * *" -> "''" which I can't use.
    If bRecord Then
      If sLine Match "^[\\t ]*\\*" Then
        sLine = "'" & Right$(Trim$(sLine), -1)
      Endif
      aRes.Add(sLine)
    Endif

    If sLine Match "^/\\*\\*G$" Then
      If bRecord Then aRes.Add("ERROR")
      sInline = ""
      bRecord = True
    Endif
    hNameInline.Exec(sLine)
    If hNameInline.Offset <> -1 Then
      If bRecord Then aRes.Add("ERROR")
      sInline = LTrim$(hNameInline[1].Text)
      bRecord = True
    Endif
  Next
  If bRecord Then aRes.Add("ERROR")
  Return aRes
End

Private Function Translate(aSource As String[], sPath As String) As String[]
  Dim sLine As String, aRes As New String[]

  For Each sLine In aSource
    If Not sLine Then Continue
    If sLine = "ERROR" Or If sLine Begins "'" Then
      aRes.Add(sLine)
      Continue
    Endif
    If sLine Begins "G " Then ' Syntax-2?
      aRes.Add(Right$(sLine, -2))
      Continue
    Endif
    ' Syntax-1
    aRes.Add(GetSyntax1(sLine, sPath))
  Next
  Return aRes
End

Private Function GetSyntax1(sFunc As String, sPath As String) As String
  Dim hClassName As New RegExp, hFunction As New RegExp
  Dim hFile As File, sLine, sClass As String
  Dim aRes As New String[]

  hClassName.Compile("GB_DECLARE\\(\\\"([^\\\"]+).*")
  hFunction.Compile("GB_[^(]+\\(\\\"([^\"]+)\\\".*" & sFunc & "\\W")

  hFile = Open sPath For Input
  sClass = "ERROR"
  For Each sLine In hFile.Lines
    If Not sLine Then Continue
    hClassName.Exec(sLine)
    If hClassName.Offset <> -1 Then sClass = hClassName[1].Text
    hFunction.Exec(sLine)
    If hFunction.Offset <> -1 Then
      If Not aRes.Count Then aRes.Add(sClass)
      aRes.Add(hFunction[1].Text)
    Endif
  Next
  Close #hFile
  Return aRes.Join(" ")
End

Public Sub MakeHelp(aSource As String[], hOut As File)
  Dim sLine, sCls, sSym As String
  Dim cHelp As New Collection, aCurrent As New String[]
  Dim cClass As Collection, aHelp, aSyn As String[]
  Dim iInd As Integer

  Output To hOut
  For Each sLine In aSource
    If Not sLine Then Continue
    If sLine Begins "'" Then
      aCurrent.Add(sLine)
    Else
      With Scan(sLine, "* *")
        If .Count = 0 Then ' <Class>
          sCls = sLine
          sSym = "#"
        Else If .Count = 2 Then ' <Class> <Symbol-and-Synonym-List>
          sCls = Trim$(.[0])
          sSym = Trim$(.[1])
        Endif
        If Not cHelp[sCls] Then cHelp[sCls] = New Collection
        cHelp[sCls][sSym] = aCurrent
        aCurrent = New String[]
      End With
    Endif
  Next

  For Each cClass In cHelp
    Print "#"; cHelp.Key
    aHelp = cClass["#"]
    If aHelp Then Print aHelp.Join("\n")
    For Each aHelp In cClass
      If cClass.Key = "#" Then Continue
      aSyn = Split(cClass.Key, " ")
      Print aSyn[0]
      If aHelp.Count Then Print aHelp.Join("\n")
      For iInd = 1 To aSyn.Max
        Print aSyn[iInd]
        Print "' A synonym for";; aSyn[0]; "."
      Next
    Next
  Next
  Output To Default
End
