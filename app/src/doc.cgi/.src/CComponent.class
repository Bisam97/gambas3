' Gambas class file

Static Public All As New Collection
Static Public Classes As Collection

Public Name As String
Public Key As String
Public Description As String
Public Authors As String[]
Public Controls As New String[]
Public Containers As New String[]
Public MultiContainers As New String[]
Public Virtuals As New String[]
Public Loaded As Boolean
Public ClassList As New String[]
Public Alpha As Boolean
Public SortKey As Integer
Public Groups As New Collection
Public Type As String

Public Require As New String[]
Public Exclude As New String[]
Public Implement As New String[]
Public Need As New String[]

Public DoNotWrite As New Collection
Public AlwaysRead As New Collection
Public Translate As New Collection

Private $sShortLang As String
Private $cClass As New Collection(gb.Text)
Private $aInit As String[]
Private $bLoaded As Boolean

Static Private $cImplement As New Collection
Static Private $cRescue As New Collection

Static Public Sub Init()
  
  Dim sComp As String
  Dim aComp As String[]
  Dim iPos As Integer

  Classes = New Collection(gb.Text)
  
  $cImplement.Clear
  
  $cRescue["Form"] = "gb.qt"
  $cRescue["ImageProvider"] = "gb.qt"
  $cRescue["OpenGLViewer"] = "gb.qt.opengl"
  $cRescue["ImageIO"] = "gb.image.io"
  $cRescue["EventLoop"] = "gb.qt"
  
  ' sPath = Main.InfoFilePath
  ' IF NOT sPath THEN sPath = System.Path &/ "share/gambas" & System.Version & "/info"

  aComp = Dir(Main.InfoFilePath, "*.component")
  For iPos = 0 To aComp.Max
    aComp[iPos] = File.BaseName(aComp[iPos])
  Next
  aComp.Sort

  For Each sComp In aComp
    All[sComp] = New CComponent(sComp)
  Next
  
End

Static Public Sub Exit()

  All = Null
  Classes = Null

End


' STATIC PRIVATE SUB SortComponents()
' 
'   DIM iMax AS Integer
'   DIM hComponent AS CComponent
'   DIM cNewAll AS NEW Collection
'   DIM iInd AS Integer
' 
'   FOR EACH hComponent IN All
'     hComponent.CalcSortKey
'     iMax = Max(iMax, hComponent.SortKey)
'     'PRINT hComponent.Key;; hComponent.SortKey
'   NEXT
' 
'   FOR iInd = 1 TO iMax
'     FOR EACH hComponent IN All
'       IF hComponent.SortKey = iInd THEN
'         cNewAll.Add(hComponent, hComponent.Key)
'       ENDIF
'     NEXT
'   NEXT
' 
'   All = cNewAll
' 
' END
' 

' PUBLIC SUB CalcSortKey()
' 
'   DIM sComp AS String
'   DIM hComp AS CComponent
'   DIM iKey AS Integer
' 
'   IF SortKey THEN RETURN
' 
'   IF Require.Count = 0 THEN
'     INC $iKey
'     SortKey = $iKey
'     RETURN
'   ENDIF
' 
'   FOR EACH sComp IN Require
'     hComp = All[sComp]
'     hComp.CalcSortKey
'     iKey = iKey + hComp.SortKey
'   NEXT
' 
'   SortKey = iKey + 1
' 
' END

Private Sub CalcShortLang()

  Dim sLang As String
  Dim iPos As Integer

  sLang = System.Language
  iPos = InStr(sLang, "_")
  If iPos Then
    $sShortLang = Left$(sLang, iPos - 1)
  Else
    $sShortLang = sLang
  Endif

End

Private Sub InsertList(cCol As Collection, sList As String)

  Dim sElt As String

  For Each sElt In Split(sList)
    If Left(sElt) = "!" Then
      cCol[Mid$(sElt, 2)] = False
    Else
      cCol[sElt] = True
    Endif
  Next

End


Public Sub _new(sName As String)

  Dim sPath As String
  Dim hFile As File
  Dim sLine As String
  Dim iPos As Integer
  Dim sKey As String
  Dim sLang As String
  Dim sGroup As String
  Dim aCtrl As String[]
  Dim sElt As String
  Dim sType As String

  sPath = Main.InfoFilePath &/ sName & ".component"
  hFile = Open sPath For Input

  Line Input #hFile, sLine
  If sLine <> "[Component]" Then Error.Raise("Not a component file: " & sPath)

  CalcShortLang

  'WHILE NOT Eof(hFile)
  '  LINE INPUT #hFile, sLine
  '  IF sLine = "[Component]" THEN BREAK
  'WEND

  If Eof(hFile) Then Seek #hFile, 0

  While Not Eof(hFile)

    Line Input #hFile, sLine
    sLine = Trim(sLine)
    If Not sLine Then Continue
    If Left(sLine) = ";" Or Left(sLine) = "'" Then Continue

    If Left(sLine) = "[" Then
      sGroup = Mid$(sLine, 2, -1)
      If sGroup = "Component" Then Break
      Continue
    Endif

    iPos = InStr(sLine, "=")
    If iPos = 0 Then Continue

    sKey = Left$(sLine, iPos - 1)
    sLine = Mid$(sLine, iPos + 1)

    iPos = RInStr(sKey, "[")
    If iPos Then
      sLang = Mid$(sKey, iPos + 1, -1)
      If sLang <> System.Language And If sLang <> $sShortLang Then Continue
      sKey = Left$(sKey, iPos - 1)
    Endif

    Name = sName
    Key = sName
    Type = "*"

    Select Case sKey
      Case "Name", "Description"
        Description = sLine
      Case "Author", "Authors"
        Authors = Split(sLine)
      Case "Implement", "Implements"
        Implement = Split(sLine)
      Case "Need", "Needs"
        Need = Split(sLine)
      ' CASE "Type"
      '   Type = sLine
      '   IF NOT Info.Forms.Exist(Type) THEN Info.Forms[Type] = NEW FormInfo(Type)
      Case "Group"
        sGroup = sLine
      Case "Init"
        $aInit = Split(sLine)
      Case "Control", "Controls"
        aCtrl = Split(sLine)
        Controls.Insert(aCtrl)
        Groups[sGroup] = aCtrl
      Case "Container", "Containers"
        Containers.Insert(Split(sLine))
      Case "MultiContainer", "MultiContainers"
        MultiContainers.Insert(Split(sLine))
      Case "Virtual", "Virtuals"
        Virtuals.Insert(Split(sLine))
      Case "Require", "Requires"
        Require = Split(sLine)
      Case "Exclude", "Excludes"
        Exclude = Split(sLine)
      Case "Alpha"
        Alpha = sLine <> "0"
      Case "DoNotWrite"
        InsertList(DoNotWrite, sLine)
      Case "AlwaysRead"
        InsertList(AlwaysRead, sLine)
      Case "Translate"
        InsertList(Translate, sLine)
    End Select

  Wend

  Close #hFile

End

Public Sub Load()

  Dim hFile As File
  Dim sPath As String
  Dim sLine As String
  Dim sKey As String
  Dim sClass As String
  Dim sParent As String
  Dim hClass As CClassInfo
  Dim sSymbol As String
  Dim hSym As CSymbolInfo
  Dim hForm As Object
  Dim bAgain As Boolean
  Dim bJumpNextClass As Boolean
  Dim sElt As String

  If $bLoaded Then Return

  $bLoaded = True

  'DEBUG "Loading "; Name

  ClassList = New String[]

  If Name <> "gb" Then All["gb"].Load()
  
  For Each sElt In Require
    All[sElt].Load()
  Next

  For Each sElt In Need
    If $cImplement.Exist(sElt) Then Continue
    If $cRescue.Exist(sElt) Then 
      All[$cRescue[sElt]].Load()
    Else 
      Error.Raise("No rescue for " & sElt)
    Endif 
  Next

  For Each sElt In Implement
    $cImplement[sElt] = Name
  Next


  sPath = Main.InfoFilePath &/ Name & ".info"
  ' Patch, as gb.qte and gb.qte.ext are unloadable at the moment
  If Not Exist(sPath) And If Name Like "gb.qte*" Then 
    sPath = Main.InfoFilePath &/ Replace(Name, ".qte", ".qt") & ".info"
  Endif
  hFile = Open sPath For Read

  Repeat

    bAgain = False
    Seek #hFile, 0

    While Not Eof(hFile)
      Line Input #hFile, sLine

      If Left$(sLine) = "#" Then

        sClass = Mid$(sLine, 2)

        bJumpNextClass = $cClass.Exist(sClass)
        If bJumpNextClass Then Continue

        'IF sClass = "Dialog" THEN STOP

        Line Input #hFile, sParent
        If Not sParent Then
          If CComponent.Classes.Exist(sClass) Then
            sParent = sClass
          Endif
        Endif

        If sParent And If Not CComponent.Classes.Exist(sParent) Then
          bAgain = True
          bJumpNextClass = True
          Continue
        Endif

        hClass = New CClassInfo(sClass, sParent)

        CComponent.Classes[sClass] = hClass
        $cClass[sClass] = hClass

        If sClass <> "." Then ClassList.Add(sClass)

        Line Input #hFile, sLine
        hClass.Creatable = InStr(sLine, "C")
        hClass.AutoCreatable = InStr(sLine, "A")
        hClass.Component = Name

        Continue

      Endif

      If bJumpNextClass Then Continue

      sSymbol = sLine
      hSym = New CSymbolInfo
      hClass.Symbols[sSymbol] = hSym

      hSym.Name = sSymbol
      hSym.Class = sClass
      hSym.Component = Name
      Line Input #hFile, hSym.Kind
      Line Input #hFile, hSym.Type
      If hSym.Kind = "C" Then
        Line Input #hFile, hSym.Value
      Else
        Line Input #hFile, hSym.Signature
      Endif
      If Left$(hSym.Kind) = "p" Then
        ' Compatibility
        If Left$(hSym.Type, 2) = "i<" Then
          'hSym.Signature = Mid$(hSym.Type, 3, -1)
          hSym.Type = "i"
        Endif
        ' Properties are now described in "_Properties"
      Endif
      'hSym.Hidden = InStr(sSymbol, "_")
      'hSym.Static = UCase(hSym.Kind) = hSym.Kind AND hSym.Kind <> ":"

    Wend

  Until Not bAgain

  'PRINT "Initializing controls..."

  ' IF Type <> "*" THEN hForm = NEW (Type)
  ' 
  ' IF $aInit THEN
  '   FOR EACH sClass IN $aInit
  '     IF $cClass.Exist(sClass) THEN
  '       $cClass[sClass].BecomeControl(hForm)
  '     ELSE
  '       DEBUG "Control "; sClass; " not found"
  '     ENDIF
  '   NEXT
  ' ENDIF
  ' 
  ' FOR EACH sClass IN Controls
  '   IF $cClass.Exist(sClass) THEN
  '     $cClass[sClass].BecomeControl(hForm)
  '   ELSE
  '     DEBUG "Control "; sClass; " not found"
  '   ENDIF
  ' NEXT
  ' 
  ' TRY hForm.Delete

  Close #hFile

  ClassList.Sort


'CATCH

  'Error.Propagate

End

Public Function _get(Class As String) As CClassInfo

  Return $cClass[Class]

End

